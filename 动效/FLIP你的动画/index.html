<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title>FLIP你的动画 · Hexo</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="FLIP你的动画 - Lovelyun"><meta name="keywords"><meta name="author" content="Lovelyun"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Hexo"><script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><header><div class="header row"><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">FLIP你的动画</h1><div class="post-info">2019-03-04<p id="busuanzi_container_page_pv" class="visit"><span id="busuanzi_value_page_pv"></span><span>次访问</span></p></div><div class="post-content"><p>网页中的动效应该运行在60fps，达到这个帧率并不容易，它去取决于你做了多大的尝试，这里我将用FLIP来帮助你。</p>
<p>我已经写了一个<a target="_blank" rel="noopener" href="https://github.com/googlearchive/flipjs">FLIP库</a>，在这里你可以看到文档和demos。</p>
<p>FLIP本质上是一个原则，而不是框架或库。这是一种思考动画的方式，尝试让浏览器渲染动画的开销尽可能小，如果一切顺利，应该能达到60fps的动画。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一般动画直接开始后，在每帧可能做开销大的计算，而这里我们让动画从头开始，动态的重新计算动效属性，然后让浏览器简单的执行渲染。<br>FLIP代表First,Last,Invert.Play。</p>
<ul>
<li>First: 元素涉及到动效的初值状态</li>
<li>Last: 元素的最终状态</li>
<li>Invert: 指出从动画开始到结束元素要如何变化，比如<code>width</code>、<code>height</code>、<code>opacity</code>。然后用<code>transform</code>、<code>opacity</code>来反向设置。如果元素从开始到结束下移了90px，你就要应用<code>transformY(-90px)</code>，让元素看起来和开始时一样，虽然实际上不是。</li>
<li>Play: 开始变化任何你改变的属性，然后去掉逆变换。因为元素处于最终位置，所以反向设置中的<code>transform</code>、<code>opacity</code>，将使它们从模拟的第一个位置轻松变换到最后一个位置。</li>
</ul>
<p><img src="/../images/2019/flip-layout-6.png" alt="flip-layout-6"><br><img src="/../images/2019/flip-layout-7.gif" alt="flip-layout-7"></p>
<h2 id="代码分解"><a href="#代码分解" class="headerlink" title="代码分解"></a>代码分解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取初始位置</span></span><br><span class="line"><span class="keyword">var</span> first = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置到最终位置</span></span><br><span class="line">el.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;totes-at-the-end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次获取位置信息. 注意这会引起重排.</span></span><br><span class="line"><span class="keyword">var</span> last = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要的话也可以操作其他可计算的样式。</span></span><br><span class="line"><span class="comment">// 但要确保尽量使用只触发重绘的属性，比如transform、opacity</span></span><br><span class="line"><span class="keyword">var</span> invert = first.<span class="property">top</span> - last.<span class="property">top</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invert.</span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translateY(<span class="subst">$&#123;invert&#125;</span>px)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待下一帧，这样我们就知道所有的样式更改都已生效</span></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始动画过程</span></span><br><span class="line">  el.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;animate-on-transforms&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  el.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用transitionend捕获动画结束</span></span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;transitionend&#x27;</span>, tidyUpAnimations);</span><br></pre></td></tr></table></figure>

<p>然而，也可以用即将来临的Web Animations API，这个会更简单，只是需要Web Animations API polyfill，不过这个补丁很轻量，并且确实很实用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取初始位置</span></span><br><span class="line"><span class="keyword">var</span> first = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动到最终位置</span></span><br><span class="line">el.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;totes-at-the-end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最终位置</span></span><br><span class="line"><span class="keyword">var</span> last = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invert.</span></span><br><span class="line"><span class="keyword">var</span> invert = first.<span class="property">top</span> - last.<span class="property">top</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从inverted位置移动到最终last位置.</span></span><br><span class="line"><span class="keyword">var</span> player = el.<span class="title function_">animate</span>([</span><br><span class="line">  &#123; <span class="attr">transform</span>: <span class="string">`translateY(<span class="subst">$&#123;invert&#125;</span>px)`</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">transform</span>: <span class="string">&#x27;translateY(0)&#x27;</span> &#125;</span><br><span class="line">], &#123;</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="attr">easing</span>: <span class="string">&#x27;cubic-bezier(0,0,0.32,1)&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在动画结束时做任何需要的整理</span></span><br><span class="line">player.<span class="title function_">addEventListener</span>(<span class="string">&#x27;finish&#x27;</span>, tidyUpAnimations);</span><br></pre></td></tr></table></figure>
<h2 id="FLIP的用途"><a href="#FLIP的用途" class="headerlink" title="FLIP的用途"></a>FLIP的用途</h2><p>当你在响应到用户输入后用一些动画来响应，这绝对是非常棒的。比如，在Chrome开发峰会上，我展开用户点击的卡片，通常情况下，元素开始和结束的位置、大小都不知道，因为网页是响应式的，元素位置大小都不固定，但FLIP就很有用，它能明确的计算元素，在运行时给出正确的值。</p>
<p>你能够做这种相对昂贵的预计算是因为利用了用户感知。用户和你的网页有交互之后，你有趁他们不注意的100ms时间来做这些。在这100ms内，用户会觉得网站是立刻响应了的，而你只需要在动画过程中保持60fps。</p>
<p>我们可以利用这个感知期(100ms)，通过javascript做<code>getBoundingClientRect</code>操作（或者你非要用不优雅的<code>getComputedStyle</code>），这样我们使动画细腻流畅，利于重绘。</p>
<p>可以用<code>transform</code>和<code>opacity</code>重写动画是最好的，如果你在js或CSS中没有用这些属性，那你可以开始优化了，它们会在你改变布局属性（比如<code>width</code>、<code>height</code>、<code>left</code>、<code>top</code>）时，用开销小的属性重写后达到最好的优化效果。</p>
<p>有时你为了用FLIP需要重新构思你的动画，在多数情况下，我把动画元素单独提取出来，这样我就可以不失真的制作动画了，并且尽可能多的用FLIP。你可能会觉得这样应用过度了，但我觉得不是，因为：</p>
<p>1、大家想这样。我的一个同事兼好友最近做了一个关于人们想从新闻app上得到什么的调查，最多的回答（这让他很吃惊）不是离线支持、同步、通知，或类似的东西，而是浏览平滑——没有晃动、没有卡顿、没有颤抖。</p>
<p>2、程序员就是这么做的。当然，这是一种主观的衡量标准，但我已经听过很多次，程序员花了好几天的时间才把过渡做得恰到好处。通过运维服务，我们我网站加载速度都很快，用户会根据他们的操作体验来评价我们的网站，而这些细节将使我们与众不同。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用FLIP时要注意以下几点：<br>1、不要超过100ms的窗口期。<br>记住一定不要超过100ms，如果超过了，你的应用会表现得没反应。通过DevTools关注它，了解是否超出了100ms。</p>
<p>2、认真设计动画。<br>想象下，你在运行一个动画，做一些位移和透明度得改变，然后你决定运行另外一个动画，它需要大量得预计算，这会打断之前运行中的动画，这种情况很糟糕。这里的关键是保证你的预计算工作是在空闲时间或上面说过的100ms窗口期内完成的，这两个动画不会互相阻断。</p>
<p>3、内容会失真。<br>当你使用<code>scale</code>和<code>transform</code>，一些元素会失真。上面说过，我会调整一点结构，来不失真的使用FLIP，不过这可能有争议。</p>
<p>总结<br>我喜欢用FLIP来考虑动画的实现，因为它让JS和CSS配合的很好，用JS来计算，但用CSS处理动画过程，你不需要用CSS来实现动画，虽然你可以只用简单的Web Animations API或JS，或什么其他的简单的方式。主要的一点是，你正在降低每帧的复杂性和成本(通常意味着<code>transform</code>和<code>opacity</code>)，以尽量为用户提供最好的体验。</p>
<p>所以，使用FLIP吧。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://aerotwist.com/blog/flip-your-animations/">Aerotwist - FLIP Your Animations</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3cplus.com/javascript/animating-layouts-with-the-flip-technique.html">FLIP技术给Web布局带来的变化_JavaScript, FLIP, Animation, Web动画 教程_w3cplus</a></li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/js/JavaScript%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BD%A2%E7%8A%B6/" title="JavaScript引擎基础之形状" class="prev">PREV</a><a href="/js/Debouncing%E5%92%8CThrottling/" title="Debouncing和Throttling" class="next">NEXT</a></div><div class="copyright"><p>© 2018 - 2024 <a href="https://github.com/lovelyun" target="_blank">Lovelyun</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://apps.bdimg.com/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>