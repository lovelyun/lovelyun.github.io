{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Lovelyun","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"js遍历那些事儿","slug":"js遍历那些事儿","date":"2024-08-02T14:14:16.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/js遍历那些事儿/","permalink":"http://example.com/js/js%E9%81%8D%E5%8E%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/","excerpt":"","text":"本文总结js中的各种常用遍历。 基本用法for最基本的遍历写法，通过索引来遍历。 12345let arr = [1, 2, 3]for(let i = 0; i &lt; arr.length; i++)&#123; console.log(i) // 索引，数组下标 0, 1, 2 console.log(arr[i]) // 数组下标所对应的元素 1, 2, 3&#125; forEach写法比for简便，遍历所有元素，不返回任何值。 12let arr = [1, 2, 3]arr.forEach(i =&gt; console.log(i)) // 1, 2, 3 map映射，常用于基于原数组返回新数组(不改变原数组)。 1234let arr = [1, 2, 3]const newArr = arr.map(i =&gt; i + 1)console.log(arr) // [1, 2, 3]console.log(newArr) // [2, 3, 4] filter筛选，常用于过滤原数组来产生新数组，不改变原数组。 1234let arr = [1, 2, 3]const newArr = arr.filter(i =&gt; i &gt; 1)console.log(arr) // [1, 2, 3]console.log(newArr) // [2, 3] 以上4种遍历基本满足大部分需求，下面看一些用的较少的遍历方法。 reduce将数组中的元素逐个进行处理，并将它们合并为一个值。功能十分强大,回调函数可以进行各种复杂的操作，包括条件判断、对象构建等。 语法： 1array.reduce(function(total, currentValue, currentIndex, arr), initialValue) callback （执行数组中每个值的函数，包含四个参数） total- 必需 （初始值, 或者计算结束后的返回值） currentValue - 必需 （数组中当前被处理的元素） currentIndex - 可选 （当前元素在数组中的索引） arr - 可选 （调用 reduce 的数组） initialValue - 可选 （作为第一次调用 callback 的第一个参数,如果不提供，第一次回调会使用数组的第一个元素） 示例（最简单的累加）： 1234567891011let arr = [1, 2, 3]const sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index) return prev + cur&#125;)console.log(arr, sum)// 输出：// 1 2 1// 3 3 2// [1, 2, 3] 6 比如我们要统计字符串中每个字母出现的次数： 123456789const arrString = &#x27;abcdaabc&#x27;arrString.split(&#x27;&#x27;).reduce(function(res, cur) &#123; res[cur] = (res[cur] || 0) + 1 return res&#125;, &#123;&#125;)// 输出：// &#123;a: 3, b: 2, c: 2, d: 1&#125; every条件都满足返回true。 12345let arr = [1, 2, 3]const res = arr.every((item, index) =&gt; &#123; return item &gt; 1&#125;)console.log(res) // false some有一个条件满足返回true。 12345let arr = [1, 2, 3]const res = arr.some((item, index) =&gt; &#123; return item &gt; 1&#125;)console.log(res) // true for…in主要用于遍历对象的可枚举属性(还会遍历原型链上的可枚举属性)。 遍历数组(不推荐，会遍历数组的所有可枚举属性，包括非索引属性和原型链上的属性)： 123456789let arr = [1, 2, 3]for(let index in arr) &#123; console.log(index, arr[index])&#125;// 输出：// 0 1// 1 2// 2 3 遍历对象： 123456789let obj = &#123; a: 1, b: 2, c: 3 &#125;for(let key in obj) &#123; console.log(key, obj[key])&#125;// 输出：// a: 1// b: 2// c: 3 for…of用于遍历可迭代对象（例如 Array, Map, Set, String, TypedArray，NodeList以及其他 DOM 集合，arguments 对象等）的可迭代属性（不可迭代属性会被忽略）。 12345678910const arr = [1, 2, 3];for (const value of arr) &#123; console.log(value);&#125;// 输出：// 1// 2// 3 for...in和for...of的区别： 12345678910111213Object.prototype.objCustom = function () &#123;&#125;Array.prototype.arrCustom = function () &#123;&#125;let iterable = [3, 5, 7]iterable.foo = &quot;hello&quot;for (let i in iterable) &#123; console.log(i) // 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;&#125;for (let i of iterable) &#123; console.log(i) // 3, 5, 7&#125; 可以看到，主要有3点不同： 1.for...in遍历key，for...of遍历value 2.for...in遍历的是可枚举属性，for...of遍历的是可迭代属性 3.对于array的不可迭代元属性objCustom、arrCustom和实例属性foo，在for...of循环中都被忽略 Object.keys，values，entries对于普通对象（需要注意和map的区别）： Object.keys(obj)：返回一个包含该对象所有的键的数组。 Object.values(obj)：返回一个包含该对象所有的值的数组。 Object.entries(obj)：返回一个包含该对象所有 [key, value] 键值对的数组。 1234567let user = &#123; name: &quot;John&quot;, age: 30,&#125;console.log(Object.keys(user)) // [&quot;name&quot;, &quot;age&quot;]console.log(Object.values(user)) // [&quot;John&quot;, 30]console.log(Object.entries(user)) // [ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;,30] ] Object.entries把 obj 变成由键&#x2F;值对组成的数组，然后使用 Object.fromEntries可以将结果转回成原来的对应 1234567let user = &#123; name: &quot;John&quot;, age: 30,&#125;console.log(Object.entries(user)) // [ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;,30] ]console.log(Object.fromEntries(Object.entries(user))) // &#123; name: &#x27;John&#x27;, age: 30 &#125; 中断循环中断循环,推荐使用break，continue不退出循环，只跳过当前循环，if条件判断替换continue，可读性更高。for循环（for&#x2F;for...in&#x2F;for...of）可通过break退出循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243let arr = [1, 2, 3]for (let i = 0; i &lt; arr.length; i++) &#123; console.log(i) if(i === 1) break&#125;// 输出：// 0// 1for (let value of arr) &#123; console.log(value) if(value === 1) break&#125;// 输出：// 1let obj = &#123; a: 1, b: 2, c: 3 &#125;for(let key in obj) &#123; console.log(key, obj[key]) if (key === &#x27;a&#x27;) break&#125;// 输出：// a 1try &#123; let arr = [1, 2, 3] arr.forEach(i =&gt; &#123; console.log(i) if(i === 1) &#123; throw new Error(&#x27;End Iterative&#x27;) &#125; &#125;)&#125; catch(e) &#123; console.log(e)&#125;// 输出：// 11// Error: End Iterative 总结，有for关键字时，可以通过break退出循环，forEach可以通过throw Error的方式退出循环(但不推荐这样写，推荐用for)。 异步当遍历碰到async、 await、 Promise时，又该怎么写呢？ 1234let arr = [20, 10, 30]const sleep = (ms) =&gt; &#123; return new Promise((resolve) =&gt; setTimeout(resolve, ms))&#125; 上面有个数组arr和耗时操作sleep，如果没有耗时操作，就是下面同步的写法： 12345678910111213141516const syncRes = arr.map((i) =&gt; &#123; console.log(&#x27;loop&#x27;, i) console.log(i) return i&#125;)console.log(&#x27;syncRes&#x27;, syncRes)// 输出：// loop 20// 20// loop 10// 10// loop 30// 30// syncRes [20, 10, 30] 如果有耗时操作，像下面这样，怎么保持输出还是[20, 10, 30]呢？ 12await sleep(i)return i 最简单的方法可以用for循环（for&#x2F;for...in&#x2F;for...of都一样）： 1234567891011121314151617let asyncRes1 = []for (let i of arr)&#123; console.log(&#x27;loop&#x27;, i) await sleep(i) console.log(i) asyncRes1.push(i)&#125;console.log(&#x27;asyncRes1&#x27;, asyncRes1)// 输出：// loop 20// 20// loop 10// 10// loop 30// 30// asyncRes1 [20, 10, 30] map可以像这样Promise.all(arr.map(async (...) =&gt; ...))： 1234567891011121314151617const asyncRes = await Promise.all(arr.map(async (i) =&gt; &#123; console.log(&#x27;loop&#x27;, i) await sleep(i) console.log(i) return i&#125;))console.log(&#x27;asyncRes&#x27;, asyncRes)// 输出：// loop 20// loop 10// loop 30// 10// 20// 30// asyncRes [20, 10, 30] 如果不用Promise.all，就是下面的效果： 1234567891011121314151617const asyncRes = arr.map(async (i) =&gt; &#123; console.log(&#x27;loop&#x27;, i) await sleep(i) console.log(i) return i&#125;)console.log(&#x27;asyncRes&#x27;, asyncRes)// 输出：// loop 20// loop 10// loop 30// asyncRes [Promise, Promise, Promise]// 10// 20// 30 碰到reduce时async (prev, cur) =&gt; await prev： 123456789101112131415161718const asyncRes = await arr.reduce(async (prev, cur) =&gt; &#123; console.log(&#x27;loop&#x27;, cur) await sleep(cur) const res = (await prev) + cur console.log(res) return res&#125;, 0)console.log(&#x27;asyncRes&#x27;, asyncRes)// 输出：// loop 20// loop 10// loop 30// 20// 30// 60// asyncRes 60 在forEach、filter等其他循环中需要使用异步，先用map、reduce、for...of处理。 总结 基本用法要熟记特性，灵活选用 需要中断就用for（for&#x2F;for...in&#x2F;for...of），使用break退出 碰到异步用for（for&#x2F;for...in&#x2F;for...of）&#x2F;map&#x2F;reduce 参考文档 Asynchronous array functions in Javascript","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"详解CSS Grid布局","slug":"详解CSS Grid布局","date":"2022-11-18T17:00:04.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"css/详解CSS Grid布局/","permalink":"http://example.com/css/%E8%AF%A6%E8%A7%A3CSS%20Grid%E5%B8%83%E5%B1%80/","excerpt":"","text":"CSS Grid 布局简介CSS Grid是一种二维的布局方式，和以前的布局方式完全不同，CSS常用来给页面布局，但做的总不够好，以前我们用table布局，后来用float、position、inline-block，这些方式本质上都是hack，缺少一些重要的特性（比如垂直居中），flex布局是一个很好的布局方式，但它基于轴的布局方式在其他方面用处更大，并且可以和Grid布局很好的配合使用，Grid布局是专门用来解决我们一直以来布局页面时所碰到的各种问题的。 本指南围绕Grid布局的最新特性讲解，所以不会考虑老旧的浏览器兼容性。 CSS Grid基础到2017年3月，大部分浏览器都支持Grid布局（无需前缀）：Chrome(包括Android)、Firefox、Safari(包括IOS)、Opera。IE10和IE11也能通过一定的途径支持，所以现在是时候使用Grid布局了。 首先你需要一个父元素，并设置dispaly: grid，通过grid-template-columns和grid-template-rows设置列和行的大小，然后向父元素中添加子元素，并设置grid-column和grid-row属性，和flex布局类似，子元素的原始顺序并不重要，CSS可以任意控制它们的顺序，这使得通过媒体查询排列元素变得超级简单。想象下你把整个页面设置成grid布局，然后对不同的屏幕宽度自适应时完全重新排列，只需要几行CSS。Grid是有史以来引入的最强大的CSS模块之一。 重要的CSS Grid术语在深入学习Grid布局之前，先了解一些重要的术语，它们有些相似，如果不先了解，后面就比较容易混淆，不过不用担心，这些概念并不多。 Grid Container应用display: grid的元素，是所有grid items的直接父级。下面的例子中，container就是grid container。 12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item item-1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item item-2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item item-3&quot;&gt; &lt;/div&gt;&lt;/div&gt; Grid ItemGrid Container的子元素，下面的例子中，item元素就是grid item，但sub-item不是。 1234567&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p class=&quot;sub-item&quot;&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;/div&gt;&lt;/div&gt; Grid LineGrid Line是用来构成网格布局的分隔线。它们可以是垂直的(“列网格线”)或水平的(“行网格线”)，位于行或列的任意一侧。这里的黄线是列网格线的一个例子。 Grid CellGrid Cell是相邻两行和相邻两列之间的区域，称为网格单元，下图黄色部分是行网格线1和2，列网格线2和3之间的网格单元。 Grid TrackGrid Track是相邻网格线之间的区域，你可以理解成一行或一列网格。下图黄色部分是第2和第3行网格线之间的Grid Track。 Grid AreaGrid Area是由4条网格线围起来的区域。一个Grid Area可以由若干个网格单元组成，下图黄色部分的是行网格线1和3，列网格线1和3围起来的Grid Area。 CSS Grid属性CSS Grid属性分为2类，分别是用在父元素和子元素上的。 用在父元素Grid Container上的属性 display grid-template-columns grid-template-rows grid-template-areas grid-template grid-column-gap grid-row-gap grid-gap justify-items align-items place-items justify-content align-content place-content grid-auto-columns grid-auto-rows grid-auto-flow grid 1、display 123.container &#123; display: grid | inline-grid;&#125; 可取值： grid——生成块级grid inline-grid——生成行内grid 2、grid-template-columns、grid-template-rows用一行空格分开的值来定义网格的行和列，这些值代表Grid Track的大小，空格代表分隔线Grid Line。 track-size —— 可以是一个长度、百分比、或者fr单位的值 line-name —— 你对网格线的命名 1234567891011121314.container &#123; grid-template-columns: ... ...; /* e.g. 1fr 1fr minmax(10px, 1fr) 3fr repeat(5, 1fr) 50px auto 100px 1fr */ grid-template-rows: ... ...; /* e.g. min-content 1fr min-content 100px 1fr max-content */&#125; 网格线自动取正值，-1是最后一行的备选值。 但是你也可以直接给网格线命名，注意名称时的括号语法： 1234.container &#123; grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]; grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];&#125; 需要注意的是分隔线可以有多个名字。比如下面第二条线有2个名字：row1-end 和 row2-start 123.container &#123; grid-template-rows: [row1-start] 25% [row1-end row2-start] 25% [row2-end];&#125; 如果需要定义重复的部分，可以用repeat()来简化： 123.container &#123; grid-template-columns: repeat(3, 20px [col-start]);&#125; 上面的写法和下面的等价： 123.container &#123; grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start];&#125; 如果多条分割线使用同样的名字，则可以通过名字加计数来区分。 123.item &#123; grid-column-start: col-start 2;&#125; fr单位可以把父元素空闲部分按比例划分给Grid Track。比如下面的写法会把Grid Track设为父元素宽度的三分之一。 123.container &#123; grid-template-columns: 1fr 1fr 1fr;&#125; 空闲部分是非自适应元素计算完毕后剩下的空间。比如下面的例子中，对fr可用的空间不包括50px: 123.container &#123; grid-template-columns: 1fr 50px 1fr 1fr;&#125; 3、grid-template-areasgrid-template-areas用名字定义网格区域，重复网格名字使该区域包括覆盖的网格单元，句号代表空网格单元。语法本身让网格结构十分明了。 可取值： grid-template-areas —— 网格区域名字 . —— 空的网格单元 none —— 未定义网格区域 12345.container &#123; grid-template-areas: &quot;&lt;grid-area-name&gt; | . | none | ...&quot; &quot;...&quot;;&#125; 举个例子： 12345678910111213141516171819202122.item-a &#123; grid-area: header;&#125;.item-b &#123; grid-area: main;&#125;.item-c &#123; grid-area: sidebar;&#125;.item-d &#123; grid-area: footer;&#125;.container &#123; display: grid; grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: &quot;header header header header&quot; &quot;main main . sidebar&quot; &quot;footer footer footer footer&quot;;&#125; 上面的代码会创建一个3行4列的网格区域，第一行是header区域，中间的一行由2块main区域、1块空单元和1块sidebar区域组成，最后一行是footer区域。 每一行的网格单元数量要相同。可以用任意数量的紧挨着的句号来声明一个空单元格。只要句号之间没有空格，它们就代表一个空单元格。 需要注意的是，grid-template-areas命名的是区域，当使用该属性时，区域两端的线会被自动命名。如果网格区域被命名成foo，该区域的第1行和第1列分隔线都会自动名称成foo-start，最后1行和最后1列的分隔线被命名成foo-end，这也意味着一些分隔线会有多个名字，比如上面的例子中，有一条分隔线有3个名字：header-start， main-start， 和 footer-start。 4、grid-templategrid-template可以把grid-template-rows，grid-template-columns和 grid-template-areas简写到一起。 可取值： none —— 3个属性都设为默认值。 &lt;grid-template-rows&gt; &#x2F; &lt;grid-template-columns&gt; —— 分别设置grid-template-rows和grid-template-columns的值，并把grid-template-areas设为none。 123.container &#123; grid-template: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;;&#125; 它的值还可以更复杂，但使用起来更方便： 123456.container &#123; grid-template: [row1-start] &quot;header header header&quot; 25px [row1-end] [row2-start] &quot;footer footer footer&quot; 25px [row2-end] / auto 50px auto;&#125; 上面的写法和下面的等价： 1234567.container &#123; grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto; grid-template-areas: &quot;header header header&quot; &quot;footer footer footer&quot;;&#125; 由于grid-template不会重置隐式网格属性(grid-auto-columns， grid-auto-rows和grid-auto-flow)，这可能是您在大多数情况下想要做的，因此建议使用grid属性而不是grid-template。 5、column-gap、row-gap、grid-column-gap、grid-row-gap定义分隔线的粗细。可以理解成设置行或列的间距。 &lt;line-size&gt; —— 长度值 123456789.container &#123; /* 新写法 */ column-gap: &lt;line-size&gt;; row-gap: &lt;line-size&gt;; /* 旧写法 */ grid-column-gap: &lt;line-size&gt;; grid-row-gap: &lt;line-size&gt;;&#125; 举个例子： 123456.container &#123; grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; column-gap: 10px; row-gap: 15px;&#125; 间距只在行或列中间存在，边缘部分不存在。 需要注意的是，grid前缀会被移除，grid-column-gap 和 grid-row-gap 会被重命名成 column-gap 和 row-gap，无前缀的语法已经被Chrome 68+， Safari 11.2 Release 50+， and Opera 54+支持。 6、gap、grid-gaprow-gap 和 column-gap的简写形式。 可取值： &lt;grid-row-gap&gt; &lt;grid-column-gap&gt; —— 长度值 1234567.container &#123; /* 新写法 */ gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; /* 旧写法 */ grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;&#125; 举个例子： 12345.container &#123; grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; gap: 15px 10px;&#125; 如果没有定义row-gap的值，它会自动等于column-gap。 7、justify-itemsgrid items的水平对齐方式，适用container中所有的grid items。 可取值： start —— 向单元格的起始边对齐。 end —— 向单元格的尾部对齐。 center —— 单元格内居中。 stretch —— 宽度填满单元格（这是默认值）。 123.container &#123; justify-items: start | end | center | stretch;&#125; 举个例子： 123.container &#123; justify-items: start;&#125; 123.container &#123; justify-items: end;&#125; 123.container &#123; justify-items: center;&#125; 123.container &#123; justify-items: stretch;&#125; 该对齐方式也可以用justify-self单独给grid items设置。 8、align-itemsgrid items的垂直对齐方式，值和用法和justify-items一样。该对齐方式也可以用align-self单独给grid items设置。 9、place-itemsalign-items 和 justify-items的简写方式。 可取值： &lt;align-items&gt; / &lt;justify-items&gt; —— 第1格值代表align-items，第2个值代表justify-items，如果第2个值省略了，第1个值会默认代表这2个属性。 1234.center &#123; display: grid; place-items: center;&#125; 10、justify-content有时整体网格的大小比容器小，比如所有的网格都是用px指定了大小，这时可以设置网格在容器中的对齐方式，justify-content设置网格的水平对齐方式。 可取值： start —— 向容器的头部对齐。 end —— 向容器的尾部对齐。 center —— 在容器中水平居中。 stretch —— 重新适配items的大小把容器的宽度填满。 space-around —— 使每个网格的列间距相等，两边的留白是列间距的一半。 space-between —— 使每个网格的列间距相等，两边不留白。 space-evenly —— 使每个网格的列间距相等，两边的留白等于列间距。 123.container &#123; justify-content: start | end | center | stretch | space-around | space-between | space-evenly;&#125; 举个例子： 123.container &#123; justify-content: start;&#125; 123.container &#123; justify-content: end;&#125; 123.container &#123; justify-content: center;&#125; 123.container &#123; justify-content: stretch;&#125; 123.container &#123; justify-content: space-around;&#125; 123.container &#123; justify-content: space-between;&#125; 123.container &#123; justify-content: space-evenly;&#125; 11、align-content值和用法和justify-content一样，区别是align-content用来设置垂直方向的对齐方式。 12、place-contentjustify-content和align-content的简写方式。 可取值： &lt;align-content&gt; &#x2F; &lt;justify-content&gt;13、grid-auto-columns、grid-auto-rows指定任何自动生成的grid tracks的大小。 用法： 1234.container &#123; grid-auto-columns: &lt;track-size&gt; ...; grid-auto-rows: &lt;track-size&gt; ...;&#125; 举个例子，来看看隐式grid tracks是怎么创建的。 1234.container &#123; grid-template-columns: 60px 60px; grid-template-rows: 90px 90px;&#125; 上面的代码创建了一个2x2的网格。接下来用grid-column和grid-row设置item的位置： 12345678.item-a &#123; grid-column: 1 / 2; grid-row: 2 / 3;&#125;.item-b &#123; grid-column: 5 / 6; grid-row: 2 / 3;&#125; 这时item-b就超出了2x2的网格范围，超出部分会默认创建隐式的grid tracks，但是这些隐式的grid tracks的宽度是0，这时我们就可以通过grid-auto-columns和grid-auto-rows为它们设置宽度： 123.container &#123; grid-auto-columns: 60px;&#125; 14、grid-auto-flowgrid-auto-flow控制item的自动排列方式。 可取值： row —— 按顺序填充每一行，必要时新增行。 column —— 按顺序填充每一列，必要时新增列。 dense —— 较小的item排在前面。 123.container &#123; grid-auto-flow: row | column | row dense | column dense;&#125; 注意dense只是虚拟的改变items的顺序，这可能导致顺序混乱。 举个例子： 1234567&lt;section class=&quot;container&quot;&gt; &lt;div class=&quot;item-a&quot;&gt;item-a&lt;/div&gt; &lt;div class=&quot;item-b&quot;&gt;item-b&lt;/div&gt; &lt;div class=&quot;item-c&quot;&gt;item-c&lt;/div&gt; &lt;div class=&quot;item-d&quot;&gt;item-d&lt;/div&gt; &lt;div class=&quot;item-e&quot;&gt;item-e&lt;/div&gt;&lt;/section&gt; 接着你定义了一个2x5的网格，并把grid-auto-flow设为row（row也是默认值）： 123456.container &#123; display: grid; grid-template-columns: 60px 60px 60px 60px 60px; grid-template-rows: 30px 30px; grid-auto-flow: row;&#125; 在给item定位的时候，你只设置了2个： 12345678.item-a &#123; grid-column: 1; grid-row: 1 / 3;&#125;.item-e &#123; grid-column: 5; grid-row: 1 / 3;&#125; 这时我们的网格看起来就是这样的： 如果我们把grid-auto-flow设为column,item-b， item-c 和 item-d 就会按顺序沿着列来排： 123456.container &#123; display: grid; grid-template-columns: 60px 60px 60px 60px 60px; grid-template-rows: 30px 30px; grid-auto-flow: column;&#125; 15、grid可以把 grid-template-rows， grid-template-columns， grid-template-areas， grid-auto-rows， grid-auto-columns， 和 grid-auto-flow 写到一起。 可取值： none —— 所有属性设为默认值。 &lt;grid-template&gt; —— 跟 grid-template 一样。 &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;? [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-rows&gt;? / &lt;grid-template-columns&gt;比如下面两种写法等价(&lt;grid-template-rows&gt; / &lt;grid-auto-columns&gt;)： 12345678.container &#123; grid: 100px 300px / 3fr 1fr;&#125;.container &#123; grid-template-rows: 100px 300px; grid-template-columns: 3fr 1fr;&#125; 下面的两种写法等价(auto-flow &lt;grid-auto-rows&gt; / &lt;grid-template-columns&gt;)： 12345678.container &#123; grid: auto-flow / 200px 1fr;&#125;.container &#123; grid-auto-flow: row; grid-template-columns: 200px 1fr;&#125; 下面的两种写法等价(auto-flow dense &lt;grid-auto-rows&gt; / &lt;grid-template-columns&gt;)： 123456789.container &#123; grid: auto-flow dense 100px / 1fr 2fr;&#125;.container &#123; grid-auto-flow: row dense; grid-auto-rows: 100px; grid-template-columns: 1fr 2fr;&#125; 下面的两种写法等价(&lt;grid-template-rows&gt; / auto-flow &lt;grid-auto-columns&gt;)： 123456789.container &#123; grid: 100px 300px / auto-flow 200px;&#125;.container &#123; grid-template-rows: 100px 300px; grid-auto-flow: column; grid-auto-columns: 200px;&#125; 还有更复杂但更简洁的写法，下面的两种写法等价： 12345678910111213.container &#123; grid: [row1-start] &quot;header header header&quot; 1fr [row1-end] [row2-start] &quot;footer footer footer&quot; 25px [row2-end] / auto 50px auto;&#125;.container &#123; grid-template-areas: &quot;header header header&quot; &quot;footer footer footer&quot;; grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto;&#125; 用在子元素Grid Item上的属性 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self place-self 1、grid-column-start、grid-column-end、grid-row-start、grid-row-end通过指定分隔线的方式定义网格单元在网格中的位置， grid-column-start&#x2F;grid-row-start是网格单元开始的地方，grid-column-end&#x2F;grid-row-end是结束的地方。 可取值： &lt;line&gt; —— 代表分隔线的数字或者名字。 span &lt;number&gt; —— 包括指定数量的网格单元。 span &lt;name&gt; —— 包括单元格直到碰到指定名字的分隔线。 auto —— 自动放置，默认1个单元格。举个例子： 123456.item-a &#123; grid-column-start: 2; grid-column-end: five; grid-row-start: row1-start; grid-row-end: 3;&#125; 123456.item-b &#123; grid-column-start: 1; grid-column-end: span col4-start; grid-row-start: 2; grid-row-end: span 2;&#125; 如果没有指定grid-column-end&#x2F;grid-row-end，item默认包含1个单元。 item还能彼此覆盖，可以用z-index控制层级。 2、grid-column、grid-rowgrid-column-start、grid-column-end、grid-row-start、grid-row-end的简写形式。 可取值： &lt;start-line&gt; / &lt;end-line&gt; —— 写法和非简写值一样。 1234.item &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;&#125; 举个例子： 1234.item-c &#123; grid-column: 3 / span 2; grid-row: third-line / 4;&#125; 3、grid-areagrid-area给item命名，这样使用grid-template-areas可以直接引用item的名字。并且此属性还可以作为 grid-row-start+grid-column-start+grid-row-end+grid-column-end的简写形式。 可取值： &lt;name&gt; —— item的名字。 &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt; —— 代表分隔线的数字或名字。 123.item &#123; grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 举个例子： 给item命名： 123.item-d &#123; grid-area: header;&#125; 简写 grid-row-start+grid-column-start+grid-row-end+grid-column-end： 123.item-d &#123; grid-area: 1 / col4-start / last-line / 6;&#125; 4、justify-self设置item在单元格内的水平对齐方式。 123.item &#123; justify-self: start | end | center | stretch;&#125; 举个例子： 123.item-a &#123; justify-self: start;&#125; 123.item-a &#123; justify-self: end;&#125; 123.item-a &#123; justify-self: center;&#125; 123.item-a &#123; justify-self: stretch;&#125; 5、align-self值和用法和justify-self一样，区别是align-self用来设置垂直方向的对齐方式。 6、place-selfplace-self是 align-self 和 justify-self的简写形式。 可取值： auto —— 默认对齐模式。 &lt;align-self&gt; / &lt;justify-self&gt; —— 第1个值是align-self，第2个值是justify-self，如果只有一个值，这个值会赋值给align-self和justify-self。 特殊的单位和函数单位fr你可能会在grid布局中使用很多分数单位，比如fr，来代表剩余空间的一部分，就像这样用，表示25%和75%: 1grid-template-columns: 1fr 3fr; 这种写法比%更可靠，比如你增加了列数，就会破坏百分比的宽度，但是分数单位fr可以和其他单位更好的组合使用： 1grid-template-columns: 50px min-content 1fr; 大小关键字在设置行或列的大小时，可以用各种单位，比如px、rem、%等等，还可以用一些关键字： min-content: 内容的最小宽度。比如一行文字E pluribus unum，会占用的最小宽度是单词pluribus的宽度。 max-content: 内容的最大宽度。比如一行文字E pluribus unum，能占用的最大宽度就是一整行句子。 auto: 和fr类似，但优先级低于fr。 fit-content: 使用可用空间，但不小于min-content，不大于max-content。 fractional units: 分数单位fr。 大小函数 minmax() —— 设置大小范围，minmax(最小值,最大值)。 min() max() repeat()函数和关键字repeat()函数可以使写法更简洁： 1234567grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;/* 简洁的写法: */grid-template-columns: repeat(8, 1fr);/* 下面的情况更新凸显简洁: */grid-template-columns: repeat(8, minmax(10px, 1fr)); repeat()和关键字结合时，会更加奇特： auto-fill: 在一行中放入尽可能多的列，即使它们是空的。 auto-fit： 把所有列都放进去，增加列来填充空间即使是空的列。这就有了CSS网格中最著名的写法，也是有史以来最伟大的CSS技巧之一: 1grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); masonry著名的瀑布流布局： 12345.container &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: masonry;&#125; 详情可以看这篇文章native-css-masonry-layout-css-grid subgridgrid-template-columns: subgrid;目前还只有 Firefox 支持，不做详细说明，有兴趣的可以看原文。","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[]},{"title":"Shutterstock Editor关于Canvas和WebGL图片滤镜的实现","slug":"Shutterstock Editor关于Canvas和WebGL图片滤镜的实现","date":"2022-08-11T16:52:55.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/Shutterstock Editor关于Canvas和WebGL图片滤镜的实现/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/Shutterstock%20Editor%E5%85%B3%E4%BA%8ECanvas%E5%92%8CWebGL%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"Shutterstock Editor是一个简单易用且专业的图片设计工具，对于这类工具来说，图片滤镜都是一个很重要的功能，Shutterstock Editor也提供了强大的支持，本文主要介绍Shutterstock Editor如何在各种浏览器和硬件的限制下实现图片滤镜。 最终效果 Shutterstock Editor有2种滤镜，一种是应用预设的滤镜效果，我们称为filters，另一种是应用一系列的滤镜，我们称为effects，比如对比度、亮度。filters通常由多个effects组成，用户可以在任何时候用filters和effects，所以处理步骤可能多达20步。 effects效果是通过滑杆控制，滤镜性能很影响用户体验。所以我们要尽量以60帧&#x2F;秒的速度来处理图片，1000ms分成60帧后，每帧大概有16ms的时间，再把这16ms分给多个effects，每一步effects就只剩下不到1ms。JavaScript速度很快，但是用户速度更快，所以我们使用CPU来处理图片，才能尽可能达到这个速度，GPU不可用时，再降级到CPU来处理。 使用CPU为了说明图片滤镜是怎么实现的，我们从CPU是如何处理的说起。Shutterstock Editor的图片是绘制在canvas上的，这意味着图片数据可以通过getImageData得到，图片像素点以r（红）、g（绿）、b（蓝）、a（透明度）的顺序存在一维数组里，于是，使用CPU处理图片滤镜，我们要这样做： 通过getImageData获取图片数据。 遍历上一步获取到的像素点数组，对每个像素点应用滤镜算法。一个简单的滤镜算法，比如灰度，只是取颜色通道r、g、b的加权平均值，把均值再赋值给r、g、b。 再次遍历像素点，应用下一个滤镜算法。 通过putImageData把处理结果更新到canvas上。 比较好的电脑上（比如MacBook Pro i7、 Chrome 56），CPU处理1500px分辨率的图片，应用一次滤镜算法耗时约40到120ms，这些滤镜处理程序很快就会堆积起来，由于运行在UI线程，这会阻塞页面操作，所以使用CPU处理图片滤镜只是个备选，使用GPU来处理是更好的选择。 使用GPU同样是canvas，我们可以通过WebGL来使用GPU处理图片： 为图片创建texture对象，存储到GPU中。 第一次使用滤镜时，GPU把代码编译成二进制格式。 GPU对texture运行编译后的代码，同时处理大量像素。 对每个滤镜效果执行一次处理。 把最后的处理结果texture更新到canvas上。 跟CPU处理滤镜类似，但是速度快得多。同样的电脑，对同样的图片应用一次滤镜处理的时间变成0.2到0.4ms，时间更多的是消耗在canvas和GPU之间的图片数据传输上，甚至连续处理多个滤镜效果也不会影响到60fps的渲染目标。 WebGL的缺点WebGL的缺点如下： WebGL的实现因浏览器、操作系统的硬件驱动和硬件而异。 错误处理有限。 学习曲线陡峭。 Texture的尺寸有限制，所以处理大尺寸的图片需要一些特殊处理。 因此，当WebGL不可用，或者不能实现我们的滤镜效果，或者抛出错误时，我们再用CPU来处理。 WebGL滤镜原理我们用一个例子来说明WebGL是怎么处理图片的，上图要变成下图，需要的设置如右图： 首先，把原图的texture（我们命名为originalTexture）传到GPU，再创建两个和原图宽高一样的texture（命名为textureA 和 textureB），当我们对图片应用不同的滤镜处理程序时，把处理结果在textureA 和 textureB之间来回传，直到所有的处理步骤都执行完。 最后一个滤镜程序一执行完，我们就把textureB的内容写到页面的canvas上，如果上图中的Brightness或者其他某个设置变了，我们就再运行一次所有的滤镜程序。出于内存的考虑，为了提升性能，可能不会每次都从第一个滤镜程序开始，但对于GPU来说，滤镜几乎不会有性能问题。 处理大图Shutterstock处理的图片尺寸通常都大于8000x5000px，有的用户的图片会更大，为了保持处理速度，我们通常预览图用小图，只有最终效果图会用原图，所以处理大图也很重要，对此，我们先了解到一些限制： 不同的浏览器，对canvas的尺寸限制从5000px到12000px不等； 不同的硬件，WebGL的texture尺寸限制从2048px到16384px不等。 所以，对于大图，我们把它分成小片，每片是2048px x 2048px，这个尺寸在大多数硬件和浏览器上都没问题，并且可以让预览的小图在显示在一个小片上，这样除了最终的原始尺寸图片渲染，我们不需要再分片。 分片处理分片后是怎么处理图片滤镜的呢？你的第一反应可能是这样的： 大图被分成挨着的小图，每个小图都可以用作WebGL的texture，但是这对Shutterstock Editor来说还不行，因为有的滤镜效果，比如模糊就有问题。类似模糊这种滤镜效果，需要每个像素点周围的像素点一起做运算，上面这种分片方法，导致分片后小图周围的像素点丢失，对这些小图分别应用滤镜程序后，它们的拼接处会有明显的分割线： 为了能实现类似模糊的这种需要周围的像素点来运算的滤镜效果，我们让分片的小图重叠，就像下面这样： 这样分片有两个重要规则：1、重叠部分是滤镜程序需要范围的2倍。比如模糊滤镜需要周围的10个像素点，那么重叠部分须大于20px；2、切片没有与其他片重叠的边，须在原图的边上。这确保了切片中没有空白部分，使每个切片的处理程序更简单。 处理后，切分再拼接到一起，每个切片提供重叠部分的一半数据，这就是为什么重叠部分得是滤镜程序需要的2倍：在切片重叠的中心，两个切片的数据要一样，从而避免出现分割线。 总结图片滤镜很简单，但对各种不同的尺寸都保持良好的性能，就比较困难，Shutterstock Editor通过使用WebGL，并尽可能复用GPU的texture，把大图分成重叠的小片，从而在任何硬件和浏览器上都可以表现得不错。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"javascript异步error","slug":"javascript异步error","date":"2022-05-19T16:48:29.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/javascript异步error/","permalink":"http://example.com/js/javascript%E5%BC%82%E6%AD%A5error/","excerpt":"","text":"本文主要总结javascript异步error的抛出和捕获。 首先我们有一个耗时的操作wait： 123const wait = (ms) =&gt; &#123; return new Promise((resolve) =&gt; setTimeout(resolve, ms))&#125; 有一个函数foo调用了上面的wait： 123456789101112131415const foo = async () =&gt; &#123; console.log(1) await wait(2000) console.log(2)&#125;console.log(3)await foo()console.log(4)// 3// 1// 等待约2秒// 2// 4 async函数foo发生异常的话，可以通过throw一个Error来抛出： 1234const foo = async () =&gt; &#123; await wait(2000) throw new Error(&#x27;Woops!&#x27;)&#125; 或者返回一个Promise.reject，不过throw error的方式更常用。 1234const foo = async () =&gt; &#123; await wait(2000) return Promise.reject(new Error(&#x27;Whoops!&#x27;))&#125; foo发生异常后，可以通过catch来捕获，这样就不会报Uncaught错误。 12345const bar = async () =&gt; &#123; await foo().catch((e) =&gt; &#123; console.log(e) // caught &#125;)&#125; 因为foo是一个async函数，返回的是一个Promise，所以可以像Promise捕获异常一样，直接在函数foo后面跟catch。 或者用try-catch来捕获： 1234567const bar = async () =&gt; &#123; try &#123; await foo() // caught &#125; catch(e) &#123; console.log(e) &#125;&#125; 对于异步函数，比如上面的foo，尽量在执行的时候用await，可以避免很多问题。比如用try-catch捕获异常时，如果没有await，就捕获不到： 1234567const bar = async () =&gt; &#123; try &#123; foo() // uncaught &#125; catch(e) &#123; console.log(e) &#125;&#125; 上面这些操作基本就能捕获到异常，然后做一些异常处理逻辑，比如提示操作失败，隐藏处理中的提示等等。编码时注意对异步逻辑的处理，最后就都能通过上面的方式捕获异常，更复杂的问题，可以试试Promise.all。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"win10编译opencvjs","slug":"win10编译opencvjs","date":"2022-02-22T11:35:22.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/win10编译opencvjs/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/win10%E7%BC%96%E8%AF%91opencvjs/","excerpt":"","text":"前言本文主要讲win10系统怎么编译出opencv.js。主要编译过程跟官网一样，先安装Emscripten，再获取opencv源码，再编译opencv源码。本文主要解决的问题是在win10上怎么完成编译。 WSL先说一下背景，公司的电脑是win10，构建opencv.js需要用到Emscripten，而Emscripten官网不推荐直接在windows系统上运行，对windows用户推荐了windows的Linux子系统。 一开始我不了解什么是window的Linux子系统，即WSL，于是我直接在windows中运行了（我不想装虚拟机，也不想重装系统，也不想把mac带到公司来），结果捣腾了2天也没把编译时的各种报错解决完，报错一个接一个，解决完一个又出现一个…… 最后我决定去看一下WSL，发现非常好用，编译opencv.js一举成功！ 安装WSL1、勾选适用于Linux的windows子系统路径是「控制面板」-「程序」-「启用或关闭Windows功能」 2、打开 Microsoft Store，搜索「WSL」，选1个安装，比如我装的第一个Ubantu 20.04。 3、安装完成后自动打开终端，没有自动打开就手动打开，跟linux系统一样，设置好用户名和密码，就进入linux系统了。 编译opencvjs1、确保安装了git、cmake、python，没有安装的话运行下列命令安装： 123sudo apt install gitsudo apt install cmakesudo apt install python 安装后可以通过下列命令查看安装的版本： 2、安装Emscripten 1234567891011121314151617# 创建customopencv目录mkdir customopencv# 进入customopencv目录cd customopencv/# 拉取emscripten源码git clone https://github.com/emscripten-core/emsdk.git# 进入emsdk目录cd emsdk/# 安装emsdk./emsdk install latest# 激活emsdk./emsdk activate latest# 设置环境变量source ./emsdk_env.sh 3、获取opencv 回到上级目录，clone opencv源码： 12# 拉取opencv源码git clone https://github.com/opencv/opencv.git 4、编译opencvjs 运行下面的命令来编译： 1python platforms/js/build_js.py build_out --emscripten_dir /home/lovelyun/customopencv/emsdk/upstream/emscripten --build_wasm --clean_build_dir 接下来去喝杯水，然后就可以看到编译成功了： 1234========== Build finished=====OpenCV.js location: /home/lovelyun/customopencv/opencv/build_out/bin/opencv.js 进入到上面的bin文件夹，运行ls -l可以看到文件详情： 或者用du -sh *查看它们占用的空间： 这里的opencv.js就是我们最后需要的文件，现在在Linux子系统中，怎么传到windows系统中呢？ 最简单的是在文件资源管理器的地址栏输入\\\\wsl$，回车就可以看到所有的子系统。 点进去就可以看到上面的文件，比如我的路径是\\\\wsl$\\Ubuntu-20.04\\home\\lovelyun\\customopencv\\opencv\\build_out\\bin。 自定义opencv构建模块接下来我们去掉DNN模块，首先用vscode打开子系统中的opencv文件夹，打开/platforms/js/build_js.py文件，把get_cmake_cmd(self)函数中的-DBUILD_opencv_dnn=ON改为-DBUILD_opencv_dnn=OFF。 重新构建后可以看到，opencv.js从一开始的8.6M减小到了5.5M。 我们还可以修改opencv_js.config.py，去掉没用到的函数，比如只保留core和imgproc。 此时编译出来的opencv.js就只有3.7M。 或许你觉得3.7M也很大，当然大啦，但是core和imgproc中没用到的函数还可以接着删除呀。 demo直接把bin目录中的opencv.js复制到项目中，比如下面这样引用： 1&lt;script src=&quot;js/opencv.js&quot; onload=&quot;onOpenCvReady();&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 然后发现调用cv的api会报错，比如cv.imread is not a function。打印发现cv是一个promise，这里我们简单的处理一下，把cv重新赋值为promise返回的结果，就可以运行起来了。 123async function onOpenCvReady() &#123; window.cv = await window.cv&#125; 按照官网的说法，应该是可以直接使用编译出来的opencv.js的，即直接替换官网编译的opencv.js。这里实测直接替换有问题，那就解决它，我们暂时不纠结为什么会有问题了， 总结需要Linux环境的问题，就用Linux，不要用windows环境瞎折腾。 这次编译的大部分时间都在解决windows上的报错问题，虽然windows上安装都是成功的，校验是否安装成功的结果都是ok的，但编译时各种报错，最后用了WSL，一开始为了省时间直接把windows上下载的emsdk文件夹cp过去用，而且WSL中的python环境默认是python3，这些因素也导致了编译报错，最后我想完全重新来一次，在WSL中重新下载emscripten，重新安装python，最后用的python2，编译一次性成功。 用Linux编译，感觉就是超幸运，干什么都是一次成功。 虽然觉得这种环境问题导致的报错解决起来浪费时间还没什么意义，但是编译成功的那一刻还是挺兴奋的，哈哈哈……","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"前端包管理器","slug":"前端包管理器","date":"2022-01-26T11:31:08.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/前端包管理器/","permalink":"http://example.com/js/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","excerpt":"","text":"前言本文将从前端包管理器的发展开始说起，然后对比npm、yarn和pnpm。 没有包管理器依赖（dependency）是别人为了解决一些问题而写好的代码，即我们常说的第三方包或三方库。一个项目或多或少的会有一些依赖，而你安装的依赖又可能有它自己的依赖。 比如，你需要写一个base64编解码的功能，你可以自己写，但为什么要自己造轮子呢？大多数情况下，一个可靠的第三方依赖经过多方测试，兼容性和健壮性会比你自己写的更好。 项目中的依赖，可以是一个完整的库或者框架，比如react或vue；可以是一个很小的功能，比如日期格式化；也可以是一个命令行工具，比如eslint。 如果没有现代化的构建工具，即包管理器，你需要用&lt;script&gt;标签来引入依赖。 此外，如果你发现了一个比当前使用的依赖更好的库，或者你使用的依赖发布了更新，而你想用最新版本，在一个大的项目中，这些版本管理、依赖升级将是让人头疼的问题。 于是包管理器诞生了，用来管理项目的依赖。它提供方法给你安装依赖（即安装一个包），管理包的存储位置，而且你可以发布自己写的包。 npm v1-v2初代npm（Node.js Package Manager）随着Node.js的发布出现了。 它的文件结构是嵌套的： 这会导致3个问题： 1、node_modules体积过大(大量重复的包被安装)2、node_modules嵌套层级过深(会导致文件路径过长的问题)3、模块实例不能共享 yarn &amp; npm v3这个版本yarn和npm v3带来了扁平化依赖管理： 扁平化处理时，比如安装A，A依赖B和C，C依赖D和E，就把A~E全部放到node_modules目录下，从而解决上个版本中node_modules嵌套层级过深的问题。在install安装时，会不停的往上级node_modules中寻找，如果找到同样的包，就不再重复安装，从而解决了大量包被重复安装的问题。 但是扁平化带来了新的问题：1、依赖结构的不确定性2、扁平化算法本身复杂性很高，耗时较长3、项目中仍然可以非法访问没有声明过依赖的包 对于问题1，比如B和C都依赖了F，但是依赖的F版本不一样： 依赖结构的不确定性表现是扁平化的结果不确定，以下2种情况都有可能，取决于package.json中B和C的位置。 于是出现yarn.lock（npm5才有package-lock.json），来保证install后产生确定的依赖结构。但这并不能完全解决问题，node_modules中依然存在各种不同版本的F，而这可能导致各种情况的编译报错，以及安装满，占磁盘空间。 对于问题3，package.json中我们只声明了A，BF都是因为扁平化处理才放到和A同级的node_modules下，理论上在项目中写代码时只可以使用A，但实际上BF也可以使用，由于扁平化将没有直接依赖的包提升到node_modules一级目录，Node.js没有校验是否有直接依赖，所以项目中可以非法访问没有声明过依赖的包。 这会产生两个问题： B~F中的包升级后，项目可能出问题额外的管理成本（比如协作时别人运行一次npm install后项目依旧跑不起来） pnmppnpm(Performance npm)的作者Zoltan Kochan发现 yarn 并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器。 pnpm复刻了npm所有的命令，所以使用方法和npm一样，并且在安装目录结构上做了优化，特点是善用链接，且由于链接的优势，大多数情况下pnpm的安装速度比yarn和npm更快。 比如安装A，A依赖了B： 1、安装依赖A和B一起放到.pnpm中（和上面相比，这里没有耗时的扁平化算法）。 另外&#65;&#64;&#49;&#46;&#x30;&#x2e;&#48;下面是node_modules，然后才是A，这样做有两点好处： 允许包引用自身把包和它的依赖摊平，避免循环结构2、处理间接依赖A平级目录创建B，B指向&#66;&#64;&#x31;&#x2e;&#48;&#46;&#x30;下面的B。 3、处理直接依赖顶层node_modules目录下创建A，指向&#65;&#x40;&#x31;&#46;&#x30;&#46;&#48;下的A。 对于更深的依赖，比如A和B都依赖了C： 总结如果你想更快的速度，更小的空间，你应该选择pnpm；如果你要用Monorepo，你可以用yarn或pnpm；如果是node项目，你应该用npm，因为这是node官方推荐的，而且yarn不支持node5+；对于npm项目，如果你担心项目的安全性，你可以考虑用yarn替换npm。 参考 为什么现在我更推荐 pnpm 而不是 npm&#x2F;yarn? Node.js 包管理器发展史 JavaScript package managers compared: Yarn, npm, or pnpm? pnpm官网","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"跟着尤雨溪学Vite","slug":"跟着尤雨溪学Vite","date":"2022-01-21T11:26:12.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/跟着尤雨溪学Vite/","permalink":"http://example.com/js/%E8%B7%9F%E7%9D%80%E5%B0%A4%E9%9B%A8%E6%BA%AA%E5%AD%A6Vite/","excerpt":"","text":"前言本文是翻译的尤雨溪在油管上发布的Learn Vite with Evan You视频。下面开始正文部分。 正文尤雨溪在这里欢迎大家，今天的视频我们会讲讲Vite。 Vite是一个我从去年开始开发的新构建工具，并且我们认为它会成为下一代的前端工具，所以，这个视频我们会谈谈，什么是Vite，为什么是Vite，而且我们还会展示怎么开始用它，以及Vite没有提供的一些很棒的特性。接下来就开始吧。 首先，什么是Vite? 如果你去官网，会看到Vite是个法语单词，意思是“快”，有些人把它读成/vait/，但它实际上是表示“快”的法语单词，所以我们读/vit/。 Vite是一个构建工具，用在开发环境，也可以为生产环境打包。如果你用过Vue CLI，你可以认为它们差不多。 Vite要解决的问题是更新速度，如果你在一个很大的项目中用过Vue CLI，你可能要等半分钟，甚至一分钟，本地环境才会更新，随着项目变大，更新就变慢，只修改了一个文件，你就不得不等好几秒，等着屏幕上的东西更新。 变慢主要是因为我们要打包，我们为什么需要打包呢？因为过去浏览器不支持ES Modules，无法加载模块化的代码，所以早期我们发明了模块化规范，比如AMD和CommonJS，我们写完代码后，用一些工具，比如webpack、Parcel、Browserfy，把代码打包成一个浏览器上可以运行的文件。 幸运的是，如今大部分的现代浏览器都能支持ES Modules，这意味着开发阶段的大量工作我们不用做了，浏览器会帮我们处理，所以用Vite的前提是我们把代码写成ES Modules，编译文件时找到import申明，并对每个模块发一个HTTP请求到开发服务器，由于大部分工作浏览器做了，所以我们需要做点额外的工作。 另一方面，如果你有很多依赖，Vite会很智能的先用esbuild打包来减少请求。 Esbuild是Evan Wallace用Go写的一个工具，把代码编译成浏览器可执行的程序，所以要快几个数量级，然后Javascript有了同样的工具。 因为上面这些原因，Vite可以提供一个极快的开发体验。所以，这是为什么是Vite。 对于快字，我认为Vite有多快你用一下就知道了，那么，我们现在就用用看。 首先确保你装了Node.js和npm，然后就可以简单的运行命令： 1npm init @vitejs/app 回车后会问你项目名，这里我就叫它hello-vite吧，然后会让你选一个框架，Vite对框架没有限制，所以即使你用react或者preact，你也可以用Vite，不过，作为第一个demo，我根本不想用框架，所以我们就选vanilla模板，Vite也可以支持Typescript，不过现在我们只选择vanilla，接下来我们进入hello-vite目录，开始前要先用npm安装依赖。 这时我们先看看我们的项目，有一个index.html，里面有一个script标签，type属性是module，src指向main.js，这个语法需要浏览器支持ESM。 接下来我们看看package.json，你可以看到，Vite是唯一的依赖，此外，还有一些npm scripts，有dev,build和serve的scripts，所以，让我们直接npm install吧。 我要开始运行npm install了，你可以看到安装过程非常的快，一共安装了13个包，就是这么简洁。而且我认为Vite没有本地缓存，从注册中心安装，花了不到1秒。 接下来我运行npm run dev启动服务，同样很快，本地服务就跑起来了，接着打开页面，就看到了Hello Vite，这就是一个普通的本地开发服务器。 我们再看回代码，index.html和main.js都没什么变化，如果我们把main.js改成main.ts，重启服务，一样能跑起来，在Vite项目中，你可以直接引进ts文件，Vite会自动转译，仅此而已，这意味着Vite不会做类型检查。 我们这样做的第一个原因是，我们用esbuild来编译ts文件，esbuild是用Go写的，比起用javascript写的ts自身的编译要快30倍，所以当我们用esbuild来编译，由于没有类型检查，如果你import一个type，确保是从另一个文件中import的，这是一个坑。 1import type &#123; &#125; from &#x27;./&#x27; 但这对于非常大的typescript项目中开发体验得到极大改善来说，只是一个很小很小的代价。 另一个原因是如果对你的编辑器，比如VS Code，做了TS相关的合适设置，可能你的IDE就会对ts文件做类型检查，ts已经在你的IDE中运行了。所以Vite就说：“好吧，就把这部分给IDE和打包程序吧”，在开发阶段Vite对ts的类型检查是不确定的，因为这部分交给其他工具了。关于typescript的就这么多。 接下来我们花1分钟讲下CSS。可以看到我们能直接import CSS，接着我准备把这里的color改成red，你可以看到页面立刻就更新了，注意看浏览器地址栏，我们再把color改成green，地址栏没有重新加载，接着我打开控制台的Elements栏，这时我们再次改变color，你可以看到，页面没有重载，这里热更新了，加载的CSS局部更新。 过去我们通过npm来import、install、使用依赖，比如我想用lodash，从lodash-es中import debounce，浏览器并不能处理，因为它不知道什么是npm，不知道怎么处理依赖，但是Vite知道怎么处理。 接下来我要install lodsah-es，然后npm run dev重启服务，你可以看到IDE已经判断出我们安装了lodash-es，所以它现在有类型定义，我加个console.log(debounce)，打开浏览器控制台，可以看到我们能够从lodsah-es中拿到debounce函数，这点很棒，Vite能够为你处理npm依赖。 还有一点很棒，如果我们去network中查看下debounce，可以发现Vite把lodash-es的众多模块组合成了一个文件，所以它比一般情况下加载地更快，如果你通过ES Modules加载loadsh-es，那就是另外一个表现了，嗯，npm依赖地加载就这么多。 总结以上就是视频的主要内容了，视频是2021年9月15日发布，从Vite名字的由来，讲到为什么需要Vite，能解决什么问题，需要付出什么代价，然后带大家初步体验Vite的使用，体验启动及热更新速度，处理typescript和npm依赖。 想了解更多，建议看看官网。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"js模块化","slug":"js模块化","date":"2022-01-20T11:00:23.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/js模块化/","permalink":"http://example.com/js/js%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"前言本文主要理理js模块化相关知识。涉及到内联脚本、外联脚本、动态脚本、阻塞、defer、async、CommonJS、AMD、CMD、UMD、ES Module。顺带探究下Vite。 内联脚本假设你是一个前端新手，现在入门，那么我们创建一个html页面，需要新建一个index.html文件： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;content&quot;&gt;hello world&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 如果需要在页面中执行javascript代码，我们就需要在 HTML 页面中插入 &lt;script&gt; 标签。 有2种插入方式：1、放在&lt;head&gt;中2、放在&lt;body&gt;中 比如，点击hello world之后，在hello world后面加3个感叹号的功能，我们在head中加入script标签，并给hello world绑定点击事件： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;script&gt; function myFunction() &#123; document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;hello world!!!&#x27; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;content&quot; onclick=&quot;myFunction()&quot;&gt;hello world&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 如果加在body中，一般放在body的最后面： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;content&quot; onclick=&quot;myFunction()&quot;&gt;hello world&lt;/p&gt; &lt;script&gt; function myFunction() &#123; document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;hello world!!!&#x27; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简单的逻辑我们可以用这2种方式写，这种方式叫做内联脚本。 外联脚本当逻辑复杂时，我们可以把上面的script标签中的代码抽取出来，比如在html的同级目录创建一个js文件夹，里面新建一个a.js的文件。 a.js中写上面script标签中的代码： 123function myFunction() &#123; document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;hello world!!!&#x27;&#125; 上面的script标签则可以改成： 1&lt;script src=&quot;./js/a.js&quot;&gt;&lt;/script&gt; 阻塞上面的2种写法，浏览器在加载html时，遇到script标签，会停止解析html。内联脚本会立刻执行；外联脚本会先下载再立刻执行。等脚本执行完毕才会继续解析html。（html解析到哪里，页面就能显示到哪里，用户也能看到哪里） 比如下面的代码： 12345&lt;p&gt;...content before script...&lt;/p&gt;&lt;script src=&quot;./js/a.js&quot;&gt;&lt;/script&gt;&lt;p&gt;...content after script...&lt;/p&gt; 解析到第一个p标签，我们能看到...content before script...显示在了页面中，然后浏览器遇到script标签，会停止解析html，而去下载a.js并执行，执行完a.js才会继续解析html，然后页面中才会出现...content after script...。 我们可以通过Chrome的Developer Tools分析一下index.html加载的时间线： 这会导致2个问题：1、脚本无法访问它下面的dom；2、如果页面顶部有个笨重的脚本，在它执行完之前，用户都看不到完整的页面。 对于问题2，我们可以把脚本放在页面底部，这样它可以访问到上面的dom，且不会阻塞页面的显示： 12345&lt;body&gt; ...all content is above the script... &lt;script src=&quot;./js/a.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 但这不是最好的办法，我们接着往下看。 defer我们给script标签加defer属性，就像下面这样： 12345&lt;p&gt;...content before script...&lt;/p&gt;&lt;script defer src=&quot;./js/a.js&quot;&gt;&lt;/script&gt;&lt;p&gt;...content after script...&lt;/p&gt; defer 特性告诉浏览器不要等待脚本。于是，浏览器将继续解析html，脚本会并行下载，然后等 DOM 构建完成后，脚本才会执行。 这样script标签不再阻塞html的解析。 这时再看时间线： 需要注意的是，具有 defer 特性的脚本保持其相对顺序。 比如： 12&lt;script defer src=&quot;./js/a.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;./js/b.js&quot;&gt;&lt;/script&gt; 上面的2个脚本会并行下载，但是不论哪个先下载完成，都是先执行a.js，a.js执行完才会执行b.js。这时，如果b.js依赖a.js，这种写法将很有用。 另外需要注意的是，defer 特性仅适用于外联脚本，即如果 script标签没有 src属性，则会忽略 defer 特性。 async我们可以给script标签加async属性，就像下面这样： 1&lt;script async src=&quot;./js/a.js&quot;&gt;&lt;/script&gt; 这会告诉浏览器，该脚本完全独立。独立的意思是，DOM 和其他脚本不会等待它，它也不会等待其它东西。async 脚本就是一个会在加载完成时立即执行的完全独立的脚本。 这时再看时间线： 可以看到，虽然下载a.js不阻塞html的解析，但是执行a.js会阻塞。 还需要注意多个async时的执行顺序，比如下面这段代码： 123456&lt;p&gt;...content before script...&lt;/p&gt;&lt;script async src=&quot;./js/a.js&quot;&gt;&lt;/script&gt;&lt;script async src=&quot;./js/b.js&quot;&gt;&lt;/script&gt;&lt;p&gt;...content after script...&lt;/p&gt; 两个p标签的内容会立刻显示出来，a.js和b.js则并行下载，且下载成功后立刻执行，所以多个async时的执行顺序是谁先下载成功谁先执行。一些比较独立的脚本，比如性能监控，就很适合用这种方式加载。 另外，和defer一样，async 特性也仅适用于外联脚本。 动态脚本我们可以动态的创建一个script标签并append到文档中。 123let script = document.createElement(&#x27;script&#x27;)script.src = &#x27;/js/a.js&#x27;document.body.append(script) append后脚本就会立刻开始加载，表现默认和加了async属性一致。我们可以显示的设置script.async &#x3D; false来改变这个默认行为，那么这时表现就和加了defer属性一致。 上面的这些写法，当script标签变多时，容易导致全局作用域污染，还要维护书写顺序，要解决这个问题，需要一种将 JavaScript 程序拆分为可按需导入的单独模块的机制，即js模块化，我们接着往下看。 CommonJS很长一段时间 JavaScript 没有模块化的概念，直到 Node.js 的诞生，把 JavaScript 带到服务端，这时，CommonJS诞生了。 CommonJS定义了三个全局变量： 1require，exports，module require 读入并执行一个 js 文件，然后返回其 exports 对象；exports 对外暴露模块的接口，可以是任何类型,指向 module.exports；module 是当前模块，exports 是 module 上的一个属性。 Node.js 使用了CommonJS规范。 比如： 1234567// a.jslet name = &#x27;Lily&#x27;export.name = name// b.jslet a = require(&#x27;a.js&#x27;)console.log(a.name) // Lily 由于CommonJS不适合浏览器端，于是出现了AMD和CMD规范。 AMDAMD（Asynchronous Module Definition） 是 RequireJS 在推广过程中对模块定义的规范化产出。 基本思想是，通过 define 方法，将代码定义为模块。当这个模块被 require 时，开始加载依赖的模块，当所有依赖的模块加载完成后，开始执行回调函数，返回该模块导出的值。 使用时，需要先引入require.js： 12&lt;script src=&quot;require.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt; 然后可以这样写： 123456789101112131415// a.jsdefine(function() &#123; let name = &#x27;Lily&#x27; return &#123; name &#125;&#125;)// b.jsdefine([&#x27;a.js&#x27;], function(a) &#123; let name = &#x27;Bob&#x27; console.log(a.name) // Lily return &#123; name &#125;&#125;) CMDCMD（Common Module Definition） 是 Sea.js 在推广过程中对模块定义的规范化产出。 使用时，需要先引入sea.js： 12&lt;script src=&quot;sea.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt; 然后可以这样写： 12345678910111213// a.jsdefine(function(require, exports, module) &#123; var name = &#x27;Lily&#x27; exports.name = name&#125;)// b.jsdefine(function(require, exports, module) &#123; var name = &#x27;Bob&#x27; var a = require(&#x27;a.js&#x27;) console.log(a.name) // &#x27;Lily&#x27; exports.name = name&#125;) UMDUMD (Universal Module Definition) 目的是提供一个前后端跨平台的解决方案(兼容全局变量、AMD、CMD和CommonJS)。 实现很简单，判断不同的环境，然后以不同的方式导出模块： 1234567891011121314151617(function (root, factory) &#123; if (typeof define === &#x27;function&#x27; &amp;&amp; (define.amd || define.cmd)) &#123; // AMD、CMD define([], factory); &#125; else if (typeof module !== &#x27;undefined&#x27; &amp;&amp; typeof exports === &#x27;object&#x27;) &#123; // Node、CommonJS module.exports = factory(); &#125; else &#123; // 浏览器全局变量 root.moduleName = factory(); &#125;&#125;(this, function () &#123; // 只需要返回一个值作为模块的export // 这里我们返回了一个空对象 // 你也可以返回一个函数 return &#123;&#125;;&#125;)); ES ModuleAMD 和 CMD 是社区的开发者们制定的模块加载方案，并不是语言层面的标准。从 ES6 开始，在语言标准的层面上，实现了模块化功能，而且实现得相当简单，完全可以取代上文的规范，成为浏览器和服务器通用的模块解决方案。 ES6 的模块自动采用严格模式。模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口；import命令用于输入其他模块提供的功能。 比如上面的代码，我们可以这样写： 1234567891011121314151617// a.jsconst name = &#x27;Lily&#x27;export &#123; name&#125;// 等价于export const name = &#x27;Lily&#x27;// b.jsimport &#123; name &#125; from &#x27;a.js&#x27;console.log(name) // Lily// b.jsimport * as a from &#x27;a.js&#x27;console.log(a.name) // Lily 此外，还可以用export default默认导出的写法： 12345678910// a.jsconst name = &#x27;Lily&#x27;export default &#123; name&#125;// b.jsimport a from &#x27;a.js&#x27;console.log(a.name) // Lily 如果只想运行a.js，可以只import: 12// b.jsimport &#x27;a.js&#x27; 我们可以给script标签加type&#x3D;module让浏览器以 ES Module 的方式加载脚本： 1&lt;script type=&quot;module&quot; src=&quot;./js/b.js&quot;&gt;&lt;/script&gt; 这时，script标签会默认有defer属性（也可以设置成async），支持内联和外联脚本。 这时我们运行打开index.html，会发现浏览器报错了： 这是因为 type&#x3D;module 的 script 标签加强了安全策略，浏览器加载不同域的脚本资源时，如果服务器未返回有效的 Allow-Origin 相关 CORS 头，会禁止加载改脚本。而这里启动的index.html是一个本地文件（地址是file:&#x2F;&#x2F;路径），将会遇到 CORS 错误，需要通过一个服务器来启动 HTML 文件。 Vite在浏览器支持 ES Module 之前，我们用工具实现JavaScript模块化的开发，比如webpack、Rollup 和 Parcel 。但是当项目越来越大后，本地热更新越来越慢，而 Vite 旨在利用ESM解决上述问题。 Vite使用简单，可以去官网看看。 总结老的规范了解即可，未来是ES Module的，用Vite可以极大的提升开发时的体验，生产环境用Rollup打包。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"梯度下降法","slug":"梯度下降法","date":"2022-01-05T10:49:10.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"ai/梯度下降法/","permalink":"http://example.com/ai/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/","excerpt":"","text":"本文主要解释什么是梯度，什么是梯度下降法，可以应用在哪里，如何用python实现。 梯度梯度是微分中一个很重要的概念： 在单变量的函数中，梯度其实就是函数的微分 在多变量函数中，梯度是一个向量先说说单变量函数。 梯度是函数的微分，那微分又是什么呢？ 下面我们看一下维基百科对微分的描述。 函数的微分是对函数局部变化的一种线性描述。微分可以近似地描述当函数自变量的取值作足够小的改变时，函数的值是怎样改变的。 在几何上，设 ∆x 是曲线 y&#x3D;f(x) 上的点 P 在横坐标上的增量，∆y 是曲线在点 P 对应 ∆x 在纵坐标上的增量，dy 是曲线在点 P 的切线对应 ∆x 在纵坐标上的增量。当 |∆x| 很小时，|∆y−dy| 比 |∆x| 要小得多(高阶无穷小)，因此在点P附近，我们可以用切线段来近似代替曲线段。 下面看一个例子。 设函数f(x) &#x3D; x²，回顾一下微分的定义，函数自变量取足够小的改变时，函数值是怎么改变的，假设函数自变量 x 变到 x + dx ，那么函数值的改变是 f(x + dx) - f(x)，进一步计算可以看到： 12345f(x + dx) - f(x)= (x + dx)² - x²= x² + 2x * dx + (dx)² - x²= 2x * dx + (dx)²= Adx + o(dx) 其中的线性主部：Adx &#x3D; 2xdx ，高阶无穷小是 o(dx) &#x3D; (dx)²。因此，该函数在 x 处的微分是 dy &#x3D; 2xdx，函数的微分与自变量的微分之商 dy &#x2F; dx &#x3D; 2x &#x3D; f’(x)，等于函数的导数。 那么现在我们再看看一元微分的定义： 设函数 y &#x3D; f(x) 在某区间内有定义，对于区间内的一点 x0 ，变动到附近的 x0 + ∆x （也在此区间内）时，如果函数的增量 ∆y &#x3D; f(x0 + ∆x) - f(x) 可表示为 ∆y &#x3D; A∆x + o(∆x) ，其中A是不依赖于 ∆x 的常数， o(∆x)是比 ∆x高阶的无穷小，那么称函数 f(x)在 x0 处是可微的，且 A∆x 称作函数在点 x0 相应于自变量增量 ∆x 的微分，记作 dy， 即 dy &#x3D; A∆X, dy 是 ∆y 的线性主部，通常把自变量 x 的增量 ∆x 称为自变量的微分，记作 dx， 即 dx &#x3D; ∆x。 当一个函数有多个变量的时候，就有了多变量的微分，即分别对每个变量求微分。 这里，我们先了解一下什么是偏导。 偏导： 一个多变量的函数(或称多元函数)，对其中一个变量(导数)微分，而保持其他变量恒定。函数 f 关于变量 x 的偏导数写为 fx’ 或 ∂f &#x2F; ∂x。偏导数符号 ∂ 是全导数符号 d 的变体。 比如函数 z &#x3D; f(x, y) &#x3D; x²y² ，对变量 x 微分，即 ∂f &#x2F; ∂x &#x3D; ∂(x²y²) &#x2F; ∂x &#x3D; 2xy²。 复合函数则需要用到链式法则，比如f(x) &#x3D; (x² + 1)³ 的导数 f’(x) &#x3D; 3(x² + 1)² * 2x &#x3D; 6x(x² + 1)²。 梯度实际上就是多变量微分的一般化。 比如 f(x, y, z) &#x3D; 0.55 - (5x + 2y -12z)， 那么该函数的梯度为 ▽f &#x3D; &lt;∂f &#x2F; ∂x, ∂f &#x2F; ∂y, ∂f &#x2F; ∂z&gt; &#x3D; &lt;-5, -2, 12&gt;。 我们可以看到，梯度其实是一个向量，这个向量指出了函数在给定点变化最快的方向。 现在我们再看看什么是梯度下降法。 理解梯度下降法，有一个很经典的例子： 一个人被困在山上，需要下山。但山上有浓雾，可视度很低，下山的路无法确定。他必须利用自己周围的信息去找下山的路。这时，他就可以利用梯度下降算法。具体来说，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走；同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。 同时可以假设最陡峭的地方无法一眼看出来，而是需要一个复杂的工具来测量。所以，此人每走一段距离，都需要一段时间来测量所在位置最陡峭的方向，这是比较耗时的。那么为了在太阳下山之前到达山底，就要尽可能的减少测量次数。问题是，如果测量频繁，可以保证下山的方向是绝对正确的，但又非常耗时，如果测量过少，又有偏离方向的风险。所以需要一个合适的测量频率，来确保下山的方向不错误，同时又不至于耗时太多。 总结一下就是： 下山 目标函数 起点 随机参数 方向 梯度下降 步长 学习率 梯度下降法的实现下面我们就用python来实现使用梯度下降法模拟求解 y&#x3D;(2x + 4)² + 1 最小值，x范围[-10, 6]，起点随机选取。 首先引入 numpy 和 matplotlib.pyplot， numpy是一个数学函数库， matplotlib.pyplot用来画图。 12import numpy as npimport matplotlib.pyplot as plt 然后定义目标函数： 12# 目标函数: y = (2 * x + 4)^2 + 1def func(x): return np.square(2 * x + 4) + 1 接着定义目标函数的导数： 12# 目标函数的一阶导数: dy / dx = 8 * x + 16def dfunc(x): return 8 * x + 16 下面实现梯度下降法。 123456789101112131415161718192021# 梯度下降法：给定起始点目标函数的一阶导函数，求在 iterations 次迭代中x的最新值# param x_start: x 的起始点# param df: 目标函数的一阶导函数# param iterations: 迭代次数# param lr: 学习率# return: x在每次迭代后的位置（包括起始点），长度为 iterations + 1def gradient_descent(x_start, df, lr = 0.01, iterations = 1000): xs = np.zeros(iterations + 1) x = x_start xs[0] = x print(f&#x27;起点：x=&#123;x&#125;, y=&#123;func(x)&#125;&#x27;) for i in range(iterations): # diff表示x要改变的幅度 diff = - df(x) * lr if np.all(np.abs(diff) &lt;= stopping_threshold): print(&#x27;停止&#x27;) break x += diff xs[i + 1] = x print (f&#x27;迭代次数: &#123;i + 1&#125;,结果：x=&#123;x&#125;, y = &#123;func(x)&#125;&#x27;) return xs 接下来就是调用梯度下降函数。 1234567891011# 起始点x_start = np.random.uniform(-10, 6)# 迭代次数iterations = 1000# 学习率lr = 0.1# 停止迭代阈值stopping_threshold = 1e-5# 梯度下降法y = gradient_descent(x_start, dfunc, lr, iterations) 最后画图。 12345678color = &#x27;r&#x27;x = np.arange(-10.0, 6.0, 0.01)plt.plot(x, func(x), c = &#x27;g&#x27;)plt.plot(y, func(y), c = color, label=&#x27;lr=&#123;&#125;&#x27;.format(lr))plt.scatter(y, func(y), c = color)plt.legend()plt.show() 我们运行3次就可以看到结果： 把学习率改为0.01时，迭代次数明显增加： 我们再运行3次，可以看到： 第1次，起点 x &#x3D; 8.80086， y &#x3D; 186.00666，迭代131次，结果x &#x3D; -2.00012, y &#x3D; 1.00000第2次，起点 x &#x3D; 7.31667， y &#x3D; 114.0679，迭代128次，结果x &#x3D; -2.00012, y &#x3D; 1.00000第3次，起点 x &#x3D; 0.84411， y &#x3D; 6.34431，迭代110次，结果x &#x3D; -1.99988, y &#x3D; 1.00000 把学习率改为0.001时，迭代次数高达1071次： 我们再运行3次，可以看到： 第1次，起点 x &#x3D; -8.81178， y &#x3D;186.60116，迭代1000次，结果x &#x3D; -2.00221, y &#x3D; 1.00002第2次，起点 x &#x3D; 2.98931， y &#x3D; 100.57297，迭代1000次，结果x &#x3D; -1.99838, y &#x3D; 1.00001第3次，起点 x &#x3D; 1.50069， y &#x3D; 1.99721，迭代746次，结果x &#x3D; -199875, y &#x3D; 1.00001 下面我们把学习率调大，比如0.2，可以看到迭代结果在最低点左右徘徊，27次后找到最低点。 再把学习率调到0.3时，迭代1000次后还没找到最低点： 参考 微分-wiki 深入浅出–梯度下降法及其实现 Gradient Descent - Problem of Hiking Down a Mountain","categories":[{"name":"ai","slug":"ai","permalink":"http://example.com/categories/ai/"}],"tags":[]},{"title":"conda建立及管理虚拟环境","slug":"conda建立及管理虚拟环境","date":"2021-12-14T20:40:53.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"ai/conda建立及管理虚拟环境/","permalink":"http://example.com/ai/conda%E5%BB%BA%E7%AB%8B%E5%8F%8A%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前文我们安装了Anaconda，本文主要介绍如何利用conda建立及管理Python虚拟环境。 前言开发python时，经常会需要不同的python版本以及不同的packages，如果你只需要使用特定的包，或者想要尝试不同的开发环境，但又不想彼此的开发环境受到影响，那么 Anaconda 的管理系统conda将是一个不错的方案。 conda命令是管理不同package时使用的，可以建立(create)、输出(export)、罗列(list)、删除(remove)和更新(update)环境中的包，还可以分享你的虚拟环境。 下面将通过5个步骤来说明conda如何建立及管理虚拟环境。 安装及更新安装部分可参考前文《AI入门之环境安装》或官网，从开始菜单中打开Anaconda Prompt后，可以通过下列命令查看当前版本： 12conda -Vconda --version 通过下列命令更新： 1conda update conda 建立虚拟环境查看当前已安装的虚拟环境： 1conda env list 假设我们要建立一个叫myenv的虚拟环境，并且安装python 3.5的版本，我们可以执行下面的命令： 1conda create --name myenv python=3.5 安装完成后会出现下面的提示，提醒启动和关闭该环境的命令： 这时，我们conda env list可以看到多了一个刚刚建立的虚拟环境myenv。 启动虚拟环境1activate myenv 当前环境已经切换到myenv。我们可以看到命令行最前面的括号内显示myenv，而且conda env list可以看到myenv后面有星号。 如果是Linux或者macOS，启动虚拟环境的命令将是： 1source activate myenv 还可以通过下列命令看当前的虚拟环境安装了哪些东西： 1conda list 如果要在当前环境安装新的包，比如安装numpy，那么只需要执行下列命令： 1conda install numpy 离开虚拟环境windows中可以执行下列命令关闭虚拟环境： 1conda deactivate Linux或者macOS则是： 1source deactivate 删除虚拟环境或package删除myenv环境中的numpy包： 1conda remove --name myenv numpy 如果要删除整个虚拟环境，比如删除上面创建的myenv，需要先deactivate关闭该环境，再执行下列命令： 1conda env remove --name myenv 总结为不同的需求建立独立的虚拟环境是个很好的习惯。因为它不会影响其它的系统配置，如果某个版本出现了问题，可以很轻易的删除某个package，或者重新搭建虚拟环境。","categories":[{"name":"ai","slug":"ai","permalink":"http://example.com/categories/ai/"}],"tags":[]},{"title":"AI入门之环境安装","slug":"AI入门之环境安装","date":"2021-12-14T10:46:37.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"ai/AI入门之环境安装/","permalink":"http://example.com/ai/AI%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"","text":"学习AI，首先我们需要安装相关开发环境。本文主要安装Anaconda、Pytorch、Jupyter NoteBook。 AnacondaAnaconda是一个开源的Python和R语言的发行版本，用于计算科学（数据科学、机器学习、大数据处理和预测分析）。Anaconda是一个包管理器，也是一个环境管理器，个人版免费。 安装参考官网，选择不同的环境安装。 使用推荐的仅为我安装，否则开启Anaconda终端需要管理员权限。 安装过程中，勾选将Anaconda作为默认的Python环境: 官方不推荐把Anaconda3加到环境变量中。如果加到环境变量中，使用起来更方便，任意终端都可以输入conda命令，但是可能会造成一些问题需要卸载重装Anaconda。推荐不加环境变量，从开始目录选择Anaconda终端打开： 验证是否安装成功，在终端中输入conda –version后回车 如果把Anaconda3加到环境变量中，运行python时可能会看见下面的警告： 1234Warning:This Python interpreter is in a conda environment, but the environment hasnot been activated. Libraries may fail to load. To activate this environmentplease see https://conda.io/activation. Windows上，要解决上面的警告，需要运行c:\\Anaconda3\\Scripts\\activate base。这里的c:\\Anaconda3\\Scripts\\activate代表Anaconda是安装在c盘根目录下的，需要换成你自己的安装路径。安装路径最好是全英文且无空格的，可以避免很多未知的坑。 比如我是装在d盘下： 源修改源到国内镜像： 123456# 配置源conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/freeconda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main# 查看当前源conda config --show channels 常用命令1234conda create -n py38 python=3.8 #创建虚拟环境conda info -e #查看环境列表conda list #查看当前已安装的包conda install pytorch #安装开源软件包,比如安装pytorch PytorchPyTorch 是一个 Python 包，它提供了两个高级特性: 具有强大的GPU加速的张量计算(如NumPy) 深度神经网络需要时可以用别的Python包扩展PyTorch，比如NumPy、SciPy、Cython。 安装先配置镜像，解决下载速度慢，有的包不存在的问题： 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 安装： 1conda install pytorch torchvision torchaudio cpuonly 如果有安装失败的，就单独再安装一次。 验证： 123pythonimport torchtorch.Tensor([1]) Jupyter NoteBookJupyter NoteBook 把基于控制台的方法扩展的一个交互式计算的新方向，提供一个基于web的应用，捕捉整个计算过程:开发、记录和执行代码，以及交流结果。 web应用：一个基于浏览器的工具，用于交互式编写文档，结合了文本、数学、计算和它们的富媒体输出。 记事本文档: web应用程序中所有可见内容的表示，包括计算的输入和输出、解释性文本、数学、图像和对象的富媒体表示。 安装1conda install jupyterlab 使用在终端执行下面的命令，你将看到notebook打开了浏览器： 1jupyter notebook 开启服务后，终端会打印一些信息，比如web应用的地址（默认是http://localhost:8888）：","categories":[{"name":"ai","slug":"ai","permalink":"http://example.com/categories/ai/"}],"tags":[]},{"title":"前端文件系统","slug":"前端文件系统","date":"2021-11-16T17:58:10.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/前端文件系统/","permalink":"http://example.com/js/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"前言前端文件系统api（The File System Access API）让web应用可以读写用户本地的文件或文件夹。使我们可以开发出能够和用户本地文件交互的web应用，比如IDE，图片和视频编辑器，文字编辑器等等。 在用户开启web应用权限后，这些api可以直接在用户本地读写文件或文件夹，打开一个目录并显示里面的内容，在用户本地创建或删除文件夹和文件。 打开比如页面中有个打开按钮： 1&lt;div id=&quot;open&quot;&gt;打开&lt;/div&gt; 点击后，调用showOpenFilePicker就可以弹出文件选择窗，我们选择文件，再调用getFile即可获取文件的file数据，这个file数据和获取的file数据一样。 123456const openElm = document.getElementById(&#x27;open&#x27;)let fileHandleopenElm.addEventListener(&#x27;click&#x27;, async () =&gt; &#123; [fileHandle] = await window.showOpenFilePicker() const file = await fileHandle.getFile()&#125;) 上面的例子中，我们选择了一个文件，showOpenFilePicker返回了FileSystemFileHandle类型的数组： 这里的fileHandle将会很有用，后面的保存等操作都需要它。 区分 file pickers有时应用会有多个不同的picker，比如富文本编辑器可以打开文本，也可以打开图片，默认情况下，每个file picker会记住上次的路径，我们可以通过id来区分不同的file picker，让它们记住不同的最近一次打开的路径。 1234567const fileHandle1 = await window.showSaveFilePicker(&#123; id: &#x27;openText&#x27;,&#125;)const fileHandle2 = await window.showSaveFilePicker(&#123; id: &#x27;importImage&#x27;,&#125;) 不过这个功能，我在windows上Chrome版本 96.0.4664.45（正式版本） （64 位）上试验失败了，file picker没有记住上次打开的路径。 保存保存会重写原文件。 页面中，我们放一个打开和保存按钮，还有一个文本框： 123&lt;div id=&quot;open&quot;&gt;打开&lt;/div&gt;&lt;div id=&quot;save&quot;&gt;保存&lt;/div&gt;&lt;textarea id=&quot;textArea&quot;&gt;&lt;/textarea&gt; 点击打开按钮，我们选择文件，比如test.txt，并把文本内容显示到textArea： 123456openElm.addEventListener(&#x27;click&#x27;, async () =&gt; &#123; [fileHandle] = await window.showOpenFilePicker() const file = await fileHandle.getFile() const contents = await file.text() textArea.value = contents&#125;) 点击保存时调用writeFile： 123saveElm.addEventListener(&#x27;click&#x27;, () =&gt; &#123; writeFile(fileHandle, textArea.value)&#125;) writeFile函数中创建可写数据流，把textArea的内容写进去： 12345678async function writeFile(fileHandle, contents) &#123; // 创建一个FileSystemWritableFileStream用来写数据 const writable = await fileHandle.createWritable() // 把file的数据写到流中 await writable.write(contents) // 关闭文件并将内容写入磁盘 await writable.close()&#125; 写数据用到FileSystemWritableFileStream对象，它本质上是一个可写的流，调用fileHandle的createWritable就可以创建，调用createWritable时，浏览器会先检查是否有写的权限，没有的话浏览器就会弹对话框，让用户选择是否开启写权限： 用户拒绝时createWritable会抛出DOMException的错误： 这样，应用就不会保存更改。 上面的writeFile方法在写数据时用的contents是字符串，我们也可以用其它格式的数据，比如BufferSource，或者Blob： 123456async function writeURLToFile(fileHandle, url) &#123; const writable = await fileHandle.createWritable() const response = await fetch(url) // 让响应的数据流入文件中，pipeTo默认会关闭管道，不需要手动关闭 await response.body.pipeTo(writable)&#125; 我们还可以在打开时手动申请写的权限，用户打开文件时看到一个对话框，然后我们对打开的文件就有了读写权限，在保存时就不会再弹对话框。 通过下面的verifyPermission函数来判断fileHandle是否有读写权限，结果是true则开启了，false则是用户拒绝了。 12345678910111213141516async function verifyPermission(fileHandle, readWrite) &#123; const options = &#123;&#125; if (readWrite) &#123; options.mode = &#x27;readwrite&#x27; &#125; // 是否开启权限，是就返回true if ((await fileHandle.queryPermission(options)) === &#x27;granted&#x27;) &#123; return true &#125; // 请求开启权限，是就返回true if ((await fileHandle.requestPermission(options)) === &#x27;granted&#x27;) &#123; return true &#125; // 用户拒绝开启权限，返回false return false&#125; 另存另存会创建一个新的文件。调用showSaveFilePicker会弹出保存弹窗: 1await window.showSaveFilePicker() 保存类型types参数控制保存类型： 12345678910await window.showSaveFilePicker(&#123; types: [ &#123; description: &#x27;Text Files&#x27;, accept: &#123; &#x27;text/plain&#x27;: [&#x27;.txt&#x27;], &#125;, &#125;, ],&#125;) 默认目录同样的，我们也可以设置启动目录。如果你是编辑文本，会希望打开或保存时的文件夹路径是文档，如果是编辑图片，则默认图片文件夹，这个路径可以通过配置startIn来实现： 1startIn: &#x27;pictures&#x27; 还有其他目录可以配置： desktop： 桌面 documents： 文档 downloads： 下载 music： 音乐 pictures： 图片 videos： 视频windows中对应文件夹的这些目录： 除了上面这些通用的目录，你还可以设置为存在的文件或目录地址： 1234567891011const openElm = document.getElementById(&#x27;open&#x27;)const saveAsElm = document.getElementById(&#x27;saveAs&#x27;)let fileHandleopenElm.addEventListener(&#x27;click&#x27;, async () =&gt; &#123; [fileHandle] = await window.showOpenFilePicker()&#125;)saveAsElm.addEventListener(&#x27;click&#x27;, async () =&gt; &#123; window.showSaveFilePicker(&#123; startIn: fileHandle &#125;)&#125;) 上面的例子中，我们showOpenFilePicker打开了文件，在showSaveFilePicker保存时startIn传打开的fileHandle，即可将保存弹窗的路径设置为和打开时选择的文件路径一致。 文件夹打开文件夹showDirectoryPicker可以打开文件夹并获取其中的内容： 1234567openElm.addEventListener(&#x27;click&#x27;, async () =&gt; &#123; const dirHandle = await window.showDirectoryPicker() for await (const entry of dirHandle.values()) &#123; console.log(entry) &#125;&#125;) 如果没有权限，浏览器会弹对话框： 创建文件和文件夹在文件夹中，你可以用getFileHandle读取文件，用getDirectoryHandle读取文件夹，在可选参数中传create来控制当新文件和文件夹不存在时是否需要创建。 1234567// 打开文件夹const dirHandle = await window.showDirectoryPicker()// 在打开的文件夹中新建名为 &quot;My Documents&quot;的文件夹const newDirectoryHandle = await dirHandle.getDirectoryHandle(&#x27;My Documents&#x27;, &#123; create: true &#125;)// 在&quot;My Documents&quot;文件夹中新建名为 &quot;My Notes.txt&quot; 的文件const newFileHandle = await newDirectoryHandle.getFileHandle(&#x27;My Notes.txt&#x27;, &#123; create: true &#125;) 解析路径上面的例子在打开的文件夹中创建文件夹并在新文件夹中新建文件，我们可以解析新建文件的路径： 12const path = await dirHandle.resolve(newFileHandle)// path 的值是 [&quot;My Documents&quot;, &quot;My Notes.txt&quot;] 删除删除上面新建的My Notes.txt文件： 1await newDirectoryHandle.removeEntry(&#x27;My Notes.txt&#x27;) 删除上面的My Documents文件夹： 1await dirHandle.removeEntry(&#x27;My Documents&#x27;, &#123; recursive: true &#125;) 拖拽1234567891011121314151617181920window.addEventListener(&#x27;dragover&#x27;, async (e) =&gt; &#123; e.preventDefault()&#125;)window.addEventListener(&#x27;drop&#x27;, async (e) =&gt; &#123; e.preventDefault() // 遍历多有的item for (const item of e.dataTransfer.items) &#123; // 注意：文件和文件夹的kind都是file if (item.kind === &#x27;file&#x27;) &#123; const entry = await item.getAsFileSystemHandle() if (entry.kind === &#x27;directory&#x27;) &#123; // 处理文件夹 handleDirectoryEntry(entry) &#125; else &#123; // 处理文件 handleFileEntry(entry) &#125; &#125; &#125;&#125;) 补丁还不能给File System Access API打完整的补丁。 showOpenFilePicker可以用&lt;input type=&quot;file&quot;&gt;代替 showSaveFilePicker可以用&lt;a download=&quot;file_name&quot;&gt;代替，尽管这能触发下载，但不能覆盖现有文件 showDirectoryPicker可以用&lt;input type=&quot;file&quot; webkitdirectory&gt;替代browser-fs-access封装了前端文件系统api，会尽量使用File System Access API，不支持的浏览器使用其他方案。 安全Chrome团队设计并实现了文件系统访问API，使用了控制访问强大Web平台功能的核心原则。 打开或另存文件打开文件时，用户通过 file picker 提供读取文件的权限，用来打开的file picker只能用户手动点开，如果用户改变主意了，可以点取消，然后应用不会得到任何用户数据，表现和一样。 同样的，当应用要另存时，浏览器会弹出保存窗口，让用户指定文件名和位置。 文件夹限制为了保护用户及其数据，浏览器不允许用户保存到一些文件夹，比如核心操作系统文件夹。如果要保存到这些位置，浏览器会弹窗让用户选择其他路径。 保存保存时会覆盖源文件，web应用必须得到用户明确同意后才能保存。 如果用户要保存对开启了读取权限文件的更改，浏览器就会弹对话框，问用户是否要保存。 另外，可以编辑多个文件的web应用程序(比如IDE)也可以在打开时请求保存更改的权限。 如果在对话框中用户点击取消，不给写的权限，那么应用就不能保存更改。这时就需要提供保存的替代方案，让用户可以保存数据，比如提供下载途径，或者保存到云端等等。 透明用户开启应用保存权限后，浏览器会在地址栏显示一个图标，点击图标可以显示开启权限了的文件列表，也可以很方便的取消保存权限。 有效期同一个域名下所有的页面都关闭后，保存权限就没了，用户下一次访问时，会再次弹对话框来询问是否开启权限。 参考 The File System Access API: simplifying access to local files","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"前端那些文件格式","slug":"前端那些文件格式","date":"2021-11-08T17:35:10.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/前端那些文件格式/","permalink":"http://example.com/js/%E5%89%8D%E7%AB%AF%E9%82%A3%E4%BA%9B%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"前言在 Web 开发中，当我们处理文件时（创建，上传，下载），经常会遇到二进制数据。另一个典型的应用场景是图像处理。在 JavaScript 中有很多种二进制数据格式，比如ArrayBuffer，Uint8Array，DataView，Blob，File 等等，不过 JavaScript 中的二进制数据是以非标准方式实现的。 下面我们来了解下这些数据格式及相互转换。本文涉及到File,Blob,TypedArray,data url(Base64),blob url等等。 File首先，我们还是拿前文的例子来看，显示用户选择的图片。 我们创建一个页面。提供选择图片功能。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; name=&quot;选择图片&quot;/&gt; &lt;div class=&quot;wrap-image&quot;&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 选择图片后，需要将图片显示到canvas中，我们在上面的script标签中加入下面的代码： 12345678910111213const fileInput = document.getElementById(&#x27;fileInput&#x27;)const canvas = document.getElementById(&#x27;canvas&#x27;)fileInput.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; let img = new Image const file = e.target.files[0] img.src = URL.createObjectURL(file) img.onload = () =&gt; &#123; canvas.width = img.width canvas.height = img.height const context = canvas.getContext(&#x27;2d&#x27;) context.drawImage(img, 0, 0) &#125;&#125;, false) 选择一张图片后，change事件中获取到选择的文件e.target.files[0]： File 对象是特殊类型的 Blob，可以用在任意的 Blob 类型的 context 中。比如 FileReader, URL.createObjectURL(), createImageBitmap(), 及 XMLHttpRequest.send() 都能处理 Blob 和 File。File 接口也继承了 Blob 接口的属性。上图的Prototype展开可以看到继承自Blob: 上面是最常见的file获取方式————从中获取。此外，我们还可以用构造器： 1new File(fileParts, fileName, [options]) fileParts —— Blob&#x2F;BufferSource&#x2F;String 类型值的数组 fileName —— 文件名字符串 options —— 可选对象： lastModified —— 最后一次修改的时间戳（整数日期） FileReaderFileReader 的用途是从 Blob（因此也从 File）对象中读取数据。它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。 可以读取为3种格式： 读取方法 目标格式 readAsArrayBuffer(blob) 读取为二进制格式的 ArrayBuffer readAsText(blob, [encoding]) 读取为给定编码（默认为 utf-8 编码）的字符串 readAsDataURL(blob) 读取为 base64编码 的 data url 比如将 Blob 读取为 base64： 12const reader = new FileReader()reader.readAsDataURL(file) // 将 Blob 读取为 base64 使用时选择哪一种，要看如何使用数据。 读取过程中有下列事件： 1、loadstart: 开始加载2、progress: 在读取过程中出现3、load: 读取完成，没有 error4、abort: 调用了 abort()取消操作5、error: 出现 error6、loadend: 读取完成，无论成功还是失败 使用最广泛的是load和error，比如下面的例子： 12345678910111213141516&lt;input type=&quot;file&quot; onchange=&quot;readFile(this)&quot;&gt;&lt;script&gt;const readFile = (input) =&gt; &#123; const file = input.files[0] const reader = new FileReader() reader.readAsText(file) reader.onload = () =&gt; &#123; console.log(reader.result) // 结果 &#125; reader.onerror = () =&gt; &#123; console.log(reader.error) // error &#125;&#125;&lt;/script&gt; 不过大多数情况下，我们不需要读取Blob，通过网络发送一个File很容易，像 XMLHttpRequest 或 fetch 等 API 本身就接受 File 对象。或者用URL.createObjectURL(file) 创建一个短的 url，并将其赋给 或 。这样，文件便可以下载文件或者将其呈现为图像，作为 canvas 等的一部分。 Blob用URL.createObjectURL创建了一个url： 1img.src = URL.createObjectURL(file) 这里，URL.createObjectURL 取一个 Blob，并为其创建一个唯一的 URL，形式为 blob:&#x2F;。本例中创建的url如下： 1blob:null/a05be8a9-78b4-4470-bdfe-5fca427781c2 浏览器内部为每个通过 URL.createObjectURL 生成的URL存储了一个 URL → Blob 映射。可以通过URL访问 Blob。 但 Blob 本身只保存在内存中的。浏览器无法释放它。关闭页面时会自动释放内存中的Blob，也可以手动释放，通过URL.revokeObjectURL(url) 从内部映射中移除引用，Blob 被删除，并释放内存。 映射被删除后该 URL 也就不再起作用了，也就无法通过URL再访问Blob。 现在，我们了解了Blob作为URL的应用，那Blob到底是什么呢？ Blob 由一个可选的字符串 type（通常是 MIME 类型）和 blobParts 组成，blobParts是 一系列其他 Blob 对象，字符串和 BufferSource。 我们可以通过构造函数创建一个Blob： 1new Blob(blobParts, options) blobParts是 Blob&#x2F;BufferSource&#x2F;String 类型的值的数组。 options 可选对象： type： Blob 类型，通常是 MIME 类型，例如 image&#x2F;png， endings：是否转换换行符，使 Blob 对应于当前操作系统的换行符（\\r\\n 或 \\n）。默认为 “transparent”（啥也不做），不过也可以是 “native”（转换）。比如从字符串创建 Blob： 12// 注意：第一个参数必须是一个数组 [...]const blob = new Blob([&#x27;&lt;html&gt;…&lt;/html&gt;&#x27;], &#123;type: &#x27;text/html&#x27;&#125;) 图片 to Blob图像操作是通过canvas来实现的：1、使用 canvas.drawImage 在 canvas 上绘制图像（绘制后可以做一些图像处理，比如旋转、裁剪等等）；2、调用 canvas 的 toBlob(callback, format, quality)方法 创建一个 Blob。 比如，在上面的context.drawImage(img, 0, 0);后，我们把canvas转成Blob: 123canvas.toBlob((blob) =&gt; &#123; console.log(&#x27;blob&#x27;, blob)&#125;, &#x27;image/png&#x27;) 或者，更喜欢同步的写法： 123456img.onload = async () =&gt; &#123; ... context.drawImage(img, 0, 0) const blob = await new Promise(resolve =&gt; canvas.toBlob(resolve, &#x27;image/png&#x27;)) console.log(&#x27;blob&#x27;, blob)&#125; Blob to Base64URL.createObjectURL 的一个替代方法是，将 Blob 转换为 base64。base64编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且可读。我们可以在 data-url 中使用base64编码，data-url就像下面这样： 1data:[&lt;mediatype&gt;][;base64],&lt;data&gt; 我们可以像常规url一样使用data-url 。比如一张支持alpha透明度的webp的图片: 1&lt;img src=&quot;data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==&quot;&gt; 我们可以用 FileReader 将 Blob 转换为 base64: 1234567// img.src = URL.createObjectURL(file)const reader = new FileReader()reader.readAsDataURL(file) // 将 Blob 转换为 base64 并调用 onloadreader.onload = () =&gt; &#123; img.src = reader.result&#125; 现在我们可以从Blob创建2种url，一种是blob url，一种是data url，下面我们对比下这2种方式： blob url data url 创建方式 URL.createObjectURL FileReader 内存 需手动撤销（revoke） 无需操作 访问 直接访问 Blob，无需“编码&#x2F;解码” 对大的 Blob 进行编码时，性能和内存会有损耗 所以要使用哪种url，需要具体情况再分析。 ArrayBuffer基本的二进制对象 ArrayBuffer是对固定长度的连续内存空间的引用，是一个内存区域，一个原始的二进制数据。 我们可以这样创建一个长度为 16 的 buffer： 1let buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer 注意：ArrayBuffer 和 Array 没有任何关系 我们可以通过 FileReader 的 readAsArrayBuffer 读取 Blob 的二进制数据： 12345const reader = new FileReader()reader.readAsArrayBuffer(file)reader.onload = () =&gt; &#123; const buffer = reader.result&#125; 或者用Blob的arrayBuffer方法： 1const buffer = await file.arrayBuffer() 上面我们看到了Int8Array、Uint8Array、Int16Array，它们的通用术语是TypedArray，此外，还有其他的TypedArray。 TypedArray 用途 Uint8Array，Uint16Array，Uint32Array 用于 8、16 和 32 位的无符号整数 Uint8ClampedArray 用于 8 位整数，对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0 Int8Array，Int16Array，Int32Array 用于有符号整数（可以为负数） Float32Array，Float64Array 用于 32 位和 64 位的有符号浮点数 总结现在回顾一下：1、&lt;input type=&quot;file&quot;&gt;是最常见的File获取方式;2、File对象是特殊类型的 Blob;3、Blob可以生成blob url;4、FileReader可以读取Blob为3种格式，二进制格式的 ArrayBuffer，给定编码的字符串，base64编码的 data url;5、blob url和data url都可以作为url使用;6、Blob对象的arrayBuffer方法可以读取Blob的ArrayBuffer;7、canvas.toBlob(callback, format, quality)可以把canvas读取为Blob; 下图可以很直观的看到它们之间的相关转换关系：","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"WebGL及其图像处理入门","slug":"WebGL及其图像处理入门","date":"2021-10-26T17:12:11.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/WebGL及其图像处理入门/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/WebGL%E5%8F%8A%E5%85%B6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/","excerpt":"","text":"前言WebGL仅仅是一个光栅化引擎，它可以根据你的代码绘制出点，线和三角形。想要利用WebGL完成更复杂任务，取决于你能否提供合适的代码，组合使用点，线和三角形代替实现。 本文将带大家了解WebGL基础的绘制流程，并结合之前图片滤镜（基础滤镜和lut滤镜）和图像卷积（模糊、锐化等）的应用，用WebGL来实现。 获取WebGLWebGL基于HTML5 Canvas，所以我们需要使用Canvas作为载体。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;WebGL入门&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; name=&quot;选择图片&quot;/&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 再通过getContext方法来获取WebGL上下文。在上面的script标签内加入下面的代码： 12const canvas = document.getElementById(&#x27;canvas&#x27;);const gl = canvas.getContext(&#x27;webgl&#x27;); 清空12gl.clearColor(1.0, 1.0, 0.0, 1.0); // 设置清空颜色缓冲区时的颜色gl.clear(gl.COLOR_BUFFER_BIT); // 清空颜色缓冲区 直接运行上面的2行代码清空，我们可以看到canvas被填充满了黄色。因为gl.clearColor中接受RGBA四个值的范围是0~1，所以如果gl.clearColor(0.0, 0.0, 0.0, 1.0)就会填充黑色。 画点12345678910111213141516171819202122232425262728293031323334353637383940function drawPoint() &#123; // 1、获取webgl const canvas = document.getElementById(&#x27;canvas&#x27;); const gl = canvas.getContext(&#x27;webgl&#x27;); if (!gl) &#123; return; &#125; // 2、清空屏幕 gl.clearColor(0, 0, 0, 1); gl.clear(gl.COLOR_BUFFER_BIT); // 3、获取着色器资源 const vertexSource = document.getElementById(&#x27;vertex-shader-2d&#x27;).innerHTML; const fragmentSource = document.getElementById(&#x27;fragment-shader-2d&#x27;).innerHTML; // 4、创建顶点着色器对象 let vertexShader = gl.createShader(gl.VERTEX_SHADER); // 绑定资源 gl.shaderSource(vertexShader, vertexSource); // 编译着色器 gl.compileShader(vertexShader); let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, fragmentSource); gl.compileShader(fragmentShader); // 5、创建一个着色器程序 let program = gl.createProgram(); // 把前面创建的两个着色器对象加到着色器程序中 gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); // 连接着色器程序 gl.linkProgram(program); // 使用程序 gl.useProgram(program); // 6、画点 gl.drawArrays(gl.POINTS, 0, 1);&#125; 运行drawPoint函数后我们会看到300x300的canvas被填充成黑色，中间有一个10x10的白色点。 现在来解读下上面的代码。 分为6步来看，前两步获取webgl并清空屏幕。 第3步获取OpenGL Shading Language（GLSL）编写的着色程序。 该语言运行于GPU，是类似于C或C++的强类型语言，它总是成对出现，每对方法中一个叫顶点着色器，另一个叫片断着色器，组合起来称作一个 program（着色程序） 顶点着色器的作用是计算顶点的位置，根据位置对点， 线和三角形在内的一些图元进行光栅化处理。片断着色器的作用是计算出当前绘制图元中每个像素的颜色值。 可以利用JavaScript中创建字符串的方式创建GLSL字符串： 12345678910111213141516171819// 顶点着色器const vertexSource = ` attribute vec4 a_position; void main () &#123; // gl_Position为内置变量，表示当前点的位置 gl_Position = a_position; // gl_Position为内置变量，表示当前点的大小，为浮点类型 gl_PointSize = 10.0; &#125;`;// 片段着色器const fragmentSource = ` // 设置浮点数精度 precision mediump float; void main () &#123; // vec4是表示四维向量，这里用来表示RGBA的值[0~1]，均为浮点数 gl_FragColor = vec4(1.0, 0.5, 1.0, 1.0); &#125;`; 或者跟本文的例子一样，将它们放在非JavaScript类型的标签中： 12345678910111213141516171819&lt;!-- 顶点着色器 --&gt;&lt;script type=&#x27;x-shader/x-vertex&#x27; id=&#x27;vertex-shader-2d&#x27;&gt; attribute vec4 a_position; void main () &#123; // gl_Position为内置变量，表示当前点的位置 gl_Position = a_position; // gl_Position为内置变量，表示当前点的大小，为浮点类型，如果赋值是整数类报错 gl_PointSize = 10.0; &#125;&lt;/script&gt;&lt;!-- 片段着色器 --&gt;&lt;script type=&#x27;x-shader/x-fragment&#x27; id=&#x27;fragment-shader-2d&#x27;&gt; // 设置浮点数精度 precision mediump float; void main () &#123; // vec4是表示四维向量，这里用来表示RGBA的值[0~1]，均为浮点数，如为整数则错 gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); &#125;&lt;/script&gt; 这里a_position属性的数据类型是vec4，vec4是一个有四个浮点数据的数据类型。 GLSL中命名约定： a_ 代表属性，值从缓冲中提供； u_ 代表全局变量，直接对着色器设置； v_ 代表可变量，是从顶点着色器的顶点中插值来出来的。 获取到着色器资源后，接着创建着色器，绑定资源并编译，然后创建着色程序，把编译好的2个着色器加进来，再连接和使用该着色程序。到这一步我们的着色程序就初始化完毕。最后就是绘制drawArrays。 由于drawArrays之前的步骤应用频繁，下面我们把它们封装起来。 创建着色器着色器都是成对出现的，比如本例中的vertexShader和fragmentShader。获取着色器资源source后，根据type创建不同的着色器，vertexShader的type是gl.VERTEX_SHADER，fragmentShader的type是gl.FRAGMENT_SHADER。然后绑定并编译。 123456789101112function createShader(gl, type, source) &#123; const shader = gl.createShader(type); // 创建 shader 对象 gl.shaderSource(shader, source); // 往 shader 中传入源代码 gl.compileShader(shader); // 编译 shader // 是否编译成功 const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS); if (success) &#123; return shader; &#125; console.log(gl.getShaderInfoLog(shader)); gl.deleteShader(shader);&#125; 创建着色程序创建着色程序，把着色器加进来，链接程序。 12345678910111213function createProgram(gl, vertexShader, fragmentShader) &#123; const program = gl.createProgram(); // 创建 program 对象 gl.attachShader(program, vertexShader); // 往 program 对象中传入 WebGLShader 对象 gl.attachShader(program, fragmentShader); gl.linkProgram(program); // 链接 program // 是否链接成功 const success = gl.getProgramParameter(program, gl.LINK_STATUS); if (success) &#123; return program; &#125; console.log(gl.getProgramInfoLog(program)); gl.deleteProgram(program);&#125; 然后通过着色器script标签的id，创建连接好的着色程序： 12345678function createProgramFromScripts (gl, vertexShaderScriptId, fragmentShaderScriptId) &#123; const vertexSource = document.getElementById(vertexShaderScriptId).innerHTML; const fragmentSource = document.getElementById(fragmentShaderScriptId).innerHTML; const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource); // 创建顶点着色器 const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource); // 创建片元着色器 const program = createProgram(gl, vertexShader, fragmentShader); // 创建 WebGLProgram 程序 return program;&#125; 封装好之后，上面的drawPoint函数就可以优化成下面这样： 12345678910111213141516171819// 1、获取webglconst canvas = document.getElementById(&#x27;canvas&#x27;);const gl = canvas.getContext(&#x27;webgl&#x27;);if (!gl) &#123; return;&#125;// 2、清空屏幕gl.clearColor(0, 0, 0, 1);gl.clear(gl.COLOR_BUFFER_BIT);// 3、创建连接好的着色程序const program = createProgramFromScripts(gl, &#x27;vertex-shader-2d&#x27;, &#x27;fragment-shader-2d&#x27;);// 4、使用上面的着色程序gl.useProgram(program);// 5、画点gl.drawArrays(gl.POINTS, 0, 1); 画多个点上面我们画了一个点，现在画多个点。比如下面的3个点： 12345const points = [ 0, 0.0, 0.5, 0.0, 0.0, 0.5]; 需要把这3个点的数据传给webgl: 12345// 创建一个buffer，用来放3个点在裁剪空间的坐标const buffer = gl.createBuffer();// buffer和ARRAY_BUFFER绑定（可以理解成ARRAY_BUFFER = buffer）gl.bindBuffer(gl.ARRAY_BUFFER, buffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW); 接着获取shader中a_position的地址并做一些配置： 1234567891011const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;); // 获取shader中a_position的地址gl.enableVertexAttribArray(positionAttributeLocation); // 开启attribute// 告诉attribute如何从positionBuffer(ARRAY_BUFFER)中读取数据gl.vertexAttribPointer( positionAttributeLocation, // 属性值a_position的位置 2, // 每次迭代运行提取两个单位数据 gl.FLOAT, // 每个单位的数据类型是32位浮点型 false, // 不需要标准化 0, // 用符合单位类型和单位个数的大小 0， // 从缓冲起始位置开始读取); 最后绘制3个点： 1gl.drawArrays(gl.POINTS, 0, 3); // 绘制3个点 把上面的绘制3个点改一下，可以绘制成三角形： 1gl.drawArrays(gl.TRIANGLES, 0, 3); // 绘制三角形 因为图元类型primitiveType为三角形gl.TRIANGLES， 顶点着色器每运行三次WebGL将会根据三个gl_Position值绘制一个三角形。 关于buffer和attribute上面我们用到了buffer和attribute，那它们是干什么的呢？ 其实，缓冲操作是GPU获取顶点数据的一种方式。gl.createBuffer创建一个缓冲；gl.bindBuffer是设置缓冲为当前使用缓冲； gl.bufferData将数据拷贝到缓冲，这个操作一般在初始化完成。一旦数据存到缓冲中，还需要告诉WebGL怎么从缓冲中提取数据传给顶点着色器的属性。 首先，我们要获取WebGL给属性分配的地址，这一步一般在初始化时完成。 12// 询问顶点数据应该放在哪里const positionAttributeLocation = gl.getAttribLocation(program, &#x27;a_position&#x27;); 绘制前还需要发出3个命令。 1、告诉WebGL我们想从缓冲中提供数据。 1gl.enableVertexAttribArray(location); 2、将缓冲绑定到 ARRAY_BUFFER 绑定点，它是WebGL内部的一个全局变量。 1gl.bindBuffer(gl.ARRAY_BUFFER, someBuffer); 3、告诉WebGL从 ARRAY_BUFFER 当前绑定点的缓冲获取数据。 1234567gl.vertexAttribPointer( location, numComponents, typeOfData, normalizeFlag, strideToNextPieceOfData, offsetIntoBuffer); numComponents: 每个顶点有几个单位的数据(1 - 4)typeOfData: 单位数据类型是什么(BYTE, FLOAT, INT, UNSIGNED_SHORT, 等等…)normalizeFlag: 标准化strideToNextPieceOfData: 从一个数据到下一个数据要跳过多少位offsetIntoBuffer: 数据在缓冲的什么位置 如果每个类型的数据都用一个缓冲存储，stride 和 offset 都是 0 。stride 为 0 表示 “用符合单位类型和单位个数的大小”。 offset 为 0 表示从缓冲起始位置开始读取。它们用 0 以外的值会复杂得多，虽然这样会取得一些性能能上的优势， 但是一般情况下并不值得。 标准化标记（normalizeFlag）适用于所有非浮点型数据。如果传递false就解读原数据类型。 坐标转换上面的例子中，我们的顶点坐标都是裁剪空间坐标，比如： 12345const points = [ 0, 0.0, 0.5, 0.0, 0.0, 0.5]; 裁剪空间的x范围是[-1, 1]，正方向向右，y的范围也是[-1, 1]，正方向向上。 对于描述二维空间中的物体，比起裁剪空间坐标你可能更希望使用屏幕像素坐标。所以我们来改造一下顶点着色器： 12345678910111213141516&lt;script type=&#x27;x-shader/x-vertex&#x27; id=&#x27;vertex-shader-2d&#x27;&gt;attribute vec2 a_position;uniform vec2 u_resolution;void main () &#123; // 像素坐标转到 0.0 到 1.0 vec2 zeroToOne = a_position.xy / u_resolution; // 0-&gt;1 转到 0-&gt;2 vec2 zeroToTwo = zeroToOne * 2.0; // 0-&gt;2 转到 -1-&gt;+1 (即裁剪空间) vec2 clipSpace = zeroToTwo - 1.0; gl_Position = vec4(clipSpace, 0, 1);&#125;&lt;/script&gt; 然后我们用像素坐标表示新的3个点： 12345const points = [ 0, 0, 100, 0, 0, 100]; 使用program后，我们需要获取vertex-shader-2d中添加的全局变量u_resolution的位置，并设置分辨率： 123const resolutionUniformLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);// 设置全局变量 分辨率gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height); 然后绘制三角形： 1gl.drawArrays(gl.TRIANGLES, 0, 3); 这时，我们的坐标系原点在左下角，如果要像传统二维API那样原点在左上角，我们只需翻转y轴： 12// gl_Position = vec4(clipSpace, 0, 1);gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); // 翻转y轴 画矩形我们将通过绘制两个三角形来绘制一个矩形，每个三角形有三个点，所以一共有6个点： 12345678const points = [ 100, 100, 200, 100, 100, 200, 200, 100, 100, 200, 200, 200]; 然后绘制时把次数改成6次： 12// 绘制gl.drawArrays(gl.TRIANGLES, 0, 6); 画图改造着色器首先我们接着改造上面坐标转换后的顶点着色器，增加a_texCoord和v_texCoord。 12345678910attribute vec2 a_texCoord;...varying vec2 v_texCoord;void main() &#123; ... // 将纹理坐标传给片断着色器 // GPU会在点之间进行插值 v_texCoord = a_texCoord;&#125; 然后用片断着色器寻找纹理上对应的颜色： 1234567891011121314&lt;script id=&quot;fragment-shader-2d&quot; type=&quot;x-shader/x-fragment&quot;&gt;precision mediump float;// 纹理uniform sampler2D u_image;// 从顶点着色器传入的纹理坐标varying vec2 v_texCoord;void main() &#123; // 在纹理上寻找对应颜色值 gl_FragColor = texture2D(u_image, v_texCoord);&#125;&lt;/script&gt; 加载图片点击选择图片按钮后，加载图片，图片加载完成后开始绘制图片。 123456789101112const inputElement = document.getElementById(&#x27;fileInput&#x27;);const canvasElement = document.getElementById(&#x27;canvas&#x27;);fileInput.addEventListener(&#x27;change&#x27;, async (e) =&gt; &#123; const imgElement = document.getElementById(&#x27;canvas&#x27;); const img = new Image(); img.src = URL.createObjectURL(e.target.files[0]); img.onload = function () &#123; imgElement.width = img.width; imgElement.height = img.height; drawPic(img); // 绘制图片 &#125;&#125;, false); 绘制图片绘制图片我们在drawPic函数中进行，首先获取gl并创建着色程序： 1234567891011function drawPic(image) &#123; // 获取webgl const canvas = document.getElementById(&#x27;canvas&#x27;); const gl = canvas.getContext(&#x27;webgl&#x27;); if (!gl) &#123; return; &#125; // 创建连接好的着色程序 const program = createProgramFromScripts(gl, &#x27;vertex-shader-2d&#x27;, &#x27;fragment-shader-2d&#x27;);&#125; 接着找2个顶点坐标位置（分别是矩形和纹理的坐标）： 12let positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);let texcoordLocation = gl.getAttribLocation(program, &quot;a_texCoord&quot;); 再画一个和图片一样大小的矩形，首先我们获取画矩形需要的6个点： 123456789101112const x1 = 0;const x2 = image.width;const y1 = 0;const y2 = image.height;const points = [ x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2,] 再和上文一样，把点的数据传给webgl，并设置读取方式: 1234567let positionBuffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);// 开启 position attributegl.enableVertexAttribArray(positionLocation);// 告诉attribute如何从positionBuffer(ARRAY_BUFFER)中读取数据gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); 然后创建纹理： 123// 创建纹理let texture = gl.createTexture();gl.bindTexture(gl.TEXTURE_2D, texture); 并对图片渲染做设置，保证可以渲染任何尺寸的图片： 1234gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); 然后把图片加载到上面创建的纹理中： 1gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); 然后告诉webgl如何从裁剪空间转换到像素空间： 1gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); 然后对a_texCoord的地址并做一些配置。渲染纹理时需要纹理坐标，而不是像素坐标，无论纹理是什么尺寸，纹理坐标范围始终是 0.0 到 1.0： 1234567891011121314gl.enableVertexAttribArray(texcoordLocation);// 给矩形提供纹理坐标let texCoordBuffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0); 接着清空屏幕并使用着色程序： 1234gl.clearColor(0, 0, 0, 0);gl.clear(gl.COLOR_BUFFER_BIT);gl.useProgram(program); 再设置全局变量分辨率： 12let resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height); 到现在就可以画矩形了(6个点画2个三角形组成矩形)： 1gl.drawArrays(gl.TRIANGLES, 0, 6); 到这里图片就出现了： 简单说就是，我们画了一个和图片一样大的矩形，创建了一个纹理并把图片传到纹理中，再把纹理贴到矩形上，这样图片就显示出来了。 操作像素现在我们对图片做一些简单的像素操作。 换位比如红蓝换位，我们只需要改片段着色器： 1gl_FragColor = texture2D(u_image, v_texCoord).bgra; 灰度解析出颜色通道后，做加权算法，再重新设置颜色： 123vec4 color = texture2D(u_image, v_texCoord);float gray = 0.2989 * color.r + 0.5870 * color.g + 0.1140*color.b;gl_FragColor = vec4(gray, gray, gray, color.a); 更多改变像素颜色的风格算法，可以看看之前写的《前端基础滤镜》。 颜色查找表颜色查找表又叫LUT(look up table)，可以实现自定义且多样的风格化滤镜，不清楚的可以看之前写的《前端如何通过LUT实现图片滤镜》。 首先需要创建一个新的片断着色器，实现LUT算法。（顶点着色器和上面画图的一样） 1234567891011121314151617181920212223242526&lt;script type=&#x27;x-shader/x-fragment&#x27; id=&#x27;fragment-shader-2d&#x27;&gt; precision mediump float; varying lowp vec2 v_texCoord; uniform sampler2D u_image0; uniform sampler2D u_image1; void main() &#123; vec4 textureColor = texture2D(u_image0, v_texCoord); float blueColor = textureColor.b * 63.0; vec2 quad1; quad1.y = floor(floor(blueColor) / 8.0); quad1.x = floor(blueColor) - (quad1.y * 8.0); vec2 quad2; quad2.y = floor(ceil(blueColor) / 8.0); quad2.x = ceil(blueColor) - (quad2.y * 8.0); vec2 texPos1; texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r); texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g); vec2 texPos2; texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r); texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g); lowp vec4 newColor1 = texture2D(u_image1, texPos1); lowp vec4 newColor2 = texture2D(u_image1, texPos2); lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor)); gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), 1.0); &#125;&lt;/script&gt; 然后改造下我们的html，除了上传图片，我们还需要上传lut图片，再增加一个应用按钮： 1234&lt;input type=&quot;file&quot; id=&quot;fileInput&quot; /&gt;&lt;input type=&quot;file&quot; id=&quot;lutInput&quot; /&gt;&lt;div id=&quot;applyLUT&quot;&gt;应用&lt;/div&gt;&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; 再给它们绑定事件，上传图片后设置图片地址，点击应用按钮时应用lut滤镜效果： 123456789101112131415161718const fileInput = document.getElementById(&#x27;fileInput&#x27;);const lutInput = document.getElementById(&#x27;lutInput&#x27;);const applyElement = document.getElementById(&#x27;applyLUT&#x27;);let image = new Image();let filterImage = new Image();fileInput.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; image.src = URL.createObjectURL(e.target.files[0]);&#125;, false);lutInput.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; filterImage.src = URL.createObjectURL(e.target.files[0]);&#125;, false);applyElement.addEventListener(&#x27;click&#x27;, () =&gt; &#123; applyLUT()&#125;) 接下来就是应用lut滤镜函数applyLUT，首先获取gl并创建连接好的着色程序： 1234567891011function applyLUT() &#123; // 获取webgl const canvas = document.getElementById(&#x27;canvas&#x27;); const gl = canvas.getContext(&#x27;webgl&#x27;); if (!gl) &#123; return; &#125; // 创建连接好的着色程序 const program = createProgramFromScripts(gl, &#x27;vertex-shader-2d&#x27;, &#x27;fragment-shader-2d&#x27;);&#125; 接着找地址： 123456const positionLocation = gl.getAttribLocation(program, &#x27;a_position&#x27;);const texcoordLocation = gl.getAttribLocation(program, &#x27;a_texCoord&#x27;);const resolutionLocation = gl.getUniformLocation(program, &#x27;u_resolution&#x27;);const u_image0Location = gl.getUniformLocation(program, &#x27;u_image0&#x27;);const u_image1Location = gl.getUniformLocation(program, &#x27;u_image1&#x27;); 然后设置canvas宽高和图片一样： 12canvas.width = image.width;canvas.height = image.height; 再传图片和lut图片数据： 123456789101112131415const image_texture = gl.createTexture();gl.bindTexture(gl.TEXTURE_2D, image_texture);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBUNSIGNED_BYTE, image);const filterImage_texture = gl.createTexture();gl.bindTexture(gl.TEXTURE_2D, filterImage_texture);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBUNSIGNED_BYTE, filterImage); 然后设置positionLocation和texcoordLocation： 12345678910111213141516171819202122232425const positionBuffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0, 0, canvas.width, 0, 0, canvas.height, 0, canvas.height, canvas.width, 0, canvas.width, canvas.height,]), gl.STATIC_DRAW);gl.enableVertexAttribArray(positionLocation);gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);const texcoordBuffer = gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0,]), gl.STATIC_DRAW);gl.enableVertexAttribArray(texcoordLocation);gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0); 最后就是清空、使用着色程序、设置窗口等配置及画矩形了： 12345678910111213gl.clearColor(0, 0, 0, 0);gl.clear(gl.COLOR_BUFFER_BIT);gl.useProgram(program);gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);gl.uniform1i(u_image0Location, 0);gl.uniform1i(u_image1Location, 1);gl.activeTexture(gl.TEXTURE0);gl.bindTexture(gl.TEXTURE_2D, image_texture);gl.activeTexture(gl.TEXTURE1);gl.bindTexture(gl.TEXTURE_2D, filterImage_texture);gl.drawArrays(gl.TRIANGLES, 0, 6); 到这里我们就能看到应用滤镜后的图片，比如我们应用下面这个lut文件： 点击应用后效果： 卷积卷积在图片处理上应用广泛，可以实现比如边缘检测、锐化、模糊等等我们将在片断着色器中计算卷积，所以创建一个新的片断着色器。 123456789101112131415161718192021222324252627282930&lt;script id=&quot;fragment-shader-2d&quot; type=&quot;x-shader/x-fragment&quot;&gt;precision mediump float;// 纹理uniform sampler2D u_image;uniform vec2 u_textureSize;uniform float u_kernel[9];uniform float u_kernelWeight;// 从顶点着色器传入的纹理坐标varying vec2 v_texCoord;void main() &#123; vec2 onePixel = vec2(1.0, 1.0) / u_textureSize; vec4 colorSum = texture2D(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] + texture2D(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] + texture2D(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] + texture2D(u_image, v_texCoord + onePixel * vec2(-1, 0)) * u_kernel[3] + texture2D(u_image, v_texCoord + onePixel * vec2( 0, 0)) * u_kernel[4] + texture2D(u_image, v_texCoord + onePixel * vec2( 1, 0)) * u_kernel[5] + texture2D(u_image, v_texCoord + onePixel * vec2(-1, 1)) * u_kernel[6] + texture2D(u_image, v_texCoord + onePixel * vec2( 0, 1)) * u_kernel[7] + texture2D(u_image, v_texCoord + onePixel * vec2( 1, 1)) * u_kernel[8] ; // 只把rgb值求和除以权重 // 将阿尔法值设为 1.0 gl_FragColor = vec4((colorSum / u_kernelWeight).rgb, 1.0);&#125;&lt;/script&gt; 在JavaScript中，我们继续改造上面的drawPic函数，首先找到下面3个地址： 123let textureSizeLocation = gl.getUniformLocation(program, &quot;u_textureSize&quot;);let kernelLocation = gl.getUniformLocation(program, &quot;u_kernel[0]&quot;);let kernelWeightLocation = gl.getUniformLocation(program, &quot;u_kernelWeight&quot;); 然后在drawArrays前设置图片大小，提供卷积核，并设置卷积核及其权重： 1234567891011// 设置图片大小gl.uniform2f(textureSizeLocation, width, image.height);const kernel = [ -1, -1, -1, -1, 8, -1, -1, -1, -1]// 设置卷积核及其权重gl.uniform1fv(kernelLocation, kernel);gl.uniform1f(kernelWeightLocation, computeKernelWeight(kernel)); 123456function computeKernelWeight(kernel) &#123; let weight = kernel.reduce(function (prev, curr) &#123; return prev + curr; &#125;); return weight &lt;= 0 ? 1 : weight;&#125; 上传图片后就能看到应用卷积核后的效果： 下面是一些常见的卷积核： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102let kernels = &#123; normal: [ 0, 0, 0, 0, 1, 0, 0, 0, 0 ], gaussianBlur: [ 0.045, 0.122, 0.045, 0.122, 0.332, 0.122, 0.045, 0.122, 0.045 ], gaussianBlur2: [ 1, 2, 1, 2, 4, 2, 1, 2, 1 ], gaussianBlur3: [ 0, 1, 0, 1, 1, 1, 0, 1, 0 ], unsharpen: [ -1, -1, -1, -1, 9, -1, -1, -1, -1 ], sharpness: [ 0,-1, 0, -1, 5,-1, 0,-1, 0 ], sharpen: [ -1, -1, -1, -1, 16, -1, -1, -1, -1 ], edgeDetect: [ -0.125, -0.125, -0.125, -0.125, 1, -0.125, -0.125, -0.125, -0.125 ], edgeDetect2: [ -1, -1, -1, -1, 8, -1, -1, -1, -1 ], edgeDetect3: [ -5, 0, 0, 0, 0, 0, 0, 0, 5 ], edgeDetect4: [ -1, -1, -1, 0, 0, 0, 1, 1, 1 ], edgeDetect5: [ -1, -1, -1, 2, 2, 2, -1, -1, -1 ], edgeDetect6: [ -5, -5, -5, -5, 39, -5, -5, -5, -5 ], sobelHorizontal: [ 1, 2, 1, 0, 0, 0, -1, -2, -1 ], sobelVertical: [ 1, 0, -1, 2, 0, -2, 1, 0, -1 ], previtHorizontal: [ 1, 1, 1, 0, 0, 0, -1, -1, -1 ], previtVertical: [ 1, 0, -1, 1, 0, -1, 1, 0, -1 ], boxBlur: [ 0.111, 0.111, 0.111, 0.111, 0.111, 0.111, 0.111, 0.111, 0.111 ], triangleBlur: [ 0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625 ], emboss: [ -2, -1, 0, -1, 1, 1, 0, 1, 2 ] ; 也可以看看之前写的《卷积在前端图像处理上的应用》。 参考 WebGL 基础概念 WebGL 图像处理 webgl-lut-filter webgl-utils","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"openCVjs图像处理之自动矫正","slug":"openCVjs图像处理之自动矫正","date":"2021-10-21T17:01:04.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/openCVjs图像处理之自动矫正/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/openCVjs%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E8%87%AA%E5%8A%A8%E7%9F%AB%E6%AD%A3/","excerpt":"","text":"前文我们写了如何做手动矫正，那需要用户手动框选需要矫正的四边形，而本文，我们简单的实现一种自动矫正，程序检测出图像中的四边形后，自动矫正，不需要手动框选四边形。 跟上文一样，我们的图片处理程序放在处理按钮的点击事件中： 123changeImageElement.onclick = function () &#123; // 图片处理&#125; 首先读取图片： 1let src = cv.imread(&quot;imageUpload&quot;); 接着做一些预处理，先灰度： 12let dst = new cv.Mat();cv.cvtColor(src, dst, cv.COLOR_BGR2GRAY, 0); // 转灰度 再高斯模糊： 1cv.GaussianBlur(dst, dst, new cv.Size(3, 3), 0); // 高斯模糊 再Canny检测边缘： 1cv.Canny(dst, dst, 75, 200); // 边缘检测 检测出边缘后，通过findContours找出所有轮廓： 123let contours = new cv.MatVector();let hierarchy = new cv.Mat();cv.findContours(dst, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE) 然后从所有轮廓中找到面积最大的闭合轮廓： 12345678let index = 0, maxArea = 0;for (let i = 0; i &lt; contours.size(); ++i) &#123; let tempArea = Math.abs(cv.contourArea(contours.get(i))); if (tempArea &gt; maxArea) &#123; index = i; maxArea = tempArea; &#125;&#125; 如果把这个找到的轮廓显示出来，就是这样： 然后通过上面找到的轮廓进行多边形拟合，从而得到4个顶点： 123456789101112const foundCours = contours.get(index);const arcL = cv.arcLength(foundCtrue);let tmp = new cv.Mat();// 逼近多边形cv.approxPolyDP(foundCours, tmp, 0.01 * arcL, true);let points = [];if (tmp.total() === 4) &#123; const data32S = tmp.data32S; for (let i = 0, len = data32S.length / 2; i &lt; len; i++) &#123; points[i] = &#123; x: data32S[i * 2], y: data32S[i * 2 + 1] &#125;; &#125;&#125; 把points打印出来可以看到，已经得到了4个顶点坐标： 接着对4个顶点进行排序，从左上角开始，顺时针排序： 123456789101112function getSortedVertex(points) &#123; const center = &#123; x: points.reduce((sum, p) =&gt; sum + p.x, 0) / 4, y: points.reduce((sum, p) =&gt; sum + p.y, 0) / 4 &#125; let sortedPoints = [] sortedPoints.push(points.find(p =&gt; p.x &lt; center.x &amp;&amp; p.y &lt; center.y)) sortedPoints.push(points.find(p =&gt; p.x &gt; center.x &amp;&amp; p.y &lt; center.y)) sortedPoints.push(points.find(p =&gt; p.x &gt; center.x &amp;&amp; p.y &gt; center.y)) sortedPoints.push(points.find(p =&gt; p.x &lt; center.x &amp;&amp; p.y &gt; center.y)) return sortedPoints&#125; 调用上面的getSortedVertex可以得到排序后的顶点，我们将顶点依次放入数组srcPoints中： 1234let srcPoints = []getSortedVertex(points).forEach(p =&gt; &#123; srcPoints.push(p.x, p.y)&#125;) 接着和上文一样，进行透视变换即可，假设我们输出的图像宽408，高380，那么： 123456const dstPoints = [0, 0, 408, 0, 408, 380, 0, 380]const srcTri = cv.matFromArray(4, 1, cv.CV_3srcPoints);const dstTri = cv.matFromArray(4, 1, cv.CV_3dstPoints);const M1 = cv.getPerspectiveTransform(srcTri, dstTri)const dsize = new cv.Size(408, 380);cv.warpPerspective(src, dst, M1, dsize) 最后把处理过的图像显示到画布中，不要忘记删除不用的Mat： 12cv.imshow(&#x27;canvasOutput&#x27;, dst);tmp.delete; src.delete(); dst.delete(); 总结：该算法实现比较简单。在预处理中，还可以缩小图片，从而加快处理速度，最后找的的顶点坐标再放大。也可能无法检测到四边形，从而无法得到4个顶点。可以往两个方向优化。1、检测时通过识别直线，再筛选直线，来找到四边形；2、边缘检测神经网络。但复杂的图像识别总有误差的可能，这时候手动就派上用场了。不过简单的图像基本ok，比如银行卡照片的矫正：","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"openCVjs图像处理之手动矫正","slug":"openCVjs图像处理之手动矫正","date":"2021-10-19T15:43:07.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/openCVjs图像处理之手动矫正/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/openCVjs%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E6%89%8B%E5%8A%A8%E7%9F%AB%E6%AD%A3/","excerpt":"","text":"本文将带大家看看怎么用openCVjs在前端实现图片手动矫正。就像下面这样，左边是原图，右边是矫正后的图： 首先框出需要矫正的四边形区域： 得到4个顶点，从左上角开始，顺时针排列，分别是p0、p1、p2、p3。可以得到他们的准确坐标： 1234p0 = [241, 60]p1 = [763, 178]p2 = [690, 689]p3 = [188, 500] 矫正后的图，假设宽为width，高为height，那么矫正后的图4个顶点是： 1234p4 = [0, 0]p5 = [width, 0]p6 = [width, height]p7 = [0, height] 其中p0~p3与p4~p7对应，我们假设宽width为408，高height为380，可以通过cv.getPerspectiveTransform求出转换矩阵M： 12345const srcPoints = [241, 60, 763, 178, 690, 689, 188, 500]const dstPoints = [0, 0, 408, 0, 408, 380, 0, 380]const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, srcPoints);const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, dstPoints);const M = cv.getPerspectiveTransform(srcTri, dstTri) 求出转转矩阵后，就可以通过cv.warpPerspective进行透视矫正： 123const dsize = new cv.Size(408, 380);cv.warpPerspective(src, dst, M, dsize)cv.imshow(&#x27;canvasOutput&#x27;, dst) 这样就得到了处理结果。现在我们看看简单的demo代码。首先，初始化一个html： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;OpenCV.js手动矫正demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 id=&quot;status&quot;&gt;Loading the Opencv ...&lt;/h3&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; /&gt; &lt;div id=&quot;changeImage&quot;&gt;处理&lt;/div&gt; &lt;div class=&quot;wrap-image&quot;&gt; &lt;img id=&quot;imageUpload&quot; alt=&quot;No Image&quot; /&gt; &lt;canvas id=&quot;canvasOutput&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // TODO &lt;/script&gt; &lt;script async src=&quot;js/opencv.js&quot; onload=&quot;onOpenCvReady();&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 再在上面的TODO处加入我们的逻辑代码，主要是一些事件绑定。 12345678910111213const imgElement = document.getElementBy(&#x27;imageUpload&#x27;);const inputElement = document.getElementBy(&#x27;fileInput&#x27;);const changeImageElement = document.getElement(&#x27;changeImage&#x27;);inputElement.onchange = function () &#123; imgElement.src = URL.createObjectURL(eventarget.files[0]);&#125;changeImageElement.onclick = function () &#123; // 图片处理&#125;function onOpenCvReady() &#123; document.getElementById(&#x27;status&#x27;).remove();&#125; 最后在上面的图片处理处加入手动矫正相关代码，点击处理按钮时执行矫正。 1234567891011const src = cv.imread(&quot;imageUpload&quot;);const dst = new cv.Mat();const srcPoints = [241, 60, 763, 178, 690,188, 500]const dstPoints = [0, 0, 408, 0, 408, 38380]const srcTri = cv.matFromArray(4, 1, cv.CV_3srcPoints);const dstTri = cv.matFromArray(4, 1, cv.CV_3dstPoints);const M = cv.getPerspectiveTransform(srdstTri)const dsize = new cv.Size(408, 380);cv.warpPerspective(src, dst, M, dsize)cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 处理完不要忘记删除Mat哦 下面是原图，感兴趣的可以自己试试看。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"前端使用openCV处理图片的基础","slug":"前端使用openCV处理图片的基础","date":"2021-10-15T15:29:15.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/前端使用openCV处理图片的基础/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8openCV%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E7%9A%84%E5%9F%BA%E7%A1%80/","excerpt":"","text":"前言前文我们讲了openCV如何在前端应用。本文主要根据官方文档的Core Operations部分，带大家了解OpenCV图片处理时需要的一些基础知识，比如mat数据类型的操作，绘制形状等等。 获取图片属性1234567let src = cv.imread(&#x27;imageUpload&#x27;);console.log(&#x27;image width: &#x27; + src.cols + &#x27;\\n&#x27; + &#x27;image height: &#x27; + src.rows + &#x27;\\n&#x27; + &#x27;image size: &#x27; + src.size().width + &#x27;*&#x27; + src.size().height + &#x27;\\n&#x27; + &#x27;image depth: &#x27; + src.depth() + &#x27;\\n&#x27; + &#x27;image channels &#x27; + src.channels() + &#x27;\\n&#x27; + &#x27;image type: &#x27; + src.type() + &#x27;\\n&#x27;); 比如上面这张图的属性打印出来就是： 123456image width: 600image height: 473image size: 600*473image depth: 0image channels 4image type: 24 Mat构造Mat创建Mat实例时，可以传入size, type或者rows, cols, type，一般用默认构造方式： 1let mat = new cv.Mat(); 或者用数组来构建： 12// 比如: let mat = cv.matFromArray(2, 2, cv.CV_8UC1, [1, 2, 3, 4]);let mat = cv.matFromArray(rows, cols, type, array); 或者用imgData： 123let ctx = canvas.getContext(&quot;2d&quot;);let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);let mat = cv.matFromImageData(imgData); 另外，还有3个静态函数： 123456// 1. 创建一个全是0的Matlet mat = cv.Mat.zeros(rows, cols, type);// 2. 创建一个全是1的Matlet mat = cv.Mat.ones(rows, cols, type);// 3. 创建一个单位矩阵的Matlet mat = cv.Mat.eye(rows, cols, type); Mat实例一定记得要及时删除 复制Mat有2种复制方法： 1234// 1. Clonelet dst = src.clone();// 2. CopyTosrc.copyTo(dst, mask); 转换Mat类型src.convertTo(dst, rtype)rtype代表期望的输出矩阵类型，或者说是深度，因为通道的数量与输入相同;如果rtype为负，输出矩阵的类型将与输入矩阵的相同。 读写像素data首先，需要了解不同的Data属性在不同语言中的type之间的关系： Data属性 C++ Type JavaScript Typed Array Mat Type data uchar Uint8Array CV_8U data8S char Int8Array CV_8S data16U ushort Uint16Array CV_16U data16S short Int16Array CV_16S data32S int Int32Array CV_32S data32F float Float32Array CV_32F data64F double Float64Array CV_64F 通过data获取像素： 123456789let row = 3, col = 4;let src = cv.imread(&quot;canvasInput&quot;);if (src.isContinuous()) &#123; let index = row * src.cols * src.channels() + col * src.channels() let R = src.data[index]; let G = src.data[index + 1]; let B = src.data[index + 2]; let A = src.data[index + 3];&#125; data操作只对连续的Mat有效，使用前应该用isContinuous函数检查。 at Mat Type At 操作 CV_8U ucharAt CV_8S charAt CV_16U ushortAt CV_16S shortAt CV_32S intAt CV_32F floatAt CV_64F doubleAt 通过at获取像素： 1234567let row = 3, col = 4;let src = cv.imread(&quot;canvasInput&quot;);let colIndex = col * src.channels()let R = src.ucharAt(row, colIndex);let G = src.ucharAt(row, colIndex + 1);let B = src.ucharAt(row, colIndex + 2);let A = src.ucharAt(row, colIndex + 3); at操作只能读，不能写。 ptr Mat Type Ptr 操作 JavaScript Typed Array CV_8U ucharPtr Uint8Array CV_8S charPtr Int8Array CV_16U ushortPtr Uint16Array CV_16S shortPtr Int16Array CV_32S intPtr Int32Array CV_32F floatPtr Float32Array CV_64F doublePtr Float64Array mat.ucharPtr(k)获取mat的第k行，mat.ucharPtr(i, j)获取mat的第i行第j列。 1234567let row = 3, col = 4;let src = cv.imread(&quot;canvasInput&quot;);let pixel = src.ucharPtr(row, col);let R = pixel[0];let G = pixel[1];let B = pixel[2];let A = pixel[3]; 颜色通道操作有时我们需要单独操作图片的R&#x2F;G&#x2F;B通道，这时就需要对颜色通道进行分割，处理完毕后再合并。 123456789let src = cv.imread(&quot;canvasInput&quot;);let rgbaPlanes = new cv.MatVector();// 分割cv.split(src, rgbaPlanes);// 获取R通道let R = rgbaPlanes.get(0);// 合并cv.merge(rgbaPlanes, src);src.delete(); rgbaPlanes.delete(); R.delete(); 坐标点Point有2种方式创建一个点： 12let point = new cv.Point(x, y);let point = &#123;x: x, y: y&#125;; 像素点Scalar12let scalar = new cv.Scalar(R, G, B, Alpha);let scalar = [R, G, B, Alpha]; 尺寸Size12let size = new cv.Size(width, height);let size = &#123;width : width, height : height&#125;; 圆12let circle = new cv.Circle(center, radius);let circle = &#123;center : center, radius : radius&#125;; 方形12let rect = new cv.Rect(x, y, width, height);let rect = &#123;x : x, y : y, width : width, height : height&#125;; 带旋转角度的方形： 12let rotatedRect = new cv.RotatedRect(center, size, angle);let rotatedRect = &#123;center : center, size : size, angle : angle&#125;; 通过下面的方法获取方形的4个顶点： 12345let vertices = cv.RotatedRect.points(rotatedRect);let point1 = vertices[0];let point2 = vertices[1];let point3 = vertices[2];let point4 = vertices[3]; 通过下面的方法获取方形的边界： 1let boundingRect = cv.RotatedRect.boundingRect(rotatedRect);","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"前端使用openCV之图片处理","slug":"前端使用openCV之图片处理","date":"2021-10-12T15:07:08.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/前端使用openCV之图片处理/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8openCV%E4%B9%8B%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/","excerpt":"","text":"前言前文我们讲了openCV如何在前端应用，本文我们跟着官方文档的图片处理部分，看看能做些什么。 我们继续在上文的基础上编码，这里简单的回顾一下。 页面中有个上传图片的按钮： 1&lt;input type=&quot;file&quot; id=&quot;fileInput&quot;/&gt; 点击按钮上传图片，触发input的onchange事件： 12345let imgElement = document.getElementById(&#x27;imageUpload&#x27;);let inputElement = document.getElementById(&#x27;fileInput&#x27;);inputElement.onchange = function() &#123; imgElement.src = URL.createObjectURL(event.target.files[0]);&#125; 上传事件中我们设置页面中img标签的图片地址： 1&lt;img id=&quot;imageUpload&quot; alt=&quot;No Image&quot; /&gt; 由于我们给img绑定了onload事件，设置图片地址后就会触发： 123imgElement.onload = function() &#123; // 图片处理程序&#125;; 我们的图片处理程序放在onload中，所以上传图片后就自动处理，然后页面中有个canvas: 1&lt;canvas id=&quot;canvasOutput&quot;&gt;&lt;/canvas&gt; 我们通过imshow把处理结果显示到canvas中： 1cv.imshow(&#x27;canvasOutput&#x27;, dst); 这样我们修改onload中的图片处理程序，就可以在上传图片后看到自动处理后的图片，下面我们来看一些例子。 改变颜色转换图片的颜色通道，比如RGB↔Gray，RGB↔HSV等等cvtColorcv.cvtColor (src, dst, code, dstCn &#x3D; 0)改变图片的颜色通道。其中code参数是颜色转换码，在OpenCV中有150多种可以使用，可以在cv.ColorConversionCodes中查询，比如COLOR_BGR2BGRA、COLOR_BGR2HSV、COLOR_BGR2HLS、COLOR_BayerBG2BGR_EA等等。现在我们看看应用最广泛的RGB↔Gray： 12345let src = cv.imread(&#x27;canvasInput&#x27;);let dst = new cv.Mat();cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); inRangecv.inRange (src, lowerb, upperb, dst)检查颜色是否在范围内。 1234567let src = cv.imread(&#x27;canvasInput&#x27;);let dst = new cv.Mat();let low = new cv.Mat(src.rows, src.cols, src.type(), [0, 0, 0, 0]);let high = new cv.Mat(src.rows, src.cols, src.type(), [150, 160, 200, 255]);cv.inRange(src, low, high, dst);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); low.delete(); high.delete(); 几何变换对图片应用不同的几何变换，比如平移、旋转、仿射变换等等 缩放缩放其实就是改变图片大小，OpenCV中用cv.resize (src, dst, dsize, fx &#x3D; 0, fy &#x3D; 0, interpolation &#x3D; cv.INTER_LINEAR)实现缩放，图片大小可以手动填写任意值，或者是缩放系数。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let dsize = new cv.Size(300, 80);cv.resize(src, dst, dsize, 0INTER_AREA);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 这里我们通过直接设置图片宽高的方式，把600x473的图片，变成了300x80. 平移1cv.warpAffine (src, dst, M, dsize, flags = cv.INTER_LINEAR, borderMode = cv.BORDER_CONSTANT, borderValue = new cv.Scalar()) 1234567let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let M = cv.matFromArray(2, 3, cv.CV_64FC1, [1, 0, 50, 0, 1, 100]);let dsize = new cv.Size(src.cols, src.rows);cv.warpAffine(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 旋转和平移一样，也是warpAffine函数，只是M代表的矩阵不同，这里用cv.getRotationMatrix2D(center, angle, scale)计算出旋转矩阵，比如下面以图片中心为旋转点，旋转45°： 12345678let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let dsize = new cv.Size(src.cols, src.rows);let center = new cv.Point(src.cols / 2, src.rows / 2);let M = cv.getRotationMatrix2D(center, 45, 1);cv.warpAffine(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 仿射变换通过cv.getAffineTransform (src, dst)得到仿射变换的矩阵M，然后调用warpAffine函数。getAffineTransform需要输入图像中的3个点在输出图像中的对应点，比如下面的srcTri中的3个点[0, 0, 0, 1, 1, 0]对应dstTri中的[0.6, 0.2, 0.1, 1.3, 1.5, 0.3]。 123456789let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let srcTri = cv.matFromArray(3, 1, cv.CV_32FC2, [0, 0, 0, 1, 1, 0]);let dstTri = cv.matFromArray(3, 1, cv.CV_32FC2, [0.6, 0.2, 0.1, 1.3, 1.5, 0.3]);let M = cv.getAffineTransform(srcTri, dstTri);let dsize = new cv.Size(src.cols, src.rows);cv.warpAffine(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete(); 图像阈值化cv.threshold(src, dst, thresh, maxval, type)如果像素值大于阈值，它被赋一个值(可能是白色)，否则被赋另一个值(可能是黑色)。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);cv.threshold(dst, dst, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 图像模糊 自定义滤波 低通滤波模糊图片 卷积滤波和一维信号一样，图像也可以用各种低通滤波器(LPF)、高通滤波器(HPF)等进行滤波。LPF有助于去除噪声，模糊图像等。HPF有助于在图像中找到边缘。 OpenCV提供cv.filter2D(src, dst, ddepth, kernel[, anchor[, delta[, borderType]]])函数来对图片进行卷积核运算。关于卷积，可以看看之前写的《卷积在前端图像处理上的应用》，比如前文的模糊卷积核： 123const kernel = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9]; // 模糊卷积核 这里可以这么用： 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let M = cv.matFromArray(3, 3, cv.CV_64FC1, [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9]);cv.filter2D(src, dst, cv.CV_8U, M);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 下面看看OpenCV内置的4个模糊处理。 均值模糊上面例子中的模糊卷积核，OpenCV提供了cv.blur()函数直接调用。下面的两种写法效果一致。 1234567// 运用filter2Dlet M = cv.matFromArray(3, 3, cv.CV_64FC1, [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9]);cv.filter2D(src, dst, cv.CV_8U, M);// 运用blurlet ksize = new cv.Size(3, 3);cv.blur(src, dst, ksize); 高斯模糊cv.GaussianBlur(src, dst, ksize, sigmaX[, sigmaY[, borderType]]) 不同于均值模糊直接取周围像素的平均值，高斯模糊取像素周围的高斯加权平均值。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let ksize = new cv.Size(3, 3);cv.GaussianBlur(src, dst, ksize, 0);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 中值模糊cv.medianBlur (src, dst, ksize)中值模糊取核内所有像素的中值，中心元素被替换为这个中值。这对图像中的椒盐噪声非常有效。上面的过滤器，中心元素是一个新计算的值，它可能是图像中的一个像素值，也可能是一个新值。但在中值模糊中，中心元素总是被图像中的某个像素值所替代。它有效地降低了噪声。 12345let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();cv.medianBlur(src, dst, 5);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 双边滤波cv.bilateralFilter(src, dst, d, sigmaColor, sigmaSpace[, borderType])双边滤波在保持边缘锐利的同时对去除噪音非常有效。但与其他过滤器相比，该操作较慢。比如高斯滤波器取像素周围的一个邻域并找到它的高斯加权平均值，在滤波时考虑附近的像素，但不考虑像素是否具有几乎相同的强度，不考虑像素是否是边缘像素。所以边缘也会模糊，这不是我们想要的。 双边滤波器实际上是2个高斯滤波器组成，一个对周围像素进行模糊，一个确保只有强度差别不大的像素会被模糊处理，所以能在模糊的同时保留边缘。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();cv.cvtColor(src, src, cv.COLOR_RGBA2RGB, 0);cv.bilateralFilter(src, dst, 9, 75, 75);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 形态变换形态变换是对图片形状的简单运算。它通常在二进制图像上执行。它需要两个输入，一个是我们的原始图像，另一个是卷积核。两个基本的形态学运算是侵蚀和膨胀。然后它的进阶形式有打开，关闭，梯度等。 侵蚀cv.erode(src, dst, kernel[, anchor[, iterations[, borderType[, borderValue]]]])卷积运算时，核内所有像素都为1时运算结果为1，否则为0。所以靠近边缘的像素都被丢弃，图像尺寸会变小。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let M = cv.Mat.ones(5, 5, cv.CV_8U);cv.erode(src, dst, M);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 膨胀cv.dilate(src, dst, kernel[, anchor[, iterations[, borderType[, borderValue]]]])与侵蚀相反，卷积运算时，核内有一个像素为1时，结果就为1，否则为0。所以图片尺寸会变大。通常，在消除噪音时，侵蚀之后是膨胀，因为侵蚀消除了白噪音，但它也缩小了我们的目标，所以需要再放大。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let M = cv.Mat.ones(5, 5, cv.CV_8U);cv.dilate(src, dst, M);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 打开1cv.morphologyEx(src, dst, op, kernel[, anchor[, iterations[, borderType[, borderValue]]]]) 打开只是侵蚀之后是再膨胀的另一个说法，常在去除噪音时使用。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let M = cv.Mat.ones(5, 5, cv.CV_8U);cv.morphologyEx(src, dst, cv.MORPH_OPEN, M);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 关闭关闭和打开相反，是膨胀之后再侵蚀，对去除图片中的小黑点比较有用。 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let M = cv.Mat.ones(5, 5, cv.CV_8U);cv.morphologyEx(src, dst, cv.MORPH_CLOSE, M);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 梯度与侵蚀和膨胀不同，它的处理结果看起来是形状的边缘。 1234567let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();let M = cv.Mat.ones(5, 5, cv.CV_8U);cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, M);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); M.delete(); 图像梯度OpenCV提供3种图像梯度过滤器：Sobel、Scharr 和 Laplacian。 12345678910let src = cv.imread(&#x27;imageUpload&#x27;);let dstx = new cv.Mat();let dsty = new cv.Mat();cv.cvtColor(src, src, cv.COLOR_RGB2GRAY, 0);cv.Sobel(src, dstx, cv.CV_8U, 1, 0); // 下图一左// cv.Sobel(src, dsty, cv.CV_8U, 0, 1); // 下图一右// cv.Scharr(src, dstx, cv.CV_8U, 1, 0); // 下图二左// cv.Scharr(src, dsty, cv.CV_8U, 0, 1); // 下图二右cv.imshow(&#x27;canvasOutput&#x27;, dstx);src.delete(); dstx.delete(); dsty.delete(); 下面4张图分别是Sobel和Scharr算子取横向和纵向： Laplacian使用的卷积核是： 123const kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0]; 先灰度，再Laplacian: 12cv.cvtColor(src, src, cv.COLOR_RGB2GRAY, 0);cv.Laplacian(src, dst, cv.CV_8U); 注意输出的cv.CV_8U数据类型会导致检测结果不准确，需要用其他格式，比如 cv.CV_16S， cv.CV_64F等等，然后取绝对值再输出。具体的可以参考官网。 Canny边缘检测Canny边缘检测是一种流行的边缘检测算法，由John F. Canny在1986年开发。算法的实现及原理这里就不讲了，我们可以直接调用cv.Canny函数： 123456let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();cv.cvtColor(src, src, cv.COLOR_RGB2GRAY, 0);cv.Canny(src, dst, 50, 100);cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 图像金字塔通常，我们使用固定大小的图像。但有时，我们需要使用不同分辨率的图像。例如，当我们在一幅图像中搜索某物时，比如人脸，我们不确定人脸在图像中的大小。这时我们需要创建一组具有不同分辨率的图像，并在所有图像中搜索对象。这些不同分辨率的图像集合被称为图像金字塔(因为当它们被保存在一个堆栈中，高分辨率高的在底部，分辨率低的在顶部，它看起来像一个金字塔)。 降低分辨率12345let src = cv.imread(&#x27;imageUpload&#x27;);let dst = new cv.Mat();cv.pyrDown(src, dst, new cv.Size(0, 0));cv.imshow(&#x27;canvasOutput&#x27;, dst);src.delete(); dst.delete(); 提高分辨率1cv.pyrUp(src, dst, new cv.Size(0, 0)); 傅里叶变换傅里叶变换常用于图片的频域分析。代码较多，这里就不详细分析了。 总结上面列了OpenCV的一些基础的图像处理接口，比如几何变换、阈值化、形态变换等等，在实际应用中，通过这些接口，可以实现图片频域分析及处理、图像分割、图片匹配、图片轮廓或边缘检测等等。比如对图片频域加盲水印会用到傅里叶变换。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"卷积在前端图像处理上的应用","slug":"卷积在前端图像处理上的应用","date":"2021-09-29T14:49:04.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/卷积在前端图像处理上的应用/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%8D%B7%E7%A7%AF%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"前言前文我们了解了前端图像处理时对矩阵的应用，通过仿射矩阵对canvas做变换处理。现在我们深入一下，通过矩阵，进行卷积运算，对canvas进行更高级的处理，比如边缘检测、锐化、模糊等等。首先我们先了解一下二维卷积层的工作原理。 互相关运算大学毕业多年，大部分同学对卷积的了解就剩“卷积”2个字了。比如课本中对连续卷积的定义公式是： 对离散卷积的定义是： 都忘了对吧？没关系，我们接着往下看。 在图像处理中，我们用到的一般是互相关运算。下面我们看看《动手学深度学习》中的例子。 第一步：两个二维矩阵做某种特殊的乘法，输出第一个元素：0×0+1×1+3×2+4×3&#x3D;19 第二步：向右移动输入矩阵的深色部分，得到第二个输出元素。同样，计算的过程也是输入矩阵的深色部分与核一一相乘。 输出中的各个元素是按照下面的方法算出： 12340 × 0 + 1 × 1 + 3 × 2 + 4 × 3 = 191 × 0 + 2 × 1 + 4 × 2 + 5 × 3 = 253 × 0 + 4 × 1 + 6 × 2 + 7 × 3 = 374 × 0 + 5 × 1 + 7 × 2 + 8 × 3 = 43 用动图演示，输入矩阵和核矩阵之间的卷积操作如下： 这种输入矩阵与核矩阵之间的相乘被称作为互相关（Cross-Correlation）运算。 下面我们看看互相关运算的程序实现。 1234567891011121314151617181920212223// 卷积计算函数function convolutionMatrix(output, input, kernel) &#123; let w = input.width, h = input.height; let iD = input.data, oD = output.data; for (let y = 1; y &lt; h - 1; y += 1) &#123; for (let x = 1; x &lt; w - 1; x += 1) &#123; for (let c = 0; c &lt; 3; c += 1) &#123; let i = (y * w + x) * 4 + c; oD[i] = kernel[0] * iD[i - w * 4 - 4] + kernel[1] * iD[i - w * 4] + kernel[2] * iD[i - w * 4 + 4] + kernel[3] * iD[i - 4] + kernel[4] * iD[i] + kernel[5] * iD[i + 4] + kernel[6] * iD[i + w * 4 - 4] + kernel[7] * iD[i + w * 4] + kernel[8] * iD[i + w * 4 + 4]; &#125; oD[(y * w + x) * 4 + 3] = 255; &#125; &#125; return output;&#125; 这里的output和input都是图片的imageData数据，从左到右，从上到下，遍历图片，把像素点存在data数组里，每个像素点由r、g、b、a一共4个值组成，canvas像素操作这里就不赘述了，不清楚的可以去看之前写的《前端如何在像素级别操纵图片》。 kernel是3x3的核矩阵。 所以我们计算oD（输出数据）中某一点的值，由上面的动图演示可以直观的看到，还需要这个点周围的8个点的数据。而一个点又由r、g、b、a这4个参数组成，所以我们需要对不同的数据通道分别进行卷积运算，这里不需要处理透明度a的值，直接赋值为255。所以上面的程序简单说就是，2个嵌套的for循环来遍历像素点（注意遍历时从1开始而不是0）: 12345for (let y = 1; y &lt; h - 1; y += 1) &#123; for (let x = 1; x &lt; w - 1; x += 1) &#123; &#125;&#125; 遍历到某个点时，通过c的遍历分别对r、g、b通道进行卷积求值，c为0时，操作的是r通道，1时是g，2时是b。 这个点的r&#x2F;g&#x2F;b&#x2F;a值在imageData.data数组中的下标是(y * w + x) * 4 + c。其中y是该点在图片中的行，行乘w（图片宽）得到该点所在行上方点的数量，再加x（该点在图片中的列），就能得到该点在所有点中的排位，由于每个点有4个值，所以还要乘4，那么从(y * w + x) * 4开始的4个值就是该点的rgba（(y * w + x) * 4 + c中c分别取0，1，2，3）。对于下标i的值，其左侧点对应的值是i - 4，右侧是i + 4。上方的点需要减一行，一行的点对应的值有w * 4个,所以正上方的点对应的值是i - w * 4，同理正下方是i + w * 4，对这两个点减4加4，就得到它们左右两点。位置如下图： 然后对他们做卷积互相关运算得到oD[i]。 123456789oD[i] = kernel[0] * iD[i - w * 4 - 4] + kernel[1] * iD[i - w * 4] + kernel[2] * iD[i - w * 4 + 4] + kernel[3] * iD[i - 4] + kernel[4] * iD[i] + kernel[5] * iD[i + 4] + kernel[6] * iD[i + w * 4 - 4] + kernel[7] * iD[i + w * 4] + kernel[8] * iD[i + w * 4 + 4]; 这样我们就对点通过核矩阵做了某个处理，从而处理了整张图片。下面我们怎么调用这个函数。在前面写过的《前端基础滤镜》一文中，曾经封装过一个CanvasImage类，这里我们可以增加一个convolution方法： 12345678910111213141516class CanvasImage &#123; constructor(img, context) &#123; this.image = img; this.context = context; &#125; getData() &#123; return this.context.getImageData(0, 0, this.image.width, this.image.height); &#125; setData(data) &#123; this.context.putImageData(data, 0, 0); &#125; convolution() &#123; // TODO 后文再完善 &#125;&#125; convolution方法中，我们调用卷积计算函数convolutionMatrix： 12345convolution(kernel) &#123; const imageData = this.getData() const outData = convolutionMatrix(this.context.createImageData(imageData), imageData, kernel) this.setData(outData)&#125; 然后我们调用convolution，需要一个核矩阵，比如一个锐化卷积核： 123const kernel = [-1, -1, -1, -1, 9, -1, -1, -1, -1]; // 锐化卷积核 接着我们创建一个CanvasImage的实例filter 1filter = new CanvasImage(img, context) 然后我们就可以调用filter的convolution方法： 1filter.convolution(kernel) 就可以看到图片被锐化处理了。（左侧是原图） 填充与步幅现在我们知道，对图片数据（输入矩阵）进行卷积时，一般是使用一个卷积核矩阵进行互相关运算。比如图一和图二中，我们使用高和宽为3的输入与高和宽为2的卷积核得到高和宽为2的输出。一般来说，假设输入形状是nh x nw，卷积核形状是kh x kw，那么输出形状将是(nh - kh + 1)*(nw - kw + 1)。所以输出形状由输入形状和卷积核形状决定。接下来我们看看卷积层的两个超参数：填充（Padding）和步幅（Strides）。 填充 PaddingPadding是指在输入高和宽的两侧填充元素（通常是0）。 一般来说，在上下一共填充ph行，在左右共填充pw列，那么输出形状就是(nh - kh + 1 + ph) * (nw - kw + 1 + pw),即输出宽高分别增加ph和pw。 通常我们用的卷积核宽高都是奇数，比如1、3、5、7，为了使输入和输出的宽高相同，一般会设置ph &#x3D; kh - 1和pw &#x3D; kw - 1，这样两端填充的个数就相等，分别是 ph &#x2F; 2和pw &#x2F; 2。 比如一个尺寸6 x 6的数据矩阵，经过padding后，尺寸变为8 * 8，卷积运算后输出尺寸为6 x 6，保证了图片尺寸不变化。 步幅 Stride上面动图演示的卷积例子中，卷积核矩阵从输入矩阵的左上方开始，按从左往右、从上往下的顺序，依次在输入矩阵上滑动。我们将每次滑动的行数和列数称为步幅（Stride）。 目前为止，我们看到的例子，在高和宽两个方向上步幅均为1。下图是在纵向上步幅为3、在横向上步幅为2的二维互相关运算： 可以看到，在输出第2个元素时，卷积窗口向右滑动了2列，计算出结果是0×0 + 0×1 + 1×2 + 2×3 &#x3D; 8。在输出第3个元素时，卷积窗口向下滑动了3行，计算出结果是0×0 + 6×1 + 0×2 + 0×3 &#x3D; 6。 一般来说，当高上的步幅为sh，宽上的步幅为sw时，输出形状为[(nh - kh + ph + sh) &#x2F; sh] * [(nw - kw + pw + sw) &#x2F; sw]。比如，如果让sh和sw都为2，那么输出矩阵的宽高会只有输入矩阵的一半。 卷积核上面介绍了卷积互相关运算及填充和步幅相关知识，下面我们来看看卷积核。经过多年的研究，人们已经能够设计出不同的核矩阵，对图片进行转换，以达到不同的效果。不过，在深度学习出现之前，卷积核是人工设计的，需要消耗大量的时间和精力，然而深度学习出现之后，我们为卷积核初始化一些随机值，通过机器学习训练就可以得到卷积核。 卷积核特性1、大小一般是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。2、卷积核上的每一位数称为权值，它们决定了这个像素的分量有多重。3、它们的总和加起来如果等于1，计算结果不会改变图像的灰度强度。4、如果大于1，会增加灰度强度，计算结果使得图像变亮。5、如果小于1，会减少灰度强度，计算结果使得图像变暗。6、如果和为0，计算结果图像不会变黑，但也会非常暗。 接下来我们看一些常见的卷积核。 边缘检测比如常用的高斯-拉普拉斯算子： 12345678// 可侦测水平和垂直边缘const kernel1 = [0, -1, 0, -1, 5, -1, 0, -1, 0];// kernel1的基础上，还可侦测对角线的边缘，即斜的边缘const kernel2 = [-1, -1, -1, -1, 8, -1, -1, -1, -1]; 图片的边缘是图像的最基本特征，所谓边缘是指其周围像素灰度有阶跃变化或屋顶变化的那些像素的集合。边缘的种类可以分为两种：一种称为阶跃性边缘，它两边的像素的灰度值有着显著的不同；另一种称为屋顶状边缘，它位于灰度值从增加到减少到变化转折点。 我们能感受到物体的边缘，是因为边缘有明显的色差。比如输入图像的部分色值为10，部分色值为50，那么10和50之间就存在色差，边缘就在这个地方。经过卷积计算之后，我们可以看到色值相同的部分都变成了0，表现为黑色，只有边缘的色值计算结果大于0（色值最小是0，负数色值也是黑色），即色值为120的边缘就凸显出来了。 除了高斯-拉普拉斯算子，还有Roberts、Sobel、Prewit、Kirsch等边缘算子。 但是高斯-拉普拉斯算子只需要一个算子，而其余的需要多个算子，然后取最大值，计算较为复杂，高斯-拉普拉斯算子对噪音敏感，可以先做模糊处理，即blur + Laplacian。 此外还有著名的Canny边缘检测算法，这里就不细说了。 锐化锐化也是一种针对边缘处理（增强）的效果，简单的锐化处理可以把边缘检测卷积核中间的8改为9。 123const kernel = [-1, -1, -1, -1, 9, -1, -1, -1, -1]; // 锐化卷积核 或者，只让中心点与上下左右4个点过度的更加粗糙： 123const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0]; 但是这些锐化效果都不是很好，会使噪点大量增多。 模糊123const kernel = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9]; // 模糊卷积核 值全为1&#x2F;9的矩阵，意思是把周边元素和中心元素做了一个平均数，从而使点间过渡更加光滑，也就实现了模糊。这也称为高斯平滑滤波。 浮雕123const kernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2]; // 浮雕卷积核 参考 二维卷积层入门：卷积运算、填充与步幅、输入输出通道 前端图像处理之滤镜","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"canvas变换矩阵","slug":"canvas变换矩阵","date":"2021-09-27T14:37:03.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/canvas变换矩阵/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/canvas%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/","excerpt":"","text":"前言在计算机图形学的各种应用中都能找到矩阵的身影。它广泛应用于计算机视觉过滤器、图像处理（比如边缘检测）、锐化以及模糊变换。随着你不断地深入到更加高级的计算图形编程中，你会发现更多有关矩阵的应用。本文主要写如何在canvas中进行变换（平移、缩放、倾斜），再延伸到矩阵的应用。 状态的保存和恢复canvas中有两个绘制复杂图形时必不可少的方法：save()和restore()。save()保存画布所有状态。调用后，将当前画布状态存到栈中。restore()调用时将上一次save的状态从栈中取出并应用。在做变形之前先保存状态是一个良好的习惯，做完变形再restore恢复即可。 当前画布状态包括：1、当前应用的变形（即移动，旋转和缩放）2、下列属性：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled3、当前的裁切路径（clipping path） 如果对save和restore应用还不够清楚，接下来一起看看MDN上的例子： 1234567891011121314151617181920function draw() &#123; var ctx = document.getElementById(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;); ctx.fillRect(0, 0, 150, 150); ctx.save(); ctx.fillStyle = &#x27;#09F&#x27;; ctx.fillRect(15, 15, 120, 120); ctx.save(); ctx.fillStyle = &#x27;#FFF&#x27;; ctx.globalAlpha = 0.5; ctx.fillRect(30, 30, 90, 90); ctx.restore(); ctx.fillRect(45, 45, 60, 60); ctx.restore(); ctx.fillRect(60, 60, 30, 30);&#125; 代码中共绘制了5次方形，每次fillRect之后对应下面的5张图： translatetranslate(x, y)用来移动 canvas 和它的原点到一个不同的位置。 1234// ctx.fillRect(60,60,30,30);// 可以改成下面的写法ctx.translate(60, 60);ctx.fillRect(0, 0, 30, 30); rotaterotate(angle)，顺时针方向，以原点为中心旋转把canvas旋转angle弧度。（注意旋转中心是原点，单位是弧度，方向是顺时针） 弧度与角度2PI 弧度 &#x3D; 360 度 12345678// degrees 角度// radians 弧度function degreesToRadians (deg) &#123; return deg * Math.PI / 180&#125;function radiansToDegrees (rad) &#123; return rad * 180 / Math.PI&#125; scalescale(x, y)缩放画布的水平和垂直的单位。x&#x2F;y可以是负数，负数时以x&#x2F;y轴镜像翻转。 默认情况下，canvas 的 1 个单位为 1 个像素。如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。scale(1,-1)就以y轴作为对称轴镜像翻转。canvas画布左上角是原点，如果translate(0, canvas.height)将原点沿x轴移到画布底部，再scale(1, -1)将画布以y轴翻转，就可以得到笛卡尔坐标系（左下角为原点）。 transformtransform(a, b, c, d, e, f)对当前画布应用该矩阵，其中： a: 水平方向的缩放scaleX b: 竖直方向的倾斜偏移skewY c: 水平方向的倾斜偏移skewX d: 竖直方向的缩放scaleY e: 水平方向的移动translateX f: 竖直方向的移动translateY setTransform(a, b, c, d, e, f)取消当前变形，然后设置为指定的变形。resetTransform()重置当前变形为单位矩阵，即取消当前变形。等同于setTransform(1, 0, 0, 1, 0, 0)，即scale都是1，无旋转，无平移。 补充完上面这些基础，下面我们来看看矩阵数学的应用。 矩阵矩阵被大量应用于 3D 系统中，以实现旋转、缩放以及平移 3D 坐标的功能。它也常用于各种 2D 图形的变换。 首先我们复习下线代中学到的矩阵的基本算法。 矩阵加&#x2F;减法就是相同位置的数字相加&#x2F;减：矩阵乘以矩阵：结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和: 矩阵的加减可以用于平移。比如一个点(x, y, z),看作是1x3的矩阵(x y z)，假如dx、dy、dz 分别为 x、y、z 轴上的移动距离，距离也看作一个1x3的矩阵(dx dy dz)。那么我们将这两个矩阵相加，就可以得到平移后的点。 矩阵乘法通常用于缩放和旋转。比如，(w h d)分别对应一个物体现在3条轴上的值（宽、高、深）。应用下面的缩放矩阵（sx、sy、sz 分别为对应轴上的缩放比例）：就需要用乘法：如果要把点(x, y, z)旋转，我们需要一个旋转矩阵，通过旋转矩阵，在3条轴中任意一条轴上旋转。比如围绕x轴的旋转矩阵：这里的 cos 与 sin 代表要旋转的角度（以弧度为单位）的余弦和正弦值。 和点(x, y, z)相乘： 所以点(x, y, z)以x轴旋转后的点是(x, y * cos - z * sin, y * sin + z * cos)。假设绕x轴旋转45°，45°转成弧度是π &#x2F; 4，所以用js表示就是： 123x = xy = y * Math.cos(Math.PI / 4) - z * Math.sin(Math.PI / 4)z = y * Math.sin(Math.PI / 4) + z * Math.cos(Math.PI / 4) 围绕 y 轴旋转的矩阵： 围绕 z 轴旋转的矩阵： 仿射变换canvas 的context变换使用下面这个 3x3 的变换矩阵，也叫做仿射变换： 为了能应用仿射变换，二维向量 (x, y) 需要改写为三维向量 (x, y, 1)。由于 (u, v, w) 并不会用到，他们会直接设为 (0, 0, 1)，并保持不变。可以通过调用ctx.setTransform(a, b, c, d, dx, dy)设置 canvas 上下文的变换矩阵，或者ctx.transform(a, b, c, d, dx, dy)累计变换效果（不取消当前变形）。 如果没有为 canvas 设置任何变换矩阵，那么 canvas 会认为我们使用了一个单位矩阵（identity matrix）或一个空矩阵，就是类似下面这样一个矩阵： 应用空矩阵，相当于ctx.setTransform(1, 0, 0, 1, 0, 0)。 仿射变换矩阵中的dx 和 dy 控制 canvas 上下文将要在 x 与 y 轴上平移的距离，而 a、b、c、d 则有点复杂，还可以将 a、b、c、d 联合起来设置成下面这个我们熟悉的旋转矩阵(上文的绕z轴旋转矩阵): 文章开头的例子中，最后我们绘制了一个小的黑色方形： 1ctx.fillRect(60, 60, 30, 30); 如果我们要以方形的中心点旋转45度，可以将上面的ctx.fillRect(60, 60, 30, 30)换成下面的写法： 1234var sin = Math.sin(Math.PI / 4);var cos = Math.cos(Math.PI / 4);ctx.transform(cos, sin, -sin, cos, 75, 75);ctx.fillRect(-15, -15, 30, 30); 这里的Math.PI &#x2F; 4改成直接调上面写过的角度与弧度的换算函数degreesToRadians(45)，会更好理解是旋转45°。 推导旋转公式下面我们以2D平面旋转为例，推导旋转公式（即canvas旋转矩阵的推导）。首先我们回顾下canvas旋转矩阵： 点(x, y)应用该矩阵： 结果是点(x, y)变成点(x * cos - y * sin, x * six + y * cos) 下面我们就一步步推导。 我们已知点(x, y)要围绕中心点(0, 0)旋转rotation角度。求旋转后的点的坐标(x1, y1)。 设点(x, y)到原点的距离是radius，与x轴的夹角是angle。那么： 12345x = radius * cos(angle)y = radius * sin(angle)x1 = radius * cos(angle + rotation)y1 = radius * sin(angle + rotation) 接下来运用cos(a + b)和sin(a + b)的展开公式把x1和y1展开： 12x1 = radius * cos(angle) * cos(rotation) - radius * sin(angle) * sin(rotation)y1 = radius * sin(angle) * cos(rotation) + radius * cos(angle) * sin(rotation) 再把x &#x3D; radius * cos(angle)和y &#x3D; radius * sin(angle)带入得： 12x1 = x * cos(rotation) - y * sin(rotation)y1 = y * cos(rotation) + x * sin(rotation) 可以看到(x1, y1)的值和运用旋转矩阵后的值一致。矩阵只是组织各种公式与方程的另一种方法而已，所以并没有什么不同。 参考 变形 Transformations HTML5 + JavaScript 动画基础 理解矩阵乘法","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"前端基础滤镜","slug":"前端基础滤镜","date":"2021-08-23T10:39:53.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/前端基础滤镜/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%BB%A4%E9%95%9C/","excerpt":"","text":"前言前文带大家看过3D LUT滤镜如何实现影片级别的滤镜效果，这种滤镜最为强大，可以实现任何滤镜效果。 通过photoshop导出处理文件，即可通过程序实现对应的滤镜效果，而且由于是颜色查找，即颜色A，通过LUT文件，直接映射成颜色B，所以处理过程只是像素点的颜色映射，不存在计算，速度非常快。 然后也带大家看过如何操纵图片的像素，通过canvas获取页面上图片的像素，然后对像素点直接进行计算，再输出新的颜色，就能得到处理后的图片。 现在，带大家看看第二种方式的滤镜，到底可以实现哪些效果。由于这种方式是对像素点进行运算，而这些算法有限，所以能实现的效果也是有限的。 初始化页面首先，我们初始化一个简单的页面，提供一个上传图片按钮，一个canvas显示图片，并用css控制下图片显示的大小，还有一个点击使用滤镜的按钮。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;基础滤镜&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; canvas &#123; width: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; name=&quot;选择图片&quot; /&gt; &lt;div class=&quot;wrap-image&quot;&gt; &lt;canvas id=&quot;imageUpload&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div onclick=&quot;useFilter()&quot;&gt;点击使用滤镜&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装图片处理应用滤镜，我们会重复使用getImageData、putImageData和遍历像素点的逻辑，这些我们都可以封装起来。 下面我们创建一个CanvasImage类： 12345678910111213141516class CanvasImage &#123; constructor(img, context) &#123; this.image = img; this.context = context; &#125; getData() &#123; return this.context.getImageData(0, 0, this.image.width, this.image.height); &#125; setData(data) &#123; this.context.putImageData(data, 0, 0); &#125; transform() &#123; // TODO 后文再完善 &#125;&#125; 然后我们在上传图片时创建一个CanvasImage的实例，接下来我们看看上传图片。 上传图片用户点击选择图片按钮后，选择了一张图片。我们通过new Image()创建一个img，并将src设置为用户选择的本地图片的临时地址，在图片加载完成后，给页面中的canvas设置宽高，然后drawImage把图片显示到canvas上，最后new CanvasImage(img, context)来创建一个CanvasImage的实例filter。 123456789101112131415let filterconst fileInput = document.getElementById(&#x27;fileInput&#x27;);fileInput.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; const imgElement = document.getElementById(&#x27;imageUpload&#x27;); const img = new Image(); img.src = URL.createObjectURL(e.target.files[0]); img.onload = function () &#123; imgElement.width = img.width imgElement.height = img.height const context = imgElement.getContext(&quot;2d&quot;); context.drawImage(img, 0, 0); filter = new CanvasImage(img, context); &#125;&#125;, false); 封装滤镜处理函数现在我们来完善上面空着的transform： 123456789101112transform(fn, factor) &#123; const imageData = this.getData() const &#123; data &#125; = imageData for (let i = 0; i &lt; data.length; i += 4) &#123; const [r, g, b, a] = fn.call(this, data[i], data[i + 1], data[i + 2], data[i + 3], factor, i); data[i] = r; data[i + 1] = g; data[i + 2] = b; data[i + 3] = a; &#125; this.setData(imageData)&#125; transform接受2个参数，fn是滤镜算法函数，这个函数输入像素相关数据，输出r，g，b，a。factor代表滤镜算法需要的控制因子。 这样我们就只需要关注滤镜算法函数fn怎么写，然后执行filter.transform(fn, factor)就可以对图片做处理，并把处理后的图片数据更新到页面。 接下来我们看看几个简单的滤镜算法。 滤镜算法灰度比如我们先实现一个灰度算法，取r、g、b的加权平均值： 1234function Greyscale(r, g, b) &#123; const avg = 0.3 * r + 0.59 * g + 0.11 * b; return [avg, avg, avg, 255];&#125; 然后在点击使用滤镜绑定的函数useFilter中可以这样写： 123function useFilter() &#123; filter.transform(Greyscale)&#125; 怀旧1234function Sepia(r, g, b) &#123; const avg = 0.3 * r + 0.59 * g + 0.11 * b; return [avg + 100, avg + 50, avg, 255];&#125; 负片123function invert(r, g, b) &#123; return [255 - r, 255 - g, 255 - b, 255];&#125; 噪点1234function noise(r, g, b, a, factor) &#123; var rand = (0.5 - Math.random()) * factor; return [r + rand, g + rand, b + rand, 255];&#125; 调用时需传入噪点控制因子，比如传45: 123function useFilter() &#123; filter.transform(noise, 45)&#125; 下图是原图、噪点传45和100的对比： 亮度123function brightness(r, g, b, a, factor) &#123; return [r + factor, g + factor, b + factor, 255];&#125; 调用时，控制因子factor是亮度。下图是原图、亮度传45和100的对比： 饱和度12345678function saturation(r, g, b, a, factor) &#123; // factor取值[-1， 1] const max = Math.max(r, g, b); r += max !== r ? (max - r) * (-factor) : 0; g += max !== g ? (max - g) * (-factor) : 0; b += max !== b ? (max - b) * (-factor) : 0; return [r, g, b, 255];&#125; 下图是饱和度传-0.5，原图，饱和度传0.5的对比： 对比度123456789function contrast(r, g, b, a, factor) &#123; // factor取值[-1， 1] const contrast = Math.floor(factor * 255); const contrastF = 259 * (contrast + 255) / (255 * (259 - contrast)); r = contrastF * (r - 128) + 128; g = contrastF * (g - 128) + 128; b = contrastF * (b - 128) + 128; return [r, g, b, 255];&#125; 下图是对比度传-0.2，原图，对比度传0.2的对比： 色温1234567function temperature(r, g, b, a, factor) &#123; // factor取值[-1， 1] const temperature = Math.round(factor * 255) r = Math.min(Math.max(r + temperature, 0), 255) b = Math.min(Math.max(b - temperature, 0), 255) return [r, g, b, 255];&#125; 下图是色温传-0.2，原图，色温传0.2的对比： 总结上面写了这些示例，现在轮到你发挥想象力了，只需要在滤镜函数中编写你的颜色处理程序： 1234function noise(r, g, b, a, factor) &#123; // 在这里发挥你的想象力 return [r, g, b, a];&#125; 比如，调换r、g、b的顺序，或者把b都变成255……然后实现别的滤镜效果，比如色调、模糊等等，而且这些基础滤镜效果还可以叠加，从而创建出更多的效果哦。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"尤雨溪带你实现一个mini vue","slug":"尤雨溪带你实现一个mini vue","date":"2021-08-20T10:36:34.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/尤雨溪带你实现一个mini vue/","permalink":"http://example.com/js/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAmini%20vue/","excerpt":"","text":"前言本篇文章主要是解析尤雨溪在codepen上实现的一段mini-vue(solution)代码。 前面的文章，我们学习了怎么把数据变成响应式，怎么用虚拟dom局部刷新页面，现在我们在这两者的基础上，看怎么实现一个mini vue。 代码解析先把所有的代码折叠起来看一下： 可以看到，在响应式、虚拟dom的实现上，和前文一模一样，只是在这两个功能上，增加了1个createApp函数，那么接下来我们主要看看createApp函数干了什么。 首先我们初始化了一个叫Component的常量，这个常量内部有data和render函数，data返回了{ count: 0 }，render返回一个虚拟dom，渲染这个虚拟dom就会向页面中添加一个div，div中显示count的值，并绑定了点击事件，点击div就让count自增1。（虚拟dom渲染不清楚的话，可以看看上文） 123456789101112131415161718const Component = &#123; data() &#123; return &#123; count: 0 &#125; &#125;, render() &#123; return h( &#x27;div&#x27;, &#123; onClick: () =&gt; &#123; this.count++ &#125; &#125;, String(this.count) ) &#125;&#125; 然后我们来看看createApp函数。 12345678910111213141516171819function createApp(Component, container) &#123; // implement this const state = reactive(Component.data()) let isMount = true let prevTree watchEffect(() =&gt; &#123; const tree = Component.render.call(state) if (isMount) &#123; mount(tree, container) isMount = false &#125; else &#123; patch(prevTree, tree) &#125; prevTree = tree &#125;)&#125;// calling this should actually mount the component.createApp(Component, document.getElementBy(&#x27;app&#x27;)) 进入函数后，首先将Component.data()即{ count: 0 }变成响应式后赋值给state，然后申明两个变量isMount和prevTree，然后调用watchEffect： 12345function watchEffect(effect) &#123; activeEffect = effect effect() activeEffect = null&#125; 那么就执行了effect函数，申明并初始化tree常量，Component.render.call(state)的意思是执行Component中的render函数，并把render函数内的this指向state。 初次createApp时，isMount是true，所以接下来就直接渲染tree，并将isMount变成false，后面count数据变化时，触发effect函数再次走到if (isMount)这个判断时，isMount值就都是false，从而patch(prevTree, tree)，用新的tree对前一个tree打补丁，即局部刷新页面。 每次渲染或局部刷新完页面，就把当前的tree赋值给prevTree。 现在一个mini vue就实现了，点击页面上的0，0就会变成1，每次点击页面上的数字，数字就自增1。（响应式和虚拟节点相关代码这里就不贴了，有需要去前文看，或者直接去codepen） 总结简单来说，之前实现的数据响应式，在使用时，只是在数据变化时把数据打印出来： 123watchEffect(() =&gt; &#123; console.log(state.count)&#125;) 现在只是把watchEffect的传参effect的功能改一下，从简单的打印，改成渲染或局部更新页面，并且运用虚拟dom提高页面性能。从而实现数据变化时，页面自动局部刷新，也就是数据驱动视图。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"尤雨溪带你实现虚拟节点","slug":"尤雨溪带你实现虚拟节点","date":"2021-08-20T10:33:36.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/尤雨溪带你实现虚拟节点/","permalink":"http://example.com/js/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9/","excerpt":"","text":"前言本篇文章主要是解析尤雨溪在codepen上实现的一段vdom代码。这段代码实现了一个简易的Virtual DOM。 Virtual DOM的作用是减少浏览器对页面的重绘，从而让用户体验更好，通过js把页面渲染相关的东西存起来，在数据更新的时候，不直接用新数据来重绘整个页面，而是先对比数据差异，在数据变化的地方局部渲染。接下来，我们就看看尤雨溪会怎么实现一个简易版本的Virtual DOM，从而让大家更好的理解Virtual DOM算法 代码解析核心代码就两个函数，mount和patch，mount的字面意思是安装、镶嵌，嵌入，这里我们可以理解成渲染，patch的字面意思是补丁，这里我们可以理解成用新数据对页面打补丁，即局部更新页面。 首先我们看看mount函数： 1234567891011121314151617181920212223242526272829303132333435function h(tag, props, children) &#123; return &#123; tag, props, children &#125;;&#125;function mount(vnode, container, anchor) &#123; const el = document.createElement(vnode.tag); vnode.el = el; // props if (vnode.props) &#123; for (const key in vnode.props) &#123; el.setAttribute(key, vnode.props[key]); &#125; &#125; if (vnode.children) &#123; if (typeof vnode.children === &quot;string&quot;) &#123; el.textContent = vnode.children; &#125; else &#123; vnode.children.forEach(child =&gt; &#123; mount(child, el); &#125;); &#125; &#125; if (anchor) &#123; container.insertBefore(el, anchor) &#125; else &#123; container.appendChild(el); &#125;&#125;const tree1 = h(&quot;div&quot;, &#123; class: &quot;red&quot; &#125;, [ h(&quot;span&quot;, null, &quot;hello&quot;), h(&quot;span&quot;, null, &quot;world&quot;)]);mount(tree1, document.querySelector(&quot;#app&quot;)); 上面这段代码，在页面中的#app元素中添加了tree1： mount函数接受3个参数：vnode虚拟节点，container容器，anchor锚。执行mount(tree1, document.querySelector(“#app”));，即渲染节点树tree1，tree1通过h函数包装后，返回的是一个对象，有tag, props, children3个属性。 在mount中，首先tree1的tag属性做处理，用createElement创建节点，然后把这个创建的节点el赋值给vnode的el属性。然后对tree1的props属性做处理，如果props存在，就遍历props的key，通过setAttribute把props设置到el上。然后对tree1的children属性做处理，如果children存在，就看看children的类型，是字符串的话，就把值赋值给el.textContent，否则就遍历children，对每个遍历到的值child执行mount(child, el)。所以对于children，最后都会走到类型是字符串那一步，从而更新到el的textContent中。最后对anchor做处理，anchor的字面意思是锚，所以这里用来控制要渲染的节点树的位置。如果anchor存在，就在已有的节点anchor前面插入el节点，否则就把el节点添加到container中。 简单来说，mount函数根据虚拟节点来操作HTML页面，实现页面的更新。有props时将props中的属性加到标签上；有children时，是字符串的children就直接把值写入父元素，否则就对children中的元素迭代mount函数；有anchor时就把创建的el加到anchor前面，否则就默认加到父元素container中。 接下来我们看看patch函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function patch(n1, n2) &#123; // Implement this // 1. check if n1 and n2 are of the same type if (n1.tag !== n2.tag) &#123; // 2. if not, replace const parent = n1.el.parentNode const anchor = n1.el.nextSibling parent.removeChild(n1.el) mount(n2, parent, anchor) return &#125; const el = n2.el = n1.el // 3. if yes // 3.1 diff props const oldProps = n1.props || &#123;&#125; const newProps = n2.props || &#123;&#125; for (const key in newProps) &#123; const newValue = newProps[key] const oldValue = oldProps[key] if (newValue !== oldValue) &#123; if (newValue != null) &#123; el.setAttribute(key, newValue) &#125; else &#123; el.removeAttribute(key) &#125; &#125; &#125; for (const key in oldProps) &#123; if (!(key in newProps)) &#123; el.removeAttribute(key) &#125; &#125; // 3.2 diff children const oc = n1.children const nc = n2.children if (typeof nc === &#x27;string&#x27;) &#123; if (nc !== oc) &#123; el.textContent = nc &#125; &#125; else if (Array.isArray(nc)) &#123; if (Array.isArray(oc)) &#123; // array diff const commonLength = Math.min(oc.length, nc.length) for (let i = 0; i &lt; commonLength; i++) &#123; patch(oc[i], nc[i]) &#125; if (nc.length &gt; oc.length) &#123; nc.slice(oc.length).forEach(c =&gt; mount(c, el)) &#125; else if (oc.length &gt; nc.length) &#123; oc.slice(nc.length).forEach(c =&gt; &#123; el.removeChild(c.el) &#125;) &#125; &#125; else &#123; el.innerHTML = &#x27;&#x27; nc.forEach(c =&gt; mount(c, el)) &#125; &#125;&#125;const tree2 = h(&quot;div&quot;, &#123; class: &quot;green&quot; &#125;, [ h(&quot;span&quot;, null, &quot;this has &quot;), h(&quot;span&quot;, null, &quot;changed&quot;)]);patch(tree1, tree2); patch函数接受2个虚拟节点的参数。 首先判断老节点和新节点的标签是否相同，不同的话就直接用新节点替换掉老节点，也不用继续往下走了。比如老节点是div，新节点是span，那么这2个节点就完全不一样，就需要直接替换掉整个节点。替换也很简单，获取老节点的父元素parent和紧跟的节点anchor，然后删除老节点，然后把新节点渲染到anchor前面。 如果类型一样，比如都是div，那么接着找差异。先初始化el，老节点的el就是在mount渲染是赋值的tag，因为类型一样，所以我们将这个值也赋值给新节点。 接下来寻找props的差异，因为props是设置在el上的，所以我们由外而内逐步寻找差异。首先初始化新修props，取虚拟节点传入的props，没传就是{}。然后遍历新props中的key,通过key取新就props对于的value，一旦新旧value不同，就要做处理，新value存在就setAttribute，不存在就removeAttribute。比如这里遍历到的key是class，那么newValue就是green，而oldValue是red，所以将class设置成green，如果我们的tree2没有传{ class: “green” }，那newValue就不存在，那就会移除el上的class属性。 newProps遍历完了，这一步将newProps中不为空的属性设置到了el上。那有的属性oldProps有，而newProps没有呢？所以接下来就是遍历oldProps，如果oldProps中的key，在newProps中没有，就移除这个属性。 处理完props的差异，接下来处理children的差异。 首先把新旧节点的children分别赋值给oc和nc，代表oldChildren和newChildren。 如果nc是字符串，还跟oc不一样，就把nc直接赋值给el.textContent。否则，看nc是不是数组，是的话，就继续往下看。如果oc不是数组，那就说明nc和oc开始变得不一样了，这时直接将el中的内容清空，遍历nc数组，对nc中的内容逐个mount渲染到页面。oc也是数组的话，就需要继续寻找差异，这时我们先去oc和nc数组长度中较小的值，在这个长度内，逐个迭代patch函数来打补丁，最后迭代到nc是字符串，直接更新el.textContent。这样就处理完了oc和nc长度相同的部分，比如oc长3，nc长5，那么oc和nc的前3个就处理完了，接下来就处理剩下的2个。如果nc比oc长，我们只需要把剩下的2个渲染；如果nc比oc短，比如nc长1，oc长7，我们把nc和oc的第一个处理了，oc还剩后6个没处理，这时我们只需要截取oc的后6个，然后逐个删除。 到这里，我们的children也找出了差异，并把差异部分更新到页面，实现了局部更新。 总结虚拟节点的原理是不是很简单？我们不谈高大上的diff算法，Virtual DOM，局部更新等名词，就只是简单的实现一个通过js来局部刷新dom的功能，看起来就简单多了。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"尤雨溪教你写进阶版响应式","slug":"尤雨溪教你写进阶版响应式","date":"2021-08-19T10:25:11.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/尤雨溪教你写进阶版响应式/","permalink":"http://example.com/js/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E6%95%99%E4%BD%A0%E5%86%99%E8%BF%9B%E9%98%B6%E7%89%88%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"","text":"前言上一篇，我们解析了尤雨溪的初级版响应式代码，一定觉得初级版的响应式和我们平常用的vue3相差太远了，定义一个响应式对象，竟然还要手写get和set，而我们日常使用vue3来定义一个响应式对象只需要用ref或者reactive包起来。 那么，这一篇我们看看尤雨溪对初级版做了哪些升级。 封装reactive上一版中，定义响应式变量需手写get和set： 12345678910const state = &#123; get count() &#123; dep.depend() return actualCount &#125;, set count(newCount) &#123; actualCount = newCount dep.notify() &#125;&#125; 那么这一版首先就将这一步封装起来。 1234567891011121314151617181920212223function reactive(raw) &#123; // use Object.defineProperty // 1. iterate over the existing keys Object.keys(raw).forEach(key =&gt; &#123; // 2. for each key: create a corresponding dep const dep = new Dep() // 3. rewrite the property into getter/setter let realValue = raw[key] Object.defineProperty(raw, key, &#123; get() &#123; // 4. call dep methods inside getter/setter dep.depend() return realValue &#125;, set(newValue) &#123; realValue = newValue dep.notify() &#125; &#125;) &#125;) return raw&#125; 封装后，定义响应式变量只需要： 123const state = reactive(&#123; count: 0&#125;) 现在看来，是不是和vue3的写法一样了呢？ 接下来我们解读下这个优化。 首先翻译几个名词，为什么想翻译一下呢？因为我觉得尤雨溪写的代码命名非常好，一段代码读下来，就像看小说，即使不懂编程，也会大概知道是做什么。 reactive: 反应的raw: 未加工的、不成熟的 这两个变量名取的好呀，一眼看过去，函数reactive接受一个未加工的变量raw，然后返回了raw。咱们不看内容，就可以猜到reactive函数做了什么。 下面我们来看看reactive函数的内容（代码中的英文注释也是尤雨溪写的哦）。 传进来的raw对象，我们对key进行遍历，取得key对应的value值后，立即重写raw。 这里用到Object.defineProperty(obj, prop, descriptor)，这个方法会直接在一个对象obj上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。其中obj是要定义属性的对象，prop是要定义或修改的属性的key，descriptor是更新或定义的属性的描述。 所以这里重写时，给key值对应的value绑定了get和set函数，实现了上一版手动绑定的过程。 然后优化watchEffect，执行effect后立刻将activeEffect置空，防止不必要的订阅行为。 12345function watchEffect(effect) &#123; activeEffect = effect effect() activeEffect = null&#125; 再次进阶上面的优化比较小，只是简化了响应式变量的定义，接下来我们看看尤雨溪还能做什么优化。 首先，重写了Dep类。之前的Dep类比较简单，只有一个发布订阅模式。 123456789101112let activeEffectclass Dep &#123; subscribers = new Set() depend() &#123; if (activeEffect) &#123; this.subscribers.add(activeEffect) &#125; &#125; notify() &#123; this.subscribers.forEach(effect =&gt; effect()) &#125;&#125; 优化后： 12345678910111213141516171819202122232425262728293031let activeEffectclass Dep &#123; // imeplement this subscribers = new Set() constructor(value) &#123; this._value = value &#125; get value() &#123; this.depend() return this._value &#125; set value(value) &#123; this._value = value this.notify() &#125; depend() &#123; if (activeEffect) &#123; this.subscribers.add(activeEffect) &#125; &#125; notify() &#123; this.subscribers.forEach((effect) =&gt; &#123; effect() &#125;) &#125;&#125; 多了一个叫_value的私有变量，并且这个_value是响应式的。然后写了一个reactiveHandlers函数： 123456789101112131415// proxy versionconst reactiveHandlers = &#123; get(target, key) &#123; // how do we get the dep for this key? const value = getDep(target, key).value if (value &amp;&amp; typeof value === &#x27;object&#x27;) &#123; return reactive(value) &#125; else &#123; return value &#125; &#125;, set(target, key, value) &#123; getDep(target, key).value = value &#125;&#125; 接着是getDep函数： 1234567891011121314151617const targetToHashMap = new WeakMap()function getDep(target, key) &#123; let depMap = targetToHashMap.get(target) if (!depMap) &#123; depMap = new Map() targetToHashMap.set(target, depMap) &#125; let dep = depMap.get(key) if (!dep) &#123; dep = new Dep(target[key]) depMap.set(key, dep) &#125; return dep&#125; 最后就是用Proxy替代defineProperty重写reactive函数： 123function reactive(obj) &#123; return new Proxy(obj, reactiveHandlers)&#125; 这里补充下Proxy知识点： Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 语法是const p = new Proxy(target, handler)，target是要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。handler通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。示例： 123456789const handler = &#123; get: function(obj, prop) &#123; return prop in obj ? obj[prop] : 37; &#125;&#125;;const p = new Proxy(&#123; a: 1 &#125;, handler);console.log(p.a, p.b); // 1, 37 补充完Proxy知识点，我们再去看reactive。 我们用reactiveHandlers代理obj，读写obj时会进入reactiveHandlers，读的时候，通过getDep获取value值，如果value是object类型，就将value变成响应式，然后返回value；写的时候就把新值写到getDep获取的value上。 在getDep函数中，用到了Map和WeakMap。Map对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。WeakMap对象是一组键&#x2F;值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。 getDep中，首先去targetToHashMap中获取target，并赋值给depMap，没有获取到的话，就将target作为键，new Map()生成的depMap作为值，存到targetToHashMap中。 然后在depMap中取key的值，取不到的话，就new Dep(target[key])作为value和key一起，组成键值对，加到depMap中。最后返回dep。 使用还是一样： 123456789const state = reactive(&#123; count: 0&#125;)watchEffect(() =&gt; &#123; console.log(state.count)&#125;)state.count++ 在上面的代码中加上一些打印，使代码流程看得更加清楚： 可见getDep最后返回了一个Dep的实例。 还有什么不清楚的地方，自行断点调试。 结语所以，看到这里，你明白Proxy比起defineProperty，在实现vue的响应式时，有什么好处吗？ 后期后空，我们继续学习尤雨溪会怎么实现一个mini vue。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"尤雨溪教你写初级版响应式","slug":"尤雨溪教你写初级版响应式","date":"2021-08-18T10:11:40.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/尤雨溪教你写初级版响应式/","permalink":"http://example.com/js/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E6%95%99%E4%BD%A0%E5%86%99%E5%88%9D%E7%BA%A7%E7%89%88%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"","text":"本篇文章主要是解析尤雨溪在codepen上实现的一段Reactivity(Dep)代码，我们拆成2部分来看。 Part 1 实现响应式123456789101112131415161718let activeEffectclass Dep &#123; subscribers = new Set() depend() &#123; if (activeEffect) &#123; this.subscribers.add(activeEffect) &#125; &#125; notify() &#123; this.subscribers.forEach(effect =&gt; effect()) &#125;&#125;function watchEffect(effect) &#123; activeEffect = effect effect()&#125; 首先，定义了一个全局变量activeEffect。 然后写了一个Dep类,它有一个subscribers属性，depend和notify方法。subscribers是Set对象，Set对象允许存储任何类型的唯一值，无论是原始值或者是对象引用。 调用depend时，如果activeEffect存在，就将其加到subscribers中。调用notify时，遍历subscribers，执行遍历到的对象。 watchEffect函数接收一个effect参数，调用时将effect参数赋值给全局变量activeEffect，然后执行effect。 从上面的解析可以看到，代码实现的非常简陋，没有做类型判断，所以调用时注意传参的类型，watchEffect传参须是函数。 现在功能实现好了，怎么用呢？我们继续往下看。 Part 2 使用123456789101112131415161718192021// usage -----------------------const dep = new Dep()let actualCount = 0const state = &#123; get count() &#123; dep.depend() return actualCount &#125;, set count(newCount) &#123; actualCount = newCount dep.notify() &#125;&#125;watchEffect(() =&gt; &#123; console.log(state.count)&#125;) // 0state.count++ // 1 我们在适当的地方加上打印，那么程序的走向将更加明了： 上面的打印能看懂，就不用看下面这些了。 首先创建一个Dep对象类型的实例dep。 然后创建一个actualCount变量，并初始化，值为0。 然后创建一个state变量，state变量内部使用get和set语法。其中get语法和set语法分别将对象属性和一个函数绑定，在获取或设置该属性时，触发绑定的函数执行。上面创建并初始化state的代码意思是获取state.count时，执行get后面的函数，调用dep.depend，然后返回actualCount。设置state.count时，比如state.count &#x3D; 1，就执行set后面的函数，把1赋值给actualCount，然后调用dep.notify。 然后调用watchEffect函数，传入的参数是匿名函数() &#x3D;&gt; { console.log(state.count) }。watchEffect函数中，将传入的匿名函数赋值给全局变量activeEffect，然后执行这个匿名函数，于是打印state.count的值，而打印state.count的值，就需要获取state.count，就会触发get绑定的函数，于是执行dep.depend，由于此时的activeEffect值是匿名函数，所以将该匿名函数加到subscribers中，然后返回actualCount，所以得到的值是0，打印了0。 最后state.count++，使state.count自增1，这里先获取再自增，所以会触发get和set,由于全局变量activeEffect一直存在，所以get时会将activeEffect加入subscribers，而subscribers内的值不会重复，所以一直就只有一个值，那就是最开始加入的匿名函数。触发set时就执行和set绑定的函数，把1赋值给actualCount,然后执行dep.notify，notify中遍历subscribers，遍历到了之前加入的匿名函数，就执行了该匿名函数，于是打印了1。 总结首先我们翻译几个名词。 subscribers: 订阅者，用户 depend: 依赖 notify: 通知，公布 actual: 目前的 effect: 达到目的 从这些名词中，你是不是已经想到了一些javascript的设计模式？这里就不做讨论，感兴趣的话自行学习。 所以，上面的代码，翻译成白话，调用watchEffect来执行一个函数，这个函数获取了一个值count，于是把这个函数加到监听者列表，当count变化时，就会遍历监听者列表，于是遍历到刚刚加入的函数，于是执行了它，于是就获取到了当前的count值(actualCount)。 打个比方，同学小明，查询(watchEffect)了一下iphone12(state)的价格(count)，获取价格时系统就把小明加入订阅者，在价格变化时，通知小明同学最新的价格。 这一期的代码比较简陋，但是循序渐进，由简入深，下期我们继续讲解进阶版。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"前端如何在像素级别操纵图片","slug":"前端如何在像素级别操纵图片","date":"2021-08-12T10:04:47.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/前端如何在像素级别操纵图片/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E5%83%8F%E7%B4%A0%E7%BA%A7%E5%88%AB%E6%93%8D%E7%BA%B5%E5%9B%BE%E7%89%87/","excerpt":"","text":"前言前端也可以做图像处理？是的，可以。今天我们要介绍一种在前端处理图像的方式。 对于一般的图片，我们用专业的软件（比如PhotoShop、mark man等等）放大到最后，就会看到很多小格子，这一个一个的格子，就是像素，每个格子，即每个像素，都代表不同的颜色。而颜色都可以用rgba的形式表示，比如白色rgba(255, 255, 255, 1)，其中r代表红色，g代表绿色，b代表蓝色，a代表透明度，rgb代表的色值取值范围是[0, 255]，a代表的透明度取值范围是[0, 1]。 获取像素数据下面将带领大家一步一步来看怎么获取像素数据。 首先，我们创建一个页面。提供选择图片功能。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; canvas &#123; width: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; name=&quot;选择图片&quot;/&gt; &lt;div class=&quot;wrap-image&quot;&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 选择图片后，需要将图片显示到canvas中，我们在上面的script标签中加入下面的代码： 12345678910111213const fileInput = document.getElementById(&#x27;fileInput&#x27;);const canvas = document.getElementById(&#x27;canvas&#x27;);let contextfileInput.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; let img = new Image img.src = URL.createObjectURL(e.target.files[0]); img.onload = function()&#123; canvas.width = img.width canvas.height = img.height context = canvas.getContext(&quot;2d&quot;); context.drawImage(img, 0, 0); &#125;&#125;, false); 现在图片显示出来了，那要怎么获取图片像素数据呢？这里我们用到canvas的getImageData对象，他的用法如下： 1let myImageData = context.getImageData(left, top, width, height); 那么在本例中，我们在drawImage后可以接着getImageData，在img.onload中继续加入下面的代码： 1let imageData = context.getImageData(0, 0, img.width, img.height); 将imageData打印出来，可以看到： 现在，我们就获取到了图片的像素数据，它在imageData对象的data中。 读取像素点上面我们获取到了像素数据，但要怎么读取像素点呢？首先，我们来看看imageData对象的data对象是什么。 data是Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下。data包含width × height × 4 bytes数据，索引值从0到(width × height × 4) - 1。 例如，要读取图片中位于第50行，第200列的像素的蓝色部份，你会写以下代码： 1let b = imageData.data[((50 * (img.width * 4)) + (200 * 4)) + 2]; 那么根据行(row)、列(col)读取一个像素点的r&#x2F;g&#x2F;b&#x2F;a值的公式是： 12345let rIndex = row * (img.width * 4) + col * 4 // data中r值的索引let r = imageData.data[rIndex];let g = imageData.data[(rIndex + 1];let b = imageData.data[(rIndex + 2];let a = imageData.data[(rIndex + 3]; 操作像素上面我们获取到了图片数据，并读取到了像素点，能读取像素点，是不是也可以设置像素点呢？是的，下面我们将用canvas的putImageData来更新像素。这里我们将实现一个invert的效果，在获取imageData之后调用。 123456789function invert(imageData) &#123; const &#123; data &#125; = imageData for (let i = 0; i &lt; data.length; i += 4) &#123; data[i] = 255 - data[i]; // red data[i + 1] = 255 - data[i + 1]; // green data[i + 2] = 255 - data[i + 2]; // blue &#125; context.putImageData(imageData, 0, 0);&#125; 总结1、前端的canvas不仅可以显示图片，还可以获取到图片数据。2、数据中有图片的宽和高，还有像素信息，它对应着图片从左到右，再从上到下的像素点的rgba值。3、我们可以读到某行某列的像素数据，同样的我们也可以写。4、对不同的颜色通道及透明度做一系列运算，就可以得到颜色变化了的新图片。5、改变图片的颜色，主要应用在图片滤镜上，前端的基础滤镜，都是这个原理。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"前端如何通过LUT实现图片滤镜","slug":"前端如何通过LUT实现图片滤镜","date":"2021-08-09T10:00:25.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/前端如何通过LUT实现图片滤镜/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87LUT%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C/","excerpt":"","text":"前言说到图片滤镜，相信大家都不陌生，比如什么晨光效果、小清新效果，但大家都清楚滤镜效果是怎么实现的吗？比如下面两个好看的滤镜效果： 在前端，一般的图像处理库，都是基于算法来实现的，获取图片的像素，解析成R、G、B，然后对这3个颜色一通操作，比如R都变成255，G都减25…，或者复杂点，进行个卷积运算，比如fabric.js的滤镜效果。但是这些算法实现的滤镜效果不仅数量少，效果也不够丰富，只能实现些简单的效果，比如反色、灰阶、怀旧等等。如果设计师在PS中对图片进行了风格调色，比如相机校正、曲线、色彩分割、HSL调整等等项目，在程序上我们又要如何实现呢？本文要介绍的图片滤镜实现方式就可以解决上面的问题，只要是设计师实现的滤镜效果，我们都可以实现，而且，还有很多免费的滤镜效果可以使用，不一定需要设计师输出，滤镜效果好，并且处理速度快，这种方式就是3D LUT（look up table），即3D颜色查找表。 准备工作3D LUT资源文件设计师输出.CUBE文件，或者网上找免费资源。图片的风格处理大都比较复杂，对设计师来说，Photoshop中内建了几个影片的3D LUT电影调色档，也可以用外部导入的电影调色档，所以我们也可以直接用设计师们用到的外部电影调色档，资源的格式一般是.CUBE文件。 3D LUT资源文件格式处理如果前端直接使用.CUBE文件，不仅文件体积大，而且需要做文件解析，但是如果把.CUBE文件转成png，不仅体积小很多，也不用解析文本，直接解析png图片中的像素即可，这里推荐一个cube转png小工具，处理后的png一般是下面这样，宽高尺寸是512x512。 前端实现基于3D LUT的滤镜下面我们写一个简单的页面，实现用户上传原图和lut图，就可以得到处理后的图，并且可以点击下载处理后的图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;LUT&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; canvas &#123; width: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;#&quot; id=&quot;downloadButton&quot;&gt;下载&lt;/a&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; name=&quot;选择图片&quot;/&gt; &lt;input type=&quot;file&quot; id=&quot;lutInput&quot;/&gt; &lt;div class=&quot;wrap-image&quot;&gt; &lt;canvas id=&quot;imageUpload&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;lutUpload&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvasOutput&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var imgElement = document.getElementById(&#x27;imageUpload&#x27;); var lutElement = document.getElementById(&#x27;lutUpload&#x27;); var outputElement = document.getElementById(&#x27;canvasOutput&#x27;); var fileInput = document.getElementById(&#x27;fileInput&#x27;); var lutInput = document.getElementById(&#x27;lutInput&#x27;); fileInput.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; var img = new Image img.src = URL.createObjectURL(e.target.files[0]); img.onload = function()&#123; imgElement.width = img.width imgElement.height = img.height outputElement.width = img.width outputElement.height = img.height var context = imgElement.getContext(&quot;2d&quot;); context.drawImage(img, 0, 0); &#125; &#125;, false); lutInput.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; var img = new Image img.src = URL.createObjectURL(e.target.files[0]); img.onload = function()&#123; lutElement.width = img.width lutElement.height = img.height var context = lutElement.getContext(&quot;2d&quot;); context.drawImage(img, 0, 0); applyLUT(&quot;canvasOutput&quot;); &#125; &#125;, false); function applyLUT(resultID) &#123; var imageContext = imgElement.getContext(&quot;2d&quot;); var lutContext = lutElement.getContext(&quot;2d&quot;); var imageData = imageContext.getImageData(0, 0, imgElement.width, imgElement.height); var lutData = lutContext.getImageData(0, 0, lutElement.width, lutElement.height); for (var i = 0; i &lt; imageData.data.length; i += 4) &#123; var r = Math.floor(imageData.data[i] / 4); var g = Math.floor(imageData.data[i + 1] / 4); var b = Math.floor(imageData.data[i + 2] / 4); var lutX = (b % 8) * 64 + r; var lutY = Math.floor(b / 8) * 64 + g; var lutIndex = (lutY * lutElement.width + lutX) * 4; imageData.data[i] = lutData.data[lutIndex]; imageData.data[i + 1] = lutData.data[lutIndex + 1];; imageData.data[i + 2] = lutData.data[lutIndex + 2];; &#125; document.getElementById(resultID).getContext(&quot;2d&quot;).putImageData(imageData, 0, 0); &#125;; document.getElementById(&#x27;downloadButton&#x27;).onclick = function() &#123; this.href = document.getElementById(&#x27;canvasOutput&#x27;).toDataURL(); this.download = &#x27;image.png&#x27;; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果如下，左边是原图，中间是3D LUT文件，右边是处理后的图，效果不错吧！ 怎么样，效果是不是特别好？而且3D LUT不仅可以处理图片，还可以处理视频哦。 参考 A function that helps to apply LUT to image. Make sure to change the canvas IDs or to create temporary canvases Playing with JavaScript, photos and 3D LUTS (lookup tables) free-luts film-emulation-luts","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"前端如何使用openCV","slug":"前端如何使用openCV","date":"2021-08-05T09:55:43.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"图像处理/前端如何使用openCV/","permalink":"http://example.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8openCV/","excerpt":"","text":"简介OpenCV(Open Source Computer Vision Library)，是一个在图像处理和识别上很强大的库，最开始只有C++版本，但现在构建了各种不同语言的版本，比如Python和Java，甚至是JavaScript，本文要介绍的就是JavaScript版本的OpenCV.js。 如何获取OpenCV.js1、官方编译好的版本下载地址为：https://docs.opencv.org/_VERSION_/opencv.js其中 VERSION 换成你想要的版本。目前最新的為 4.5.3 版本，那么下载地址就是https://docs.opencv.org/4.5.3/opencv.js 2、参照官网自行构建OpenCV.js 实现一个简单的处理图片灰度处理效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;OpenCV.js&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrap-image &#123; display: flex; flex-direction: row; margin-top: 10px; &#125; .wrap-image img, .wrap-image canvas &#123; width: 300px; margin-right: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 id=&quot;status&quot;&gt;Loading the Opencv ...&lt;/h3&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot;/&gt; &lt;div class=&quot;wrap-image&quot;&gt; &lt;img id=&quot;imageUpload&quot; alt=&quot;No Image&quot; /&gt; &lt;canvas id=&quot;canvasOutput&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; let imgElement = document.getElementById(&#x27;imageUpload&#x27;); let inputElement = document.getElementById(&#x27;fileInput&#x27;); inputElement.onchange = function() &#123; imgElement.src = URL.createObjectURL(event.target.files[0]); &#125; imgElement.onload =function() &#123; let src = cv.imread(&#x27;imageUpload&#x27;); let dst = new cv.Mat(); cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0); cv.imshow(&#x27;canvasOutput&#x27;, dst); src.delete(); dst.delete(); &#125;; function onOpenCvReady() &#123; document.getElementById(&#x27;status&#x27;).remove(); &#125; &lt;/script&gt; &lt;script async src=&quot;js/opencv.js&quot; onload=&quot;onOpenCvReady();&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码解析：1、opencv.js很大，载入时需要加上async，并设定onload来检测是否载入完成。 1&lt;script async src=&quot;js/opencv.js&quot; onload=&quot;onOpenCvReady();&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 2、记得及时清理Mat对象，释放内存。 12src.delete();dst.delete(); 3、imread和imshow 必须传入 &lt;img /&gt; 或 &lt;canvas /&gt; 的 id 或是 DOM。 下载图片图片处理好了，用户想要下载，那就再html中加上下载链接： 1&lt;a href=&quot;#&quot; id=&quot;downloadButton&quot;&gt;下载&lt;/a&gt; 然后把下面的JavaScript加到之前的script标签中： 1234document.getElementById(&#x27;downloadButton&#x27;).onclick = function() &#123; this.href = document.getElementById(&#x27;canvasOutput&#x27;).toDataURL(); this.download = &#x27;image.png&#x27;;&#125;; 总结一旦你习惯了将图像作为Mat对象来操作，你就可以做更多的事情了,你可以在OpenCV的网站上找到更多的教程，包括人脸识别和模板匹配等等。 参考 如何在 Nodejs 或前端使用 OpenCV（免安裝）. 在本機使用 OpenCV 很簡單，在伺服器端使用 OpenCV… | by Up Chen | Medium An Introduction to Computer Vision in JavaScript using OpenCV.js | DigitalOcean","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"SVG Path实现tooltips","slug":"SVG Path实现tooltips","date":"2020-11-25T17:39:48.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"动效/SVG Path实现tooltips/","permalink":"http://example.com/%E5%8A%A8%E6%95%88/SVG%20Path%E5%AE%9E%E7%8E%B0tooltips/","excerpt":"","text":"在地图指针之后，让我们来尝试下更多有趣的SVG Path形状：一个tooltip。点击查看例子 tooltip形状的path路径是由5个变量决定的：width,height,pointer offset,corner radius和placement(left,top,right或bottom)。 简单来说，我们先来完成一个没有圆角的向上的tooltip，我们需要这么做：1、移动到点A：M aX,aY2、连线到点B：L bX,bY3、垂直连线到点C：H cX4、水平连线到点D：V dY5、垂直连线到点E：H eX6、水平连线到点F：V fY7、垂直连线到点G：H gX8、连线到点A：L aX,aY9、结束路径：z 点A的坐标是(0,0)，其他点的坐标由width,height和offset计算出来： 123456bx = -offsetby = -offset // cy,fy,gy也是一样的cx = -width / 2 // dx也一样dy = -offset - height // ey也一样ex = width / 2 // fx也一样gx = offset 整个路径实现出来就会是这样： 1234567891011121314function topTooltipPath(width, height, offset) &#123; const left = -width / 2 const right = width / 2 const top = -offset - height const bottom = -offset return `M 0,0 L $&#123;-offset&#125;,$&#123;bottom&#125; H $&#123;left&#125; V $&#123;top&#125; H $&#123;right&#125; V $&#123;bottom&#125; H $&#123;offset&#125; L 0,0 z`&#125; 上面的代码解释下就是：画笔移动到点M，再画直线到点B，再水平画直线到点C，再垂直画直线到点D，再水平画直线到点E，再垂直画直线到点F，再水平画直线到点G，再画直线到点M，并结束。 需要注意的是坐标系是左上角为原点，x轴正方向朝右，y轴正方向朝下。 实现圆角，我们有2个方案：弧(Arc)和二次贝塞尔曲线(Quadratic Bezier curve)。弧需要使用7个变量，但是二次贝塞尔曲线就要简单得多：它在当前路径上取得起点，另外2个点是顶点(vX,vY)和终点(tX,tY)。在SVG中，二次贝塞尔曲线的写法是Q vX,vY tX,tY。 拿圆角C来举例，设圆角半径是r,圆角的起点在B到C的水平直线上，，故起点坐标是(cX+r, cY),终点在出圆角去点D的垂直直线上，故终点坐标是(cX,cY-r)，顶点就是点C(cX,cY)，把上面例子中的直角变成圆角，我们只需要把H cX V dY换成H cX+r Q cX, cY cX, (cY - r) V dY，这样就得到了半径是r的圆角C，下面是优化后的代码： 123456789101112131415161718function topTooltipPath(width, height, offset, radius) &#123; const left = -width / 2 const right = width / 2 const top = -offset - height const bottom = -offset return `M 0,0 L $&#123;-offset&#125;,$&#123;bottom&#125; H $&#123;left + radius&#125; Q $&#123;left&#125;,$&#123;bottom&#125; $&#123;left&#125;,$&#123;bottom - radius&#125; V $&#123;top + radius&#125; Q $&#123;left&#125;,$&#123;top&#125; $&#123;left + radius&#125;,$&#123;top&#125; H $&#123;right - radius&#125; Q $&#123;right&#125;,$&#123;top&#125; $&#123;right&#125;,$&#123;top + radius&#125; V $&#123;bottom - radius&#125; Q $&#123;right&#125;,$&#123;bottom&#125; $&#123;right - radius&#125;,$&#123;bottom&#125; H $&#123;offset&#125; L 0,0 z`&#125; 获得圆角的向下的tooltip，我们只需要把路径中的Y坐标全部取反： 123456789101112131415161718function bottomTooltipPath(width, height, offset, radius) &#123; const left = -width / 2 const right = width / 2 const bottom = offset + height const top = offset return `M 0,0 L $&#123;-offset&#125;,$&#123;top&#125; H $&#123;left + radius&#125; Q $&#123;left&#125;,$&#123;top&#125; $&#123;left&#125;,$&#123;top + radius&#125; V $&#123;bottom - radius&#125; Q $&#123;left&#125;,$&#123;bottom&#125; $&#123;left + radius&#125;,$&#123;bottom&#125; H $&#123;right - radius&#125; Q $&#123;right&#125;,$&#123;bottom&#125; $&#123;right&#125;,$&#123;bottom - radius&#125; V $&#123;top + radius&#125; Q $&#123;right&#125;,$&#123;top&#125; $&#123;right - radius&#125;,$&#123;top&#125; H $&#123;offset&#125; L 0,0 z`&#125; 同样的可以得到朝左和朝右的tooltip: 123456789101112131415161718192021222324252627282930313233343536function leftTooltipPath(width, height, offset, radius) &#123; const left = -offset - width const right = -offset const top = -height / 2 const bottom = height / 2 return `M 0,0 L $&#123;right&#125;,$&#123;-offset&#125; V $&#123;top + radius&#125; Q $&#123;right&#125;,$&#123;top&#125; $&#123;right - radius&#125;,$&#123;top&#125; H $&#123;left + radius&#125; Q $&#123;left&#125;,$&#123;top&#125; $&#123;left&#125;,$&#123;top + radius&#125; V $&#123;bottom - radius&#125; Q $&#123;left&#125;,$&#123;bottom&#125; $&#123;left + radius&#125;,$&#123;bottom&#125; H $&#123;right - radius&#125; Q $&#123;right&#125;,$&#123;bottom&#125; $&#123;right&#125;,$&#123;bottom - radius&#125; V $&#123;offset&#125; L 0,0 z`&#125;function rightTooltipPath(width, height, offset, radius) &#123; const left = offset const right = offset + width const top = -height / 2 const bottom = height / 2 return `M 0,0 L $&#123;left&#125;,$&#123;-offset&#125; V $&#123;top + radius&#125; Q $&#123;left&#125;,$&#123;top&#125; $&#123;left + radius&#125;,$&#123;top&#125; H $&#123;right - radius&#125; Q $&#123;right&#125;,$&#123;top&#125; $&#123;right&#125;,$&#123;top + radius&#125; V $&#123;bottom - radius&#125; Q $&#123;right&#125;,$&#123;bottom&#125; $&#123;right - radius&#125;,$&#123;bottom&#125; H $&#123;left + radius&#125; Q $&#123;left&#125;,$&#123;bottom&#125; $&#123;left&#125;,$&#123;bottom - radius&#125; V $&#123;offset&#125; L 0,0 z`&#125; 参考 SVG Paths | MDN","categories":[{"name":"动效","slug":"动效","permalink":"http://example.com/categories/%E5%8A%A8%E6%95%88/"}],"tags":[]},{"title":"lottie-web应用优化之Base64","slug":"lottie-web应用优化之Base64","date":"2019-04-28T17:29:44.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"动效/lottie-web应用优化之Base64/","permalink":"http://example.com/%E5%8A%A8%E6%95%88/lottie-web%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96%E4%B9%8BBase64/","excerpt":"","text":"前文的优化中，主要把设计输出的多张图片合并成1张雪碧图，减小了图片请求次数和资源大小。每次新的动效出来，还需要开发介入处理。 本文的优化主要解决2个问题：1、资源文件多，不方便发布。前文优化后，有3个文件，1个html，1个json，1个png的雪碧图。本文优化后，只有1个html文件。 2、需要开发介入。前文优化后，需要开发处理雪碧图生成、json数据改造、雪碧图压缩等等。本文优化后，不需要开发介入。设计用AE导出资源后，通过前端提供的工具，自动生成html代码，这个html文件直接发布即可。 优化方案：通过Electron，开发出一个桌面应用，这个应用将自动处理所有需要开发介入的事情。 ElectronElectron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架。【打造你的第一个 Electron 应用】一文可以让你快速上手Electron。 动效生成器界面启动Electron应用，会打开一个界面，本文叫做HTML动效生成器，界面中收集3个信息：1、AE导数的demo文件夹；2、动效尺寸宽3、动效尺寸高 比如demo文件在桌面，那么在demo文件夹路径的输入框中直接填入地址：C:\\Users\\win\\Desktop\\demo因为默认导出的数据尺寸宽高是100%，大小不固定，所以还需收集尺寸信息。动效宽高填设计元素的宽高即可（单位px）。 生成逻辑逻辑写在renderer.js中。设计输出资源的目录demo文件夹的结构是这样的：.├── images│ ├── img_0.png│ ├── img_1.png│ ├── img_2.png│ ├── …├── demo.html├── lottie.js└── data.json 点击生成资源按钮时，1、获取images文件夹下的图片资源。主要用到node文件系统fs的readdirSync。2、将图片转成Base64。主要用到readFileSync来读取文件、Buffer.from将读取到的文件转成Base64。3、更改data.json中的assets字段，将代表图片相对路径的p字段置空，将代表图片的u字段改成Base64。这样png图片文件就Base64编码整个进data.json文件了。更改字段主要是先readFileSync读取utf8格式文件，然后将读取的数据转成json格式，重新将要更改的字段赋值，然后转成字符串writeFileSync写入data.json。然后点击创建按钮，1、重写index.html文件，把动效尺寸宽高重写，把data.json文件的数据整个进html。2、把重写后的index.html文件输出到demo文件夹下，这个index.html就是我们最终想要的文件。 1、注意本地文件相对路径的写法，需要用path来拼接，如果直接写相对路径，在打包后相对路径发生变化会导致文件找不到 2、重写，复制等文件操作其实主要就是node fs文件系统的读和写，必要的时候做一个格式转换。 static/index.html是index.html的模版文件，主要是删除设计输出的demo.html文件的多余信息，lottie库通过script引入而不是直接在html中，animationData置空，生成的时候会重写。 打包参考官网的应用程序打包，选择electron-packager来打包，打包后生成.exe可执行文件，双击即可启动该桌面应用。至此，自动生成代码的小工具就完成啦。 总结数据对比： webp格式动图 HTML HTML格式雪碧图优化 HTML格式Base64优化 总流量 2M 258.2k 139.3k 161k 图片请求次数 1 18 1 0 总请求次数 1 21 3 2","categories":[{"name":"动效","slug":"动效","permalink":"http://example.com/categories/%E5%8A%A8%E6%95%88/"}],"tags":[]},{"title":"创建NodeJS命令行包指南","slug":"创建NodeJS命令行包指南","date":"2019-04-26T17:38:59.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"node/创建NodeJS命令行包指南/","permalink":"http://example.com/node/%E5%88%9B%E5%BB%BANodeJS%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8C%85%E6%8C%87%E5%8D%97/","excerpt":"","text":"受到启发要创建一个NodeJS命令行脚本来解决特定的问题？您想要将命令行作为可安装包发布吗？这应该很简单，对吧?幸运的是,它确实很简单！ 下面是关于创建NodeJS命令行包的简明指南。 本指南将引导您创建、映射和链接NodeJS命令行脚本。 创建node包首先，我们需要创建NodeJS包，比如只包含一个package.json文件的目录。我们可以简单地分两步来做：1、创建一个空目录；2、在目录下运行npm init。 这对于创建NodeJS命令行包并不是什么新鲜事，也不是特殊的，因为它是任何NodeJS包的起点。下面让我们创建NodeJS命令行脚本。 创建NodeJS命令行脚本你可能已经知道我们可以通过运行node script.js来执行一段NodeJS脚本，这在大多数情况下是可行的，但是NodeJS命令行脚本除了包含一个特殊的shell指令外，就是一个常规的JavaScript文件，这个稍后再详细介绍。首先，让我们创建一个JavaScript文件，它将成为NodeJS命令行脚本。 创建JavaScript文件npm官方文档和流行的NodeJS项目通常将JavaScript命令行文件命名为cli.js。这个命名非常好，因为它的名字就说明了它的作用。 JavaScript文件转成NodeJS命令行脚本和其他shell脚本类似，我想通过本地安装的node来运行我们的JavaScript文件，所以我们在JavaScript文件的顶部添加一个shebang字符序列： 1#!/usr/bin/env node 这样，我们就告诉*nix系统，JavaScript文件的解释器应该是/usr/bin/env node，它查找本地安装的node。在Windows系统中,这行会被忽略，因为它被看成注释，但是它是必须的，因为在Windows机器上npm会在NodeJS命令行包安装的时候读取它。 让JavaScript命令行文件可执行在大多数情况下，不允许执行新文件。在创建将要执行的NodeJS命令行脚本时，我们需要修改它的文件权限。在*nix系统中，您可以这样做: 1chmod +x cli.js # 让cli.js文件可执行 现在我们给脚本文件加点儿代码，我们将创建一个简单的Hello World，并打印一些提供的变量。 给NodeJS命令行文件增加代码1234#!/usr/bin/env nodeconst [,,...args] = process.argv // 取变量console.log(`Hello World $&#123;args&#125;`) // 打印Hello World和变量 现在我们可以运行它，在Linux 和 Mac OS X系统运行./cli.js，在Windows系统运行node.cmd cli.js。试试看！试试传递一些变量给它。 到现在为止，我们在Linux和Mac OS X上可以像普通的javascript文件一样运行我们的NodeJS命令行文件，但是在Windows中我们仍然需要增加node.cmd。此外，我们使用文件名来执行命令行脚本，这并不好。在下一节中，我们将避开这些问题。 命令行脚本映射到命令名到现在为止，我们将JavaScript文件变成了NodeJS命令行文件，然而，我们希望给它一个更有意义的名字，而不是NodeJS命令行脚本文件的名字。为此，我们需要配置package.json来映射命令行脚本和命令名。npm官网是这么说的： 在package.json中提供一个bin字段，表示命令名到本地文件名的映射。 这意味着我们可以为本地的JavaScript脚本指定一个命令名称，比如我们像让cli.js脚本映射到say-hello命令，我们可以像上面提到的那样增加bin字段到package.json： 我们为bin字段分配了一个对象，其中键成为命令名，值是映射到NodeJS命令行脚本文件的对象。这种格式允许我们作为开发人员提供多个脚本映射。但是，如果我们想提供一个与它的文件同名的NodeJS命令行脚本，我们可以设置一个字符串表示本地文件路径，而不是一个对象。 命令命名我们可以为命令选择任何名称，但我们不希望它与现有的流行命令名称(如ls、cd、dir等)发生冲突。如果我们使用一个现有的名称，脚本很可能不会被执行，而是执行现有现有的命令(结果可能不同)。 链接开发命令npm link命令允许我们在本地“符号链接一个包文件夹”，根据我们的需要，它将在本地安装package.json里bin字段中列出的任何命令。换句话说，npm link就像一个NodeJS包安装模拟器。值得一提的是，npm link有更广泛的用途，超出了本指南的范围。 npm link命令是从我们想符号链接的NodeJS包目录中使用的: 1npm link 执行后，我们将看到命令被全局符号链接。现在，我们可以用它自己的命令名称say-hello来执行NodeJS命令行脚本: 非常简洁有没有？这样我们就能在npm publish之前本地运行NodeJS命令行脚本。 npm link说明在底层，npm链接(也适用于npm安装)符号链接package.json bin字段中指定的所有文件。npmjs文档说: 在安装时，npm将符号链接文件到prefix&#x2F;bin中用于全局安装，或者.&#x2F;node_modules&#x2F;.bin&#x2F;用于本地安装。 在*nix系统上，npm链接过程类似于为指定的命令文件创建快捷方式，该命令文件将由shell执行，然后由node执行(因为指定了#!&#x2F;usr&#x2F;bin&#x2F;env node)。在Windows上，npm会做相同的事情（如果指定了运行环境），然而它还会创建&#123;command-name&#125;.cmd来让node执行我们特殊的命令行文件&#x2F; 保持目录整洁当我们的符号链接命令测试通过后，可能会想删除它。为此，我们可以在包目录下运行下面的代码： 1npm unlink // 不再安装 总结以上就是关于创建NodeJS命令行包的简明指南。通过这四个步骤，我们已经具备了发布NodeJS包的基础知识，该包将安装命令行包。现在，你可以commit,push你的NodeJS命令行包代码来解放你的创造力了。如果您这样做了，请在评论中通过GitHub链接给我留言，这样我就可以偷看了。 推荐最后，这些是我在自己的命令行项目中用到的工具： meow – 简单的命令行工具 chalk - 终端字符样式 yargs - 命令行options解析","categories":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}],"tags":[]},{"title":"lottie-web应用优化","slug":"lottie-web应用优化","date":"2019-04-20T17:28:36.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"动效/lottie-web应用优化/","permalink":"http://example.com/%E5%8A%A8%E6%95%88/lottie-web%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96/","excerpt":"","text":"Web动画之AE+Bodymovin文中的应用过程最近找到了2点优化空间： 1、图片资源加载2次，增加了CDN流量。优化方向：图片加载次数减小到1次；2、设计输出的图片资源多且零散，有9张小图片。优化方向：多张图片合并成1张雪碧图，减少网络请求。 加载次数上图可以看到，同一张图加载了2次，且返回的status都是200。 首先分析同一张图片加载2次的原因。 查看源码发现图片加载主要有预加载逻辑和页面元素创建逻辑两处： 预加载逻辑中会调用creatimagedata，这里会将所有的图片提前下载，后面创建svg页面元素时调用了creatcontent也会加载图片。 点击图片查看请求Headers，发现Request Headers中的Cache-Control值为no-cache,表示客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定。协商缓存的概念和协商过程这里就不叙述了，但很明显，这里的协商缓存没有命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。 这就体现了协商缓存的缺陷：如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。 而我们这里的资源下载速度最慢的也只有293ms，所以预加载的图片缓存并没有体现出预计的效果。所以图片被加载了2次。 如果不做上面方案二雪碧图的优化，可以简单的把预加载逻辑去掉。那么图片就不会加载2次了。 雪碧图查看lottie-web的文档和源码，发现并不支持雪碧图。参阅开源项目lottie-web-sprite源码后，对我们用到的lottie_svg做改造： 生成雪碧图生成雪碧图使用lia。步骤如下： 创建精灵图配置文件sprite_conf.js。（使用lia init命令可以自动生成配置文件，只不过因为需要使用自定义模版，所以这里手动创建） 12345678&#x27;use strict&#x27;;module.exports = [&#123; src: [&#x27;*.png&#x27;], // 图片素材路径匹配规则 image: &#x27;sprite.png&#x27;, // 生成的精灵图的路径 style: &#x27;sprite.js&#x27;, // 生成的图片素材和精灵图的位置关系数据文件的路径 tmpl: &#x27;./template.ejs&#x27; // 图片素材和精灵图的位置关系数据文件模版&#125;]; 创建图片素材和精灵图的位置关系数据模版文件template.ejs。 1234567891011121314151617181920var opt = &#123; width: &lt;%= size.width %&gt;, height: &lt;%= size.height %&gt;, src: &#x27;&lt;%= realpath %&gt;&#x27;, count: &lt;%= items.length %&gt;, items: [ &lt;% items.forEach(function(item, idx) &#123; -%&gt; &#123; index: &lt;%= idx %&gt;, name: &#x27;&lt;%= item.name %&gt;&#x27;, width: &lt;%= item.size.width %&gt;, height: &lt;%= item.size.height %&gt;, x: &lt;%= item.x %&gt;, y: &lt;%= item.y %&gt; &#125;, &lt;% &#125;) -%&gt; ]&#125;module.exports = opt; 运行下面2行命令得到精灵图sprite.png以及位置关系数据文件sprite.js： 12npm i -g lialia 把位置关系数据文件sprite.js中的绝对路径改为相对路径：src: &#39;./sprite.png&#39;,。 此文基础：所有文件都在同一目录层级，否则需要注意修改相对目录结构。 修改data.jsondata.json新增字段_sprite，将sprite.js中的数据复制给_sprite。此时data.json中的数据看起来类似这样： 12345678910111213141516171819202122232425262728293031323334&#123; &quot;v&quot;: &quot;5.5.0&quot;, &quot;fr&quot;: 25, &quot;ip&quot;: 0, ... &quot;assets&quot;: [&#123; &quot;id&quot;: &quot;image_0&quot;, &quot;w&quot;: 66, &quot;h&quot;: 55, &quot;u&quot;: &quot;&quot;, &quot;p&quot;: &quot;img_0.png&quot;, &quot;e&quot;: 0 &#125; ... ], &quot;layers&quot;: [...], &quot;markers&quot;: [], &quot;_sprite&quot;: &#123; &quot;width&quot;: 733, &quot;height&quot;: 568, &quot;src&quot;: &quot;./sprite.png&quot;, &quot;count&quot;: 9, &quot;items&quot;: [&#123; &quot;index&quot;: 0, &quot;name&quot;: &quot;img_0&quot;, &quot;width&quot;: 66, &quot;height&quot;: 55, &quot;x&quot;: 243, &quot;y&quot;: 310 &#125; ... ] &#125;&#125; 更改源码更改configAnimation方法，增加preloadSprite方法和loadAssetsFromSprite方法，这些可参考lottie-web-sprite。 另外需要更改getAssetsPath方法，如果有_spriteSrc，图片路径取雪碧图生成的base64编码。方法里的其他逻辑不变。 1234567891011121314151617181920212223242526AnimationItem.prototype.getAssetsPath = function (assetData) &#123; var path = &#x27;&#x27;; if (this._spriteSrc) &#123; this.imagePreloader.images.assetData var i = 0, len = this.imagePreloader.images.length; while (i &lt; len) &#123; if(assetData.id == this.imagePreloader.images[i].assetData.id)&#123; return this.imagePreloader.images[i].img.src; &#125; i += 1; &#125; &#125; else if(assetData.e) &#123; path = assetData.p; &#125; else if(this.assetsPath)&#123; var imagePath = assetData.p; if(imagePath.indexOf(&#x27;images/&#x27;) !== -1)&#123; imagePath = imagePath.split(&#x27;/&#x27;)[1]; &#125; path = this.assetsPath + imagePath; &#125; else &#123; path = this.path; path += assetData.u ? assetData.u : &#x27;&#x27;; path += assetData.p; &#125; return path;&#125;; 总结现在就可以应用雪碧图了。 lia自动生成的雪碧图还可以再压缩的哦 优化效果总结（以童话故事吊牌数据为例）： webp格式动图 HTML HTML格式优化后 总流量 2M 258.2k 139.3k 图片请求次数 1 18 1 webp格式动图主要缺点是太大，接近2M。做成HTML吊牌后，利用第三方库实现动效，但是这种方式的缺点是设计直接输出的图多且零散，比如童话故事有9张图，第三方库会预加载图片，发起9次请求，由于CDN缓存机制导致预加载功能失效，会重复加载，一共发起18次图片资源请求。HTML吊牌优化后，效果最佳。主要更改了第三方库的源码，多张图片合并成1张，图片资源大小和请求次数都大幅减小。 本文修改的是lottie-web-5.5.0版本的lottie_svg.js源码 参考 lottie-web-sprite 精灵图在 Lottie Web 动画中的应用 - 知乎 lia 一文读懂前端缓存 - 知乎","categories":[{"name":"动效","slug":"动效","permalink":"http://example.com/categories/%E5%8A%A8%E6%95%88/"}],"tags":[]},{"title":"node自动布署","slug":"node自动布署","date":"2019-04-18T11:41:38.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"node/node自动布署/","permalink":"http://example.com/node/node%E8%87%AA%E5%8A%A8%E5%B8%83%E7%BD%B2/","excerpt":"","text":"前端静态资源布署，可以通过xShell或者SecureCRT这种软件来上传资源，用软件的ftp上传，或者手动输入一些命令来操作，比如： 1234#上传rz#解压unzip 如果用node自动布署，就简便很多。 使用node脚本，可将npm run build之后构建出来的dist文件夹压缩，然后自动上传到远端服务器，然后在远端服务器自动解压到固定的目录。 cli在package.json中增加bin命令cli-deploy,指向./bin/deploy.js,在script中增加deploy命令。后面完成deploy.js后就可以直接npm run deploy来发布了。不了解node cli的话，可以看这篇文章A guide to create a NodeJS command-line package – Netscape – Medium 12345678910// package.json&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;deploy&quot;: &quot;vue-cli-service build &amp;&amp; cli-deploy&quot;&#125;,&quot;bin&quot;: &#123; &quot;cli-deploy&quot;: &quot;./bin/deploy.js&quot;&#125;, 也可以不使用bin，将scripts中的deploy命令改成vue-cli-service build &amp;&amp; node ./bin/deploy.js 压缩1234567891011121314151617181920212223242526272829303132333435363738// zip.jsconst glob = require(&#x27;glob&#x27;)const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const yazl = require(&quot;yazl&quot;)const chalk = require(&#x27;chalk&#x27;)const zip = (&#123; sourcePath, destPath, filename &#125;) =&gt; &#123; return new Promise((resolve) =&gt; &#123; const zipfile = new yazl.ZipFile() if (!fs.existsSync(destPath)) &#123; fs.mkdirSync(destPath, 0777) &#125; const files = glob.sync(&#x27;**/*.*&#x27;, &#123; cwd: sourcePath &#125;) files.forEach(function(file) &#123; const filePath = path.join(sourcePath, file) zipfile.addFile(filePath, file) &#125;) zipfile.outputStream.pipe(fs.createWriteStream(path.resolve(destPath, filename))).on(&#x27;close&#x27;, () =&gt; &#123; console.log(chalk.cyan( ` $&#123;filename&#125; has build!` )) resolve() &#125;) zipfile.end() &#125;)&#125;module.exports = &#123; zip&#125; 123456789// bin/deploy.js#!/usr/bin/env nodeconst &#123; zip &#125; = require(&#x27;./zip&#x27;)const zipOptions = &#123; sourcePath: path.join(__dirname, &#x27;../dist&#x27;), // 需要要打包的目录 destPath: path.join(__dirname, &#x27;../&#x27;), // 打包存放的目录 filename: &#x27;dist.zip&#x27;, // 打包后的名称&#125;zip(zipOptions) 上传上传这块做了比较多的调研，看了比较多的库，最后决定用scp2，不需要配置ssh免密登录，直接使用的时候指定信息就行。 123456// bin/deploy.jsconst path = require(&#x27;path&#x27;)const client = require(&#x27;scp2&#x27;)client.scp(path.join(__dirname, &#x27;../dist.zip&#x27;), `$&#123;user&#125;:$&#123;pass&#125;@$&#123;host&#125;:$&#123;reomteFloder&#125;`, () =&gt; &#123; // 这里远端解压&#125;) 也可以不压缩，直接上传文件夹 123456// bin/deploy.jsconst path = require(&#x27;path&#x27;)const client = require(&#x27;scp2&#x27;)client.scp(path.join(__dirname, &#x27;../dist/&#x27;), `$&#123;user&#125;:$&#123;pass&#125;@$&#123;host&#125;:$&#123;reomteFloder&#125;/`, () =&gt; &#123; // 上传成功&#125;) 解压选用simple-ssh连接远端，然后用ssh.exec在远端执行命令。simple-ssh只是把ssh2进一步封装了一下，让调用更简单。 123456789101112// bin/deploy.jsconst SSH = require(&#x27;simple-ssh&#x27;)const host = &#x27;xx.xx.xx.xx&#x27; // 远端主机ipconst user = &#x27;xxx&#x27; // 用户名const pass = &#x27;xxx&#x27; // 密码const reomteFloder = &#x27;/xxx/xxx/xx&#x27; // 远端解压目录const ssh = new SSH(&#123;host, user, pass&#125;)ssh.exec(`rm -rf $&#123;reomteFloder&#125;/dist`) // 解压前先清空dist目录，避免有哈希的文件积累 .exec(`unzip -o $&#123;reomteFloder&#125;/dist.zip -d $&#123;reomteFloder&#125;/dist`, &#123; out: console.log.bind(console), &#125;) .start() unzip参数说明： - -o 不必先询问用户，unzip执行后覆盖原有文件 - -d 指定文件解压缩后所要存储的目录 pm2有的项目需要用pm2重启，如果直接远程执行pm2命令，比如pm2 status, 会报错pm2: command not found。解决办法：把pm2 status改成&#39;bash -l -c &quot;pm2 status&quot;&#39;。参考了bash-doesnt-load-node-on-remote-ssh-command和env-problem-when-ssh-executing-command-on-remote 总结至此，完成了自动压缩、上传、解压。cli-deploy可以部署；npm run deploy可以构建+部署。 完整版本deploy.js如下： 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env nodeconst &#123; zip &#125; = require(&#x27;./zip&#x27;)const path = require(&#x27;path&#x27;)const SSH = require(&#x27;simple-ssh&#x27;)const client = require(&#x27;scp2&#x27;)const zipOptions = &#123; sourcePath: path.join(__dirname, &#x27;../dist&#x27;), // 需要要打包的目录 destPath: path.join(__dirname, &#x27;../&#x27;), // 打包存放的目录 filename: &#x27;dist.zip&#x27;, // 打包后的名称&#125;const host = &#x27;xx.xx.xx.xx&#x27; // 远端主机ipconst user = &#x27;xxx&#x27; // 用户名const pass = &#x27;xxx&#x27; // 密码const reomteFloder = &#x27;/xxx/xxx/xx&#x27; // 远端解压目录const ssh = new SSH(&#123;host, user, pass&#125;)const upload = () =&gt; &#123; client.scp(path.join(__dirname, &#x27;../dist.zip&#x27;), `$&#123;user&#125;:$&#123;pass&#125;@$&#123;host&#125;:$&#123;reomteFloder&#125;`, () =&gt; &#123; ssh.exec(`unzip -o $&#123;reomteFloder&#125;/dist.zip -d $&#123;reomteFloder&#125;/dist`, &#123; out: console.log.bind(console), &#125;) .start() &#125;)&#125;async function deploy () &#123; await zip(zipOptions) console.log(&#x27;Build complete&#x27;) upload()&#125;deploy()","categories":[{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"}],"tags":[]},{"title":"Web动画之AE+Bodymovin","slug":"Web动画之AE-Bodymovin","date":"2019-03-28T16:53:44.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"动效/Web动画之AE-Bodymovin/","permalink":"http://example.com/%E5%8A%A8%E6%95%88/Web%E5%8A%A8%E7%94%BB%E4%B9%8BAE-Bodymovin/","excerpt":"","text":"AE+Bodymovin简介设计通过AE设计动效，安装Bodymovin插件后，直接导出js或者json数据给前端。前端利用设计提供的动画数据即可实现动效。 设计设计首先需要下载Bodymovin插件。具体的设计细节这里就不描述了，交给设计同事就好。需要注意的是：1、文件如果使用了图片资源或者未转成形状图层的Adobe Illustrator文件图层, 将会同时生成一个images文件夹存放这些图片资源。(建议将AI图层转换为形状图层，这样他们会被导出为矢量数据，只需在AE中导入的AI图层上右键 &gt; 从矢量图层创建形状) 注意，如果不同的带图片资源的动画导出到同一地址，images文件夹将会被覆盖。 2、性能Bodymovin的动画都是实时渲染的，最好控制下AE工程文件体积。避免这种情况：绘制了一个巨大的形状图层，但是只通过遮罩使用其中一小部分。过多的节点同样会影响性能。Bodymovin支持的AE特性： 支持预合成、形状图层、固态层、图片、空对象以及文字图层。 支持遮罩和反向遮罩。也许别的模式也会支持，但是会对性能造成巨大影响。 支持时间重映射。 支持形状图层的形状、矩形、椭圆和星形。 支持滑块效果。 支持部分表达式。更多介绍可以查看这里。 不支持： 图像序列、视频和音频。 不要伸缩图层！不知为何，伸缩图层会破坏导出的数据，所以不要做这个操作。 前端1、安装 1npm install lottie-web 或者直接从官方CDN获取。 完整版支持渲染为svg\\canvas\\html三种格式，由于我们只需要svg格式（html格式性能不好，canvas格式性能够好，但是动画数据是js格式，有安全隐患，折中选择json格式数据的svg），所以只需要lottie_svg.min.js，经过gzip压缩的库文件只有48.3k。 2、demo请看demo。请看官方文档。 应用设计输出资源的目录结构是这样的：.├── images│ ├── img_0.png│ ├── img_1.png│ ├── img_2.png│ ├── …├── demo.html├── lottie.js└── data.json有3个问题导致不能直接布署：1、资源太大；2、目录结构不方便上传CDN；3、动画尺寸未设置，默认是100%。 资源大小问题由于不完全是矢量图的设计，所以有images图片资源，直接点击demo.html就可以看到效果。但是设计直接导出的资源比较大，主要有以下几点原因： 1、lottie.js未压缩，直接内嵌在html里面，有243k,如果选择官网CDN的lottie_svg.min.js就只有48k，不过公司的CDN只能压缩到62k。2、data.json也直接内嵌到html里面，但把json文件放到CDN上用gzip压缩后，只有2k。 把demo.html里的lottie.js和data.json代码删除，用CDN加载lottie_svg.min.js和data.json。通过webpack压缩后的demo.html文件只有577字节。 目录结构问题为了方便发布到CDN，改变了目录结构.├── img_0.png├── img_1.png├── …├── img_8.png├── demo.html└── data.json需要把data.json里的图片资源路径改一下，assets里面的u代表图片资源路径。 123456789101112131415161718// 原来是这样的&quot;assets&quot;: [&#123; &quot;id&quot;: &quot;image_0&quot;, &quot;w&quot;: 66, &quot;h&quot;: 55, &quot;u&quot;: &quot;images/&quot;, &quot;p&quot;: &quot;img_0.png&quot;, &quot;e&quot;: 0&#125;]// 改成下面这样&quot;assets&quot;: [&#123; &quot;id&quot;: &quot;image_0&quot;, &quot;w&quot;: 66, &quot;h&quot;: 55, &quot;u&quot;: &quot;&quot;, &quot;p&quot;: &quot;img_0.png&quot;, &quot;e&quot;: 0&#125;] 动画尺寸问题修改#lottie的width和height。 完整示例本示例lottie_svg.min.js使用官方CDN，实际使用的是公司CDN资源。 123456789101112131415161718192021222324252627282930313233343536&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;head&gt; &lt;style&gt; body&#123; margin: 0px; height: 100%; overflow: hidden; &#125; #lottie&#123; width:280px; height:300px; display:block; overflow: hidden; transform: translate3d(0,0,0); text-align: center; opacity: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.5.1/lottie_svg.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;div id=&quot;lottie&quot;&gt;&lt;/div&gt;&lt;script&gt; var params = &#123; container: document.getElementById(&#x27;lottie&#x27;), renderer: &#x27;svg&#x27;, loop: true, autoplay: true, path: &#x27;data.json&#x27; &#125;; var anim; anim = lottie.loadAnimation(params);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 应用总结1、资源大小输出的webp格式动图接近2M。这种方式就小了很多，库文件lottie_svg.min.js有63k，data.json有2k，html不到1k，所有的图片资源96.1k,不过不知道为什么图片资源会加载2次(后面分析源码搞清楚了加载两次的原因，见lottie-web应用优化，造成了192.2k的图片资源流量。不过总体来说63+2+1+192.2&#x3D;258.2k，是远小于2M的，只有原来的12.6%的大小，相当于节约了87.4%的流量。 2、开发效率高设计输出动效资源，开发处理下上面列过的3个问题点就可以直接布署了，动效细节完美实现。 参考 lottie-web","categories":[{"name":"动效","slug":"动效","permalink":"http://example.com/categories/%E5%8A%A8%E6%95%88/"}],"tags":[]},{"title":"SVG线条动画","slug":"SVG线条动画","date":"2019-03-25T16:48:49.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"动效/SVG线条动画/","permalink":"http://example.com/%E5%8A%A8%E6%95%88/SVG%E7%BA%BF%E6%9D%A1%E5%8A%A8%E7%94%BB/","excerpt":"","text":"SVG线条动画原理现在有一个svg，如何让它动起来呢？主要用到两个参数： stroke-dasharray：控制描边的点划线的图案范式。dasharray是一个长度和百分比的数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。 stroke-dashoffset：指定dash模式到路径开始的距离。如果使用了一个 &lt;百分比&gt; 值， 那么这个值就代表了当前viewport的一个百分比。值可以取为负值。 原理一利用stroke-dasharray，假如svg路径长度是100，设置stroke-dasharray: 0, 100，表示路径上的实线长度为0，空隙为100，所以一开始整个路径都是空隙，什么也看不见，然后过渡到stroke-dasharray: 100, 100，由于整个路径的长度是100，实线从0变成100，看起来就像实线动起来了。 原理二利用stroke-dashoffset，假如svg路径长度是100，设置stroke-dasharray: 100, 100;stroke-dashoffset: 100，表示100实线和100空隙，线条偏移100，于是100的实线被移出路径，路径上只剩100空隙，什么也看不见，然后慢慢修改偏移量，把实线一点点挪出来，就看到实线动起来了。 获取路径长度上面原理都是假设路径长度100，实际需要使用js的document.getElementById(&#39;path&#39;).getTotalLength()获取路径长度。 demost1使用stroke-dashoffset，st2使用stroke-dasharray。请查看demo。","categories":[{"name":"动效","slug":"动效","permalink":"http://example.com/categories/%E5%8A%A8%E6%95%88/"}],"tags":[]},{"title":"JavaScript引擎基础之内联缓存","slug":"JavaScript引擎基础之内联缓存","date":"2019-03-25T14:37:08.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/JavaScript引擎基础之内联缓存/","permalink":"http://example.com/js/JavaScript%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98/","excerpt":"","text":"形状背后的主要推动力是内联缓存（Inline Caches）或ICs的概念。ICs是让JavaScript快速运行的关键因素！JavaScript引擎使用ICs来记住去哪里寻找对象的属性，从而减少昂贵的查找次数。 下面这个函数getX接受一个对象并返回属性x： 123function getX(o) &#123; return o.x;&#125; 如果我们在JSC中运行这个函数，它会生成以下字节码: 第一条命令get_by_id从第一个变量arg1中加载属性x，并把结果存到loc0中，第二条命令返回我们在loc0中存的内容。JSC还将内联缓存嵌入get_by_id命令，该命令由两个未初始化的槽组成。 现在我们假设把对象{ x: ‘a’ }传入getX，正如我们上篇文章中所了解的，这个对象有一个带有属性x的形状，这个形状存储属性x的偏移量和值。当你第一次执行getX,get_by_id命令寻找x属性，然后发现值存在偏移为0的地方。 嵌入到get_by_id指令中的IC将记住找到的属性的形状和偏移： 后续运行种，IC只需要比较形状，如果一样，就直接从记忆偏移量处读取值，而且，如果JavaScript引擎遇到的对象的形状之前IC记录过，引擎就不会获取属性值，开销很大的属性寻找被直接跳过，这比每次都寻找属性明显快多了。 高效存储数组数组是常见的存储类型，这些属性的值被称为数组元素，JavaScript引擎在默认情况下让数组索引属性可写、可枚举和可配置，并将数组元素与其他命名属性分开存储。 思考下面这个数组： 123const array = [ &#x27;#jsconfeu&#x27;,]; JavaScript引擎存储数组长度length为1，然后指向含有offset和length属性的形状。 看起来和我们之前看到的一样，但是数组的value值存到哪里去了呢？ 每个数组都有一个单独的元素支持存储，其中包含所有数组索引的属性值。JavaScript引擎不需要为数组元素存储任何属性属性，因为通常情况下数组都是可写、可枚举和可配置的。 异常情况下会发生什么呢？比如更改数组元素的属性值会怎样? 1234567891011// 请永远不要这么做const array = Object.defineProperty( [], &#x27;0&#x27;, &#123; value: &#x27;Oh noes!!1&#x27;, writable: false, enumerable: false, configurable: false, &#125;); 上面的代码片段定义了一个名为“0”的属性(恰好是一个数组索引)，但是将其值设置为非默认值。在这种情况下，JavaScript引擎将整个支持存储的元素表示为字典，将数组索引映射到属性值。 即使只有1个数组元素有非默认属性，整个数组的后备存储器进入这种缓慢而低效的模式。避免在数组索引上使用Object.defineProperty（我不知道你为什么要这么做。这似乎是一件奇怪的、无用的事情）。 小结我们已经了解了JavaScript引擎如何存储对象和数组，形状和ICs又是如何优化对象和数组的常见操作。基于这些知识，我们发现了一些实用的JavaScript编码技巧，可以帮助提高性能: 始终以相同的方式初始化对象，这样它们就不会有不同的形状。 不要打乱数组元素的默认值，这样可以有效地存储和操作它们。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"JavaScript引擎基础之形状","slug":"JavaScript引擎基础之形状","date":"2019-03-11T16:24:17.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/JavaScript引擎基础之形状/","permalink":"http://example.com/js/JavaScript%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BD%A2%E7%8A%B6/","excerpt":"","text":"本文描述了所有JavaScript引擎共有的一些关键基础，不仅仅是作者所研究的V8引擎。作为JavaScript开发者，深入理解JavaScript引擎的工作方式，会帮助你推断代码的性能。 JavaScript引擎管道这一切都从您编写的JavaScript代码开始，JavaScript引擎解析源码，将其转换成抽象语法树（Abstract Syntax Tree，简称AST），基于AST,解释器将其变成字节码。此时，引擎实际上正在运行JavaScript代码。 JavaScript source code: JavaScript源码 parser: 解析器 Abstract Syntax Tree： 抽象语法树，简称AST interpreter: 解释器 bytecode: 字节码 optimize: 优化 optimizing compiler: 优化编译器 optimized code: 优化后的代码 deoptimize: 反优化 profiling data: 分析数据 为了让它运行的更快，字节码可以和分析数据一起送到优化编译器，优化编译器根据它的分析数据做出某些假设，然后生成高度优化的机器码。如果在某一时刻其中一个假设被证明是错的，那么优化编译器就会取消优化并返回解释器。 JavaScript引擎的解释&#x2F;编译器管道（Interpreter&#x2F;compiler）现在，让我们放大这个管道中实际运行JavaScript代码的部分。比如代码在哪里得到解释和优化，以及主流JavaScript引擎之间的一些差异。通常，有一个包含解释器和优化编译器的管道，解释器快速生成未经过优化的字节码，而优化编译器需要更长的时间，但最终生成高度优化的机器码。 优化编译器：这个通用管道几乎和V8(Chrome和Node中使用的JavaScript引擎)的工作原理一样。 V8的优化编译器： Ignition: 点火器TurboFan: 风扇 V8里的解释器叫点火器，负责生成和执行字节码。当它运行字节码时，会收集分析数据（后面将会用来加快执行速度），当某个函数变热，比如经常执行，它的字节码和分析数据就会传到风扇（我们的优化编译器），然后基于分析数据来生成高度优化的机器码。 SpiderMonkey（Firefox和SpiderNode中使用的Mozilla JavaScript引擎），会有一点不同。它有两个而不是一个优化编译器。解释器优化到基线编译器里面，基线编译器会生成一些优化的代码。结合运行代码时收集的分析数据，IonMonkey编译器可以生成高度优化的代码。如果假设的优化失败了，IonMonkey返回到基线代码。 SpiderMonkey的优化编译器： Baseline: 基线 Chakra(在Edge和Node-ChakraCore中使用的微软的JavaScript引擎)使用了类似的两个优化编译器。解释器优化成SimpleJIT (JIT代表即时编译器)，生成优化的代码。与分析数据相结合，FullJIT生成更优化的代码。Chakra的优化编译器：JavaScriptCore(缩写为JSC，苹果的JavaScript引擎，用于Safari和React Native)，使用三种不同的优化编译器将其发挥到极致。底层解释器LLInt优化到基线编译器，然后基线编译器优化到DFG(Data Flow Graph)编译器，DFG又优化到FTL(Faster Than Light)编译器。JavaScriptCore的优化编译器：为什么有些引擎比其他引擎有更多的优化编译器?一切都是关于权衡的。解释器可以快速生成字节码，但是字节码通常不是很高效。另一方面，优化编译器需要更长的时间，但最终会生成更高效的机器码。这是快速让代码运行（解释器）和慢一点让代码运行，但最终让代码以最优性能的方式运行（优化编译器）之间的权衡。一些引擎选择添加具有不同时间或效率特性的多个优化编译器，以额外的复杂性为代价对这些权衡进行更细致的控制。另一个权衡与内存使用有关。有关这方面的详细信息，请参阅我们的后续文章。 上面我们主要描述了不同的JavaScript引擎的解释器和优化编译器管道的差异，但是除了这些差异，在高层面上看，所有JavaScript引擎都具有相同的体系结构:有一个解析器和某种解释器&#x2F;编译器管道。 JavaScript的对象模型让我们通过放大某些方面的实现来看看JavaScript引擎还有什么共同之处。比如，JavaScript引擎如何实现JavaScript对象模型，以及它们使用哪些技巧来加速访问JavaScript对象上的属性，事实上，所有主流引擎都实现了非常类似的功能。ECMAScript规范定义对象是字符串键映射到属性值的字典。除了[[Value]]本身外，规范还定义了这些属性： [[Writable]]：决定是否可以将属性重写 [[Enumerable]]：决定属性是否出现在for-in循环中（是否可枚举） [[Configurable]]：决定是否可以将属性删除双方括号[[]]看起来很时髦，但这只是规范表示不直接暴露给JavaScript的属性的方式。但您仍然可以在JavaScript中使用Object.getOwnPropertyDescriptor获得任何给定对象的这些值。 123const object = &#123; foo: 42 &#125;;Object.getOwnPropertyDescriptor(object, &#x27;foo&#x27;);// → &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; 这就是JavaScript如何定义对象的，那数组呢？您可以将数组看作对象的特殊情况，一个区别是数组对数组索引有特殊的处理。数组索引是ECMAScript规范中的一个特殊术语。在JavaScript中数组长度限制在2³²−1以内，数组索引是该限制内任何有效的索引，比如，任何0到2³²−2之间的整数。 另一个不同之处在于数组还有一个神奇的长度属性。 1234const array = [&#x27;a&#x27;, &#x27;b&#x27;];array.length; // → 2array[2] = &#x27;c&#x27;;array.length; // → 3 上面的例子中，数组在创建的时候有一个值为2的length，然后我们给第2项赋值，length就自动更新了。 JavaScript定义数组类似于对象。例如，包括数组索引在内的所有键都显式地表示为字符串。数组中的第一个元素存储在键“0”下。 length属性只是另一个不可枚举和不可删除的属性，一旦元素被添加到数组中，JavaScript将自动更新length属性的[[Value]]值。总之，数组的表现和对象非常相似。 优化属性访问现在我们知道在JavaScript中对象是怎么定义的了，让我们深入了解JavaScript引擎如何高效地处理对象。JavaScript中访问属性是目前最常见的操作。对于JavaScript引擎来说，快速访问属性是至关重要的。 1234567const object = &#123; foo: &#x27;bar&#x27;, baz: &#x27;qux&#x27;,&#125;;// 这里我们访问了`object`的`foo`属性doSomething(object.foo); 形状在JavaScript中，很多对象有相同的key是很常见的，这样的对象有相同的形状。 123const object1 = &#123; x: 1, y: 2 &#125;;const object2 = &#123; x: 3, y: 4 &#125;;// `object1`和`object2`有相同的形状 形状相同的对象获取相同的属性值也很常见： 123456789function logX(object) &#123; console.log(object.x);&#125;const object1 = &#123; x: 1, y: 2 &#125;;const object2 = &#123; x: 3, y: 4 &#125;;logX(object1);logX(object2); 考虑到这一点，JavaScript引擎可以根据对象的形状优化对象属性访问。下面是它的工作原理。让我们假设有一个对象，有x和y属性，它使用了我们前面讨论过的字典数据结构：它包含key的字符串，它们指向各自的值。如果你访问一个属性，比如object.y，JavaScript引擎在JSObject中查找键y,然后加载相应的属性值，最后返回[[value]]。但是这些属性值在内存中是存在哪里呢？我们可以把他们存为JSObject的一部分吗？如果我们假设以后会看到更多具有这种形状的对象，那么将包含键值对的完整字典存储在JSObject本身是很浪费的，因为所有具有相同形状的对象都重复使用属性名。这是大量重复和不必要的内存使用。作为一种优化，引擎单独存储对象的形状。这个形状Shape包含所有的键和值，除了[[value]],在Shape中用值的偏移量offset代替JSobject中的value，这样JavaScript就知道去哪里找到value，每个具有相同形状的JSObject都指向这个形状实例，现在，每个JSObject只需要存储这个对象特有的值。 这个好处在有大量对象的时候变得明显，不管有多少对象，只要它们形状相同，我们只需要存储一次形状和属性。 所有JavaScript引擎都使用形状作为优化手段，但它们并不都称它们为形状: 学术论文称它们为隐藏类（Hidden Classes） V8称它们为映射（Maps） JavaScriptCore称它们为结构（Structures） SpiderMonkey称它们为形状（Shapes） 在本文中，我们将继续使用形状这个术语。 转换链和树如果你有一个具有特定形状的对象，但是你给它添加了一个属性，会发生什么?JavaScript引擎如何找到新形状? 123const object = &#123;&#125;;object.x = 5;object.y = 6; 这些形状在JavaScript引擎中形成所谓的转换链。这里有一个例子: 这个对象一开始没有任何属性，所以它指向一个空的形状，下一个状态中，这个对象增加了x为5的属性，所以JavaScript引擎将其指向一个新的形状，这个形状有x属性，值5在第一个偏移量0处添加到JSObject，再下一个状态增加y为6的属性，所以JavaScript引擎将其指向又一个新的形状，这个形状包含x和y属性，并将值6追加到JSObject(偏移量为1)。 属性添加的顺序影响形状,例如{ x: 4, y: 5 }的形状和{ y: 5, x: 4 }不同 我们甚至不需要为每个形状存储完整的属性表，每个形状只需要知道它引入的新属性。在本例中，我们不必将关于x的信息存储在最后一个形状中，因为它可以在前面的链找到。为了实现这一功能，每个形状都链接着上一个形状。 如果你JavaScript代码中写o.x，JavaScript引擎通过遍历转换链查找属性x，直到找到引入属性x的形状。但是如果没有办法创建一个转换链呢?例如，如果您有两个空对象，并且为每个空对象添加了不同的属性，该怎么办? 1234const object1 = &#123;&#125;;object1.x = 5;const object2 = &#123;&#125;;object2.y = 6; 在这种情况下，我们必须用分支，而不是链，我们最终得到一个转换树: 这里我们创建了空对象a，然后给a增加x属性，最终我们得到只有一个value的JSObject和2个形状：一个空形状，一个只有属性x的形状。第二个例子一开始也只有一个空对象b，然后增加属性y。最终我们得到两个转换链和三个形状。 这意味着我们总是从空的形状开始？不一定。引擎对已经包含属性的对象应用了一些优化。假设我们从空对象开始添加x，或者有一个已经包含x的对象： 123const object1 = &#123;&#125;;object1.x = 5;const object2 = &#123; x: 6 &#125;; 在第一个例子中，我们一开始是空的形状，然后链接到有x属性的形状，就像我们上文看到的那样；在object2的例子中，直接生成有x的对象，而不是从一个空对象开始并进行转换。 包含属性x的对象从包含x的形状开始，有效地跳过了空形状。这就是V8和SpiderMonkey所做的。这种优化缩短了转换链，使从字面构造对象更加有效。 下面的例子是有x,y和z的3D坐标对象。 1234const point = &#123;&#125;;point.x = 4;point.y = 5;point.z = 6; 如前所述，这将在内存中创建有3个形状的对象(不包括空形状)。读取对象上的x，比如你在代码中写point.x，JavaScript引擎需要遵循链接列表：它从底部的形状开始，然后逐渐上升到顶部引入x的形状。 如果我们经常这样做，将会非常慢，尤其是当对象有很多属性的时候。找到该属性的时间是O(n)，也就是说，对象的属性数量是线性的。为了加快搜索属性的速度，JavaScript引擎添加了叫形状表的数据结构。这个形状表是一个字典，将属性键映射到引入属性的各个形状。 等一下，现在我们回到了字典查找……这是我们开始添加形状之前的位置!那么我们为什么还要为形状而烦恼呢？这就是形状可以用内联缓存优化的原因(内联缓存见后续文章)。","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"FLIP你的动画","slug":"FLIP你的动画","date":"2019-03-04T15:44:01.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"动效/FLIP你的动画/","permalink":"http://example.com/%E5%8A%A8%E6%95%88/FLIP%E4%BD%A0%E7%9A%84%E5%8A%A8%E7%94%BB/","excerpt":"","text":"网页中的动效应该运行在60fps，达到这个帧率并不容易，它去取决于你做了多大的尝试，这里我将用FLIP来帮助你。 我已经写了一个FLIP库，在这里你可以看到文档和demos。 FLIP本质上是一个原则，而不是框架或库。这是一种思考动画的方式，尝试让浏览器渲染动画的开销尽可能小，如果一切顺利，应该能达到60fps的动画。 基本概念一般动画直接开始后，在每帧可能做开销大的计算，而这里我们让动画从头开始，动态的重新计算动效属性，然后让浏览器简单的执行渲染。FLIP代表First,Last,Invert.Play。 First: 元素涉及到动效的初值状态 Last: 元素的最终状态 Invert: 指出从动画开始到结束元素要如何变化，比如width、height、opacity。然后用transform、opacity来反向设置。如果元素从开始到结束下移了90px，你就要应用transformY(-90px)，让元素看起来和开始时一样，虽然实际上不是。 Play: 开始变化任何你改变的属性，然后去掉逆变换。因为元素处于最终位置，所以反向设置中的transform、opacity，将使它们从模拟的第一个位置轻松变换到最后一个位置。 代码分解123456789101112131415161718192021222324252627// 获取初始位置var first = el.getBoundingClientRect();// 设置到最终位置el.classList.add(&#x27;totes-at-the-end&#x27;);// 再次获取位置信息. 注意这会引起重排.var last = el.getBoundingClientRect();// 需要的话也可以操作其他可计算的样式。// 但要确保尽量使用只触发重绘的属性，比如transform、opacityvar invert = first.top - last.top;// Invert.el.style.transform = `translateY($&#123;invert&#125;px)`;// 等待下一帧，这样我们就知道所有的样式更改都已生效requestAnimationFrame(function() &#123; // 开始动画过程 el.classList.add(&#x27;animate-on-transforms&#x27;); el.style.transform = &#x27;&#x27;;&#125;);// 用transitionend捕获动画结束el.addEventListener(&#x27;transitionend&#x27;, tidyUpAnimations); 然而，也可以用即将来临的Web Animations API，这个会更简单，只是需要Web Animations API polyfill，不过这个补丁很轻量，并且确实很实用。 1234567891011121314151617181920212223// 获取初始位置var first = el.getBoundingClientRect();// 移动到最终位置el.classList.add(&#x27;totes-at-the-end&#x27;);// 获取最终位置var last = el.getBoundingClientRect();// Invert.var invert = first.top - last.top;// 从inverted位置移动到最终last位置.var player = el.animate([ &#123; transform: `translateY($&#123;invert&#125;px)` &#125;, &#123; transform: &#x27;translateY(0)&#x27; &#125;], &#123; duration: 300, easing: &#x27;cubic-bezier(0,0,0.32,1)&#x27;,&#125;);// 在动画结束时做任何需要的整理player.addEventListener(&#x27;finish&#x27;, tidyUpAnimations); FLIP的用途当你在响应到用户输入后用一些动画来响应，这绝对是非常棒的。比如，在Chrome开发峰会上，我展开用户点击的卡片，通常情况下，元素开始和结束的位置、大小都不知道，因为网页是响应式的，元素位置大小都不固定，但FLIP就很有用，它能明确的计算元素，在运行时给出正确的值。 你能够做这种相对昂贵的预计算是因为利用了用户感知。用户和你的网页有交互之后，你有趁他们不注意的100ms时间来做这些。在这100ms内，用户会觉得网站是立刻响应了的，而你只需要在动画过程中保持60fps。 我们可以利用这个感知期(100ms)，通过javascript做getBoundingClientRect操作（或者你非要用不优雅的getComputedStyle），这样我们使动画细腻流畅，利于重绘。 可以用transform和opacity重写动画是最好的，如果你在js或CSS中没有用这些属性，那你可以开始优化了，它们会在你改变布局属性（比如width、height、left、top）时，用开销小的属性重写后达到最好的优化效果。 有时你为了用FLIP需要重新构思你的动画，在多数情况下，我把动画元素单独提取出来，这样我就可以不失真的制作动画了，并且尽可能多的用FLIP。你可能会觉得这样应用过度了，但我觉得不是，因为： 1、大家想这样。我的一个同事兼好友最近做了一个关于人们想从新闻app上得到什么的调查，最多的回答（这让他很吃惊）不是离线支持、同步、通知，或类似的东西，而是浏览平滑——没有晃动、没有卡顿、没有颤抖。 2、程序员就是这么做的。当然，这是一种主观的衡量标准，但我已经听过很多次，程序员花了好几天的时间才把过渡做得恰到好处。通过运维服务，我们我网站加载速度都很快，用户会根据他们的操作体验来评价我们的网站，而这些细节将使我们与众不同。 注意事项使用FLIP时要注意以下几点：1、不要超过100ms的窗口期。记住一定不要超过100ms，如果超过了，你的应用会表现得没反应。通过DevTools关注它，了解是否超出了100ms。 2、认真设计动画。想象下，你在运行一个动画，做一些位移和透明度得改变，然后你决定运行另外一个动画，它需要大量得预计算，这会打断之前运行中的动画，这种情况很糟糕。这里的关键是保证你的预计算工作是在空闲时间或上面说过的100ms窗口期内完成的，这两个动画不会互相阻断。 3、内容会失真。当你使用scale和transform，一些元素会失真。上面说过，我会调整一点结构，来不失真的使用FLIP，不过这可能有争议。 总结我喜欢用FLIP来考虑动画的实现，因为它让JS和CSS配合的很好，用JS来计算，但用CSS处理动画过程，你不需要用CSS来实现动画，虽然你可以只用简单的Web Animations API或JS，或什么其他的简单的方式。主要的一点是，你正在降低每帧的复杂性和成本(通常意味着transform和opacity)，以尽量为用户提供最好的体验。 所以，使用FLIP吧。 参考 Aerotwist - FLIP Your Animations FLIP技术给Web布局带来的变化_JavaScript, FLIP, Animation, Web动画 教程_w3cplus","categories":[{"name":"动效","slug":"动效","permalink":"http://example.com/categories/%E5%8A%A8%E6%95%88/"}],"tags":[]},{"title":"Debouncing和Throttling","slug":"Debouncing和Throttling","date":"2019-02-27T15:26:09.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/Debouncing和Throttling/","permalink":"http://example.com/js/Debouncing%E5%92%8CThrottling/","excerpt":"","text":"Debounce 和 throttle是两种相似但不同的技术，用来控制函数在一定时间内执行的次数，简单说是用来限频。 当我们的函数操作DOM事件时，对函数用使用Debounce 或 throttle非常有用，因为我们在DOM事件和函数执行之间加了我们的控制层。 当我们通过触控板、滚轮、拖动滚动条来滚动时，会很轻易的每秒触发30次滚动事件，但是在智能手机上测试缓慢的滚动时，每秒可触发多达100次滚动事件，你的滚动回调为这样高频的执行做好准备了吗？ 2011年，Twitter网站突现了一个问题:页面在向下滚动时变得卡顿。John Resig发表了一篇关于这个问题的博文，来解释直接将昂贵的函数绑定到滚动事件上多么糟糕。John建议在滚动回调函数外包裹一个每250ms执行一次的循环，这样滚动回调不与滚动事件耦合，简单的避免了用户体验差的问题。 现在处理类似的高频事件的方式稍微复杂点。下面介绍Debounce, Throttle, 和 requestAnimationFrame。 DebounceDebounce可以把连续的多个调用分组到一个调用中。 想象下你在电梯里，门开始关闭，突然有人要进来，电梯没有改变楼层，门又开了，每次要关门时，如果有人要进来，都会再次开门，电梯在推迟移动到其他楼层，但在优化资源。 Leading edge（或immediate）在事件发生间隔变的足够长之前，Debounce会一直等待，推迟回调的执行，为什么不立刻触发回调的执行，看起来就像没有用Debounce处理过，只是在快速连续的触发事件停止之前不要再次执行，就像下面这样： 在underscore.js中, 这个参数叫immediate，而不是leading。 Debounce实现第一次看到Debounce的js实现是2009年John Hann的博文《Debouncing Javascript Methods》，此后不久，Ben Alman创建了一个jQuery插件(不再维护)，一年后，Jeremy Ashkenas将其添加到underscore.js中。后来，它被添加到Lodash中。这3种实现在内部略有不同，但它们的接口几乎相同。有一段时间underscore.js采用了Lodash的debounce&#x2F;throttle实现，直到我2013年发现了_.debounce函数的一个bug，这两种实现逐渐不同。 Lodash在_.debounce和_.throttle中添加了更多的功能。原来的immediate参数被leading和trailing替代，你可以选择1个，或两个都选，默认只用trailing。 本文没有介绍的maxWait参数（目前仅在Lodash中）是非常有用的，实际上，在lodash源码中可以看到，Throttle函数的定义_.debounce中有maxWait。 Debounce示例1、resize在拖动大小控制器来resize浏览器窗口时，可以触发很多次resize事件。完整示例请查看原文Debouncing and Throttling Explained Through Examples | CSS-Tricks 12345678910111213141516171819// Based on http://www.paulirish.com/2009/throttled-smartresize-jquery-event-handler/$(document).ready(function()&#123; var $win = $(window); var $left_panel = $(&#x27;.left-panel&#x27;); var $right_panel = $(&#x27;.right-panel&#x27;); function display_info($div) &#123; $div.append($win.width() + &#x27; x &#x27; + $win.height() + &#x27;&lt;br&gt;&#x27;); &#125; $(window).on(&#x27;resize&#x27;, function()&#123; display_info($left_panel); &#125;); $(window).on(&#x27;resize&#x27;, _.debounce(function() &#123; display_info($right_panel); &#125;, 400));&#125;); resize事件中我们用了默认参数trailing，因为我们只关心浏览器停止改变窗口大小后的最终值。 2、按键输入关联的ajax请求为什么我们要在用户还是输入的时候每50ms向服务器发ajax请求呢？_.debounce可以帮助我们避免这种冗余的造作，只在用户停止输入的时候发送请求。 此时，使用leading参数没有意思，我们要等最后一个字符输入完毕。 1234567891011121314151617181920212223242526272829$(document).ready(function()&#123; var $statusKey = $(&#x27;.status-key&#x27;); var $statusAjax = $(&#x27;.status-ajax&#x27;); var intervalId; // 仅为示例模拟的假ajax function make_ajax_request(e)&#123; var that = this; $statusAjax.html(&#x27;等待时间足够了，现在进行数据请求&#x27;); intervalId = setTimeout(function()&#123; $statusKey.html(&#x27;在这里输入，当你停止输入的时候我会发现&#x27;); $statusAjax.html(&#x27;&#x27;); $(that).val(&#x27;&#x27;); // 清空输入值 &#125;,2000); &#125; // 当事件被触发时显示信息 $(&#x27;.autocomplete&#x27;) .on(&#x27;keydown&#x27;, function ()&#123; $statusKey.html(&#x27;等待后续输入... &#x27;); clearInterval(intervalId); &#125;) // 显示数据请求什么时候会发生（停止输入后） // 为了示例更明显，设置了超长的1.3s等待时长。实际情况下最好等待50ms到200ms $(&#x27;.autocomplete&#x27;).on(&#x27;keydown&#x27;, _.debounce(make_ajax_request, 1300));&#125;); 类似的情形还可能是等到用户停止输入再校验其输入内容，然后显示类似“您的密码位数太短”的提示语。 如何使用debounce和throttle以及其中的坑自己写一个debounce&#x2F;throttle功能是很容易的，或者随便从哪个博客里复制一个。我的建议是直接用underscore或Lodash，如果你只需要_.debounce和_.throttle方法，你可以用Lodash的自定义构建输出一个2KB的压缩包，构建命令很简单： 12npm i -g lodash-clilodash include = debounce, throttle 也就是说，一般会通过webpack/browserify/rollup使用lodash/throttle和lodash/debounce或lodash.throttle和lodash.debounce的包。 一个常见的坑是不止1次的调用_.debounce函数： 1234567// 错误的写法$(window).on(&#x27;scroll&#x27;, function() &#123; _.debounce(doSomething, 300);&#125;);// 正确的写法$(window).on(&#x27;scroll&#x27;, _.debounce(doSomething, 200)); 如果你有需要，在Lodash和underscore.js中，为需要debounce的函数创建一个变量将允许我们调用私有方法debounced_version.cancel()。 12345var debounced_version = _.debounce(doSomething, 200);$(window).on(&#x27;scroll&#x27;, debounced_version);// 如果有需要debounced_version.cancel(); Throttle使用了_.throttle,我们不允许函数每X毫秒执行超过1次。 throttle和debounce的主要区别是，throttle保证函数有规律的执行，至少每X毫秒执行1次。和debounce一样，throttle也包含在Ben的插件、underscore.js和lodash中。 Throttle示例1、无限滚动一个常见的例子：用户向下滑动你的无限滚动页面，你需要检查用户距离页面底部有多远，如果快滑到底部了，你就要通过ajax请求更多的数据来填充页面。此时_.debounce没用了，它只能在用户停止滑动时触发，而我们需要在用户滑到底之前请求数据，_.throttle可以让我们不停的检查距离底部的距离。 12345678910111213141516171819202122// 这是一个很简单的例子。// 或许你想用类似下面这样的插件// https://github.com/infinite-scroll/infinite-scroll/blob/master/jquery.infinitescroll.js$(document).ready(function()&#123; // 每200ms检查一下滚动位置 $(document).on(&#x27;scroll&#x27;, _.throttle(function()&#123; check_if_needs_more_content(); &#125;, 200)); function check_if_needs_more_content() &#123; pixelsFromWindowBottomToBottom = 0 + $(document).height() - $(window).scrollTop() -$(window).height(); // console.log($(document).height()); // console.log($(window).scrollTop()); // console.log($(window).height()); // console.log(pixelsFromWindowBottomToBottom); if (pixelsFromWindowBottomToBottom &lt; 200)&#123; // 这里会有一个数据请求 $(&#x27;body&#x27;).append($(&#x27;.item&#x27;).clone()); &#125; &#125;&#125;); requestAnimationFrame (rAF)requestAnimationFrame是另外一种限频方式，可以看成_.throttle(dosomething, 16)，但是会精确很多，因为它是为了更好的精确度的浏览器原生API。 考虑下列优缺点后，我们可以酌情用rAF API替代throttle。 优点：1、目标是60fps (16ms每帧)，但内部将决定如何安排渲染的最佳时间；2、非常简单且标准的API，将来不会改变，便于维护。 缺点：1、我们需要开始或取消rAF，不像.debounce或.throttle自己在内部处理；2、如果浏览器页面不是激活状态，rAF将不会执行，虽然对于滚动、鼠标、键盘事件这并不重要；3、虽然所有的现代浏览器支持rAF，但是IE9、Opera Mini、和老的安卓并不支持，现在还需要打补丁；4、node.js不支持rAF，所以不能用在服务端的文件系统事件。 一般来说，如果js函数需要重新计算元素位置，比如直接渲染或动效，我会用requestAnimationFrame。发起数据请求，增加或移除控制动效的css class，我会用_.debounce或_.throttle，这样可以更低的执行频率，比如200ms，而不是16ms。你或许觉得rAF应该在underscore或lodash中实现，但他们都没有，因为它用途少并容易直接使用。 rAF示例Paul Lewis写的的《Leaner, Meaner, Faster Animations with requestAnimationFrame》一步一步的介绍了这个例子的逻辑，受他的启发，这里我只会介绍requestAnimation用在滚动上的例子。 我把_.throttle限频16ms和rAF放在一起对比，实现类似的功能，但极有可能rAF在复杂的场景会表现的更好。 123456789101112131415161718192021222324252627282930313233// 参考https://www.html5rocks.com/en/tutorials/speed/animations/#debouncing-scroll-eventsvar latestKnownScrollY = 0, ticking = false, item = document.querySelectorAll(&#x27;.item&#x27;);function update() &#123; // 重置tick，使我们能够捕获下一个onScroll ticking = false; item[0].style.width = latestKnownScrollY + 100 + &#x27;px&#x27;;&#125;function onScroll() &#123; latestKnownScrollY = window.scrollY; // 不支持IE8 requestTick();&#125;function requestTick() &#123; if(!ticking) &#123; requestAnimationFrame(update); &#125; ticking = true;&#125;window.addEventListener(&#x27;scroll&#x27;, onScroll, false);// THROTTLEfunction throttled_version() &#123; item[1].style.width = window.scrollY + 100 + &#x27;px&#x27;;&#125;window.addEventListener(&#x27;scroll&#x27;, _.throttle(throttled_version, 16), false); rAF的一个更好的例子我在headroom.js库中看到过，它把逻辑解耦并封装。 总结使用debounce, throttle 和 requestAnimationFrame来优化事件处理，它们略有不同，但都很有用，并相互补充。 方法 作用 debounce 把突然爆发的大量事件（比如连续快速的按键输入）组合成1个事件 throttle 保证每X毫秒执行1次的持续的事件流。比如每200ms检查下滚动位置来触发CSS动效 requestAnimationFrame 代替throttle。当你在屏幕上重新计算并渲染元素，想保证变化或动效的流畅时使用。注意：不支持IE9","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"页面性能优化之减少回流的10种方法","slug":"页面性能优化之减少回流的10种方法","date":"2019-02-22T15:19:36.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"css/页面性能优化之减少回流的10种方法/","permalink":"http://example.com/css/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E7%9A%8410%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"尽管web页面达到2MB的性能仍然是一个热门话题,页面越平滑，用户体验越好，转化率越高!也就是说，我对添加肤浅的CSS3动画或不考虑后果地操纵多个DOM元素感到内疚。在应用视觉效果时，浏览器中使用了两个术语: 重绘Repaints当变化影响元素可见性而不是布局的时候会发生一次重绘，比如：opacity, background-color, visibility, 和 outline，重绘的代价很高，因为浏览器必须检查DOM中所有其他节点的可见性——一个或多个节点可能在更改的元素下面变得可见。 重排Reflows重排对性能的影响巨大，需要重新计算所有元素的位置和尺寸，这会导致部分或整个文档的重新渲染，改变单个元素能影响所有的子节点、父节点和兄弟节点。 重绘和重排时，用户和web页面都不能做其它事情，在极端情况下，css会让js执行变慢，比如滚动不稳定、界面响应不灵敏。 触发重排途径添加、删除或改变元素的可见性首先是显而易见的:使用JavaScript更改DOM将导致回流。 添加、删除或改变css样式直接应用CSS样式或更改类名都可能会改变布局。比如更改元素的宽度会影响同一DOM树及其周围的所有元素。 CSS3 animations 和 transitions动画的每一帧都会引起回流。 用offsetWidth 和 offsetHeight读取元素的offsetWidth 和 offsetHeight属性会触发回流来计算属性值。 用户行为一些用户行为会触发回流，比如：hover、在输入框中输入文本、调整窗口大小、更改字体大小、切换样式表或字体。 回流的影响各不相同，比如相同的操作一些浏览器表现的更好，一些元素的渲染开销会更大。幸运的是，你可以使用一些通用技巧来提升性能. 通用技巧使用最佳布局方案不要使用内联样式和table布局！内联样式会在下载HTML时影响布局，并触发额外的reflow。table布局开销很大，因为解析器需要多次传递去计算单元格维度，使用table时应用fixed定位有一定的优化效果，因为列的宽度是基于标题行的内容。主页面布局应用flexbox也会有性能影响，因为在HTML下载的时候，flex items的位置和尺寸可能会变化。 最小化CSS规则的数量css规则越少，重排越快，要尽量避免复杂的css选择器。如果您使用的是Bootstrap这样的框架，那么这一点尤其成问题——很少有站点使用了框架提供的所有样式。像Unused CSS、uCSS、grunt-uncss和gulp-uncss这样的工具可以显著减少样式定义和文件大小。 最小化DOM层级稍微复杂一点——减小DOM树大小和每个分支的元素数量。文档越小越浅，回流越快。如果不需要支持古老的浏览器，可以删除不必要的包裹元素。 更改class的DOM层级要低改变class的DOM层级尽可能的低（比如：没有多个深度嵌套的元素），这能减小重排的范围，只重排必要的元素，本质上，只有在对嵌套子节点的影响很小的情况下，才将类更改应用于父节点，比如包装器。 从文档流中移除复杂的动效通过使用position: absolute; 或者 position: fixed;来使有动效的元素脱离文档流，这可以在不影响文档流中的其它元素的情况下更新尺寸和位置。 更新隐藏的元素通过display: none;来隐藏的元素在改变时不会触发重绘和重排，可以的话，在元素可见之前进行更改。 批量更新元素所有的DOM操作在同一次动作中进行能提高性能。下面这个简单的例子会引起3次重排： 1234var myelement = document.getElementById(&#x27;myelement&#x27;);myelement.width = &#x27;100px&#x27;;myelement.height = &#x27;200px&#x27;;myelement.style.margin = &#x27;10px&#x27;; 我们可以把上面的操作减少到1次重排，这也更便于维护： 12var myelement = document.getElementById(&#x27;myelement&#x27;);myelement.classList.add(&#x27;newstyles&#x27;); 12345.newstyles &#123; width: 100px; height: 200px; margin: 10px;&#125; 你也可以最小化接触DOM的时间，假设你要创建这个项目列表: item1 item2 item3 每次添加1个元素会触发7次重排-1次添加，3次添加，3次添加li里面的文本。但是，可以使用DOM片段实现1次reflow，并先在内存中构建节点： 1234567891011var i, li, frag = document.createDocumentFragment(), ul = frag.appendChild(document.createElement(&#x27;ul&#x27;));for (i = 1; i &lt;= 3; i++) &#123; li = ul.appendChild(document.createElement(&#x27;li&#x27;)); li.textContent = &#x27;item &#x27; + i;&#125;document.body.appendChild(frag); 限制受影响的元素避免大量元素受影响的情况。比如：一个选项卡内容控件，单击一个选项卡将激活不同的内容块。如果每个内容块的高度不同，则会影响周围的元素。可以为容器设置固定高度或从文档流中删除控件来提高性能。 意识到平滑影响性能每帧移动1px看起来平滑，但是低端机会卡顿，每帧移动4px，需要1&#x2F;4的重排，且可能只会稍微不那么平滑。 用浏览器工具分析渲染问题所有主流浏览器都提供工具来强调重排如何影响性能。","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[]},{"title":"hexo博客","slug":"hexo博客","date":"2018-11-26T15:11:58.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"doc/hexo博客/","permalink":"http://example.com/doc/hexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"基本操作写博客1hexo new 博客标题 本地服务1hexo serve 构建并发布1hexo g -d // hexo generate --deploy的简写 版本控制与持续集成使用了上面的构建并发布流程后，你一定会觉得这个过程很麻烦，而且源文件不方便管理，虽然可以开一个分支放源文件，但还是很麻烦对不对？下面来看一个更好的处理办法，新的push出现时自动构建并发布：1、Content Repo：Hexo生成出来的静态网站放到GitHub Pages时用到的repo;2、Source Repo：hexo源文件的repo；3、使用CI工具（比如AppVeyor官网）来完成下面的功能：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo。 使用AppVeyor来建立CI的方法参考本文第二个参考链接。 个性化文章链接更改_config.yml中的下列配置： 1permalink: :category/:title/ 图片资源处理放在 source&#x2F;images 文件夹中。然后通过 ![](/images/image.jpg) 的方法访问它们。 1![hexo serve](/img/serve.png) // 上面hexo serve的图片写法 参考 文档 | Hexo Hexo的版本控制与持续集成 | formulahendry","categories":[{"name":"doc","slug":"doc","permalink":"http://example.com/categories/doc/"}],"tags":[]},{"title":"git常用操作","slug":"git常用操作","date":"2018-11-23T15:00:08.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"git/git常用操作/","permalink":"http://example.com/git/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"下载下载git bash下载meld 基础配置新建.gitconfig和meld.sh文件放到C:\\Users\\win .gitconfig文件内容如下： 123456789101112131415161718192021222324[user] email = youremail@xxx.xx name = yourname[gui] encoding = UTF-8[core] autocrlf = true[color] ui = auto[branch] autosetuprebase = always[alias] st = status ci = commit co = checkout br = branch rb = reset --hard ORIG_HEAD unstage = reset HEAD lg = log --graph --oneline --decorate last = log --graph --oneline --decorate origin/master..HEAD[merge] tool = meld[diff] external = C:/Users/win/meld.sh meld.sh文件内容如下： 12#!/bin/shmeld $2 $5 升级配置设置SSH Key123456789#生成公钥ssh-keygen -t rsa -C &quot;youremail@xxx.xx&quot;#查看公钥（复制公钥后到git仓库公钥管理页面添加key）cat ~/.ssh/id_rsa.pub#验证是否添加成功ssh -T git@xxx.xxx.xxx#Welcome to GitLab, xx! // 成功会出现这行欢迎 多个ssh-key的管理假设你已经完成了上面的步骤，现在要给github添加一个用户和ssh-key。 12#生成公钥ssh-keygen -t rsa -C &quot;youremail@gmail.com&quot; 现在进入.ssh目录，比如我的电脑用户名是win，我的目录就是C:\\Users\\win.ssh，把刚刚生成的id_rsa_github和id_rsa_github.pub都放进来。新建config文件，内容如下： 12345Host github.com HostName github.com IdentityFile C:\\\\Users\\\\win\\\\.ssh\\\\id_rsa_github PreferredAuthentications publickey User youremail@gmail.com 现在.ssh目录结构如下： 现在本地都配置完毕，去github添加刚刚生成的id_rsa_github.pub。然后验证ssh-key是否都添加成功。 因为有多个用户了，上面的.gitconfig全局配置了用户信息。那么在特殊项目，就需要局部设置用户信息： 1234#局部配置，优先使用局部配置,如果没有局部配置，默认用全局配置cd ~/workspace/github_project/git config user.name &#x27;yourename&#x27;git config user.email &#x27;youremail@gmail.com&#x27; 解决LF和CRLF问题推荐使用方法2。 1、.gitconfig文件里的autocrlf设置为true true会在git commit的时候自动把commit的内容里的CRLF转成LF，保证远端代码都是LF 2、vscode用户，在USER SETTINGS里增加配置项”files.eol”: “\\n” files.eol配置项含义：The default end of line character. Use \\n for LF and \\r\\n for CRLF. 3、vscode安装插件，保存是自动转换成LF。比如EditorConfig for VS Code. 统一commit message格式根据 angular 规范提交 commit， 这样 history 看起来更加清晰，还可以自动生成 changelog。 提交 commit 的类型，包括以下几种： feat: 新功能 fix: 修复问题 docs: 修改文档 style: 修改代码格式(空格、换行、分号等)，不影响代码逻辑 refactor: 重构代码（既不是修复bug，也不是增加新特性），理论上不影响现有功能 perf: 提升性能 test: 增加修改测试用例 chore: 修改工具相关（包括但不限于文档、代码生成等） deps: 升级依赖,修改版本号 还可以借助插件来写符合规范的message: 1234567891011# Making your repo Commitizen-friendly# For this example, we&#x27;ll be setting up our repo to use AngularJS&#x27;s commit message convention also known as conventional-changelog.# First, install the Commitizen cli tools:npm install commitizen -g# Next, initialize your project to use the cz-conventional-changelog adapter by typing:commitizen init cz-conventional-changelog --save-dev --save-exact# commit codes(use git cz to instead git commit)# For detailed explanation on how things work, checkout the [guide](https://github.com/commitizen/cz-cli).git cz 常用命令基础操作12345678910111213141516171819# initgit clone git@git.xxx.xx:xx/xxx.git# add codesgit add# push codesgit push origin feature-name# new branchgit checkout mastergit checkout -b feature-new# merge branches(use rebase to instead merge)# For example, merge feature-new to master(please make master up-to-date with &#x27;origin/master&#x27; at first)git checkout feature-newgit rebase mastergit checkout mastergit rebase feature-new tag12345678910111213141516#新建标签git tag v1.0 // 打在最近的commit上git tag v0.9 f52c633 // 打在f52c633上git tag -a v0.9 -m &quot;blablabla...&quot; // 指定标签信息#查看标签git tag // 查看所有标签git show v0.9 // 查看单个标签，可以看到标签信息#删除标签git tag -d v0.1 //删除本地标签git push origin :refs/tags/v0.1 //删除远程标签#推送标签git push origin v1.0 // 推送单个标签git push origin --tags // 推送所有标签","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[]},{"title":"Promise总结","slug":"Promise总结","date":"2018-10-15T14:40:33.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"js/Promise总结/","permalink":"http://example.com/js/Promise%E6%80%BB%E7%BB%93/","excerpt":"","text":"Promise简介Promise对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。由浏览器直接支持。 打开Chrome的控制台输入new Promise(function () &#123;&#125;);后可以看到浏览器的Promise对象: 下面创建一个Promise: 123let promise = new Promise(function(resolve, reject) &#123; // executor (the producing code, &quot;singer&quot;)&#125;); 传给new Promise作为参数的函数叫做executor。Promise创建后自动运行。 promise有两个内部变量：1、state — 初始值pending, 会变成fulfilled或rejected。2、result — 初始值undefined，代码运行后的任意值。 当executor运作完毕，会执行它两个参数中的一个函数： resolve(value) - 代表executor运作结果是成功的，并且：1、把state变成fulfilled；2、把result变成value。reject(error) - 代表executor运作出错，并且：1、把state变成rejected；2、把result变成error。 Promise状态是resolved或rejected时叫做settled。 上面说到executor运行完毕会执行resolve或reject，其实executor只会执行一次resolve或reject，并且result改变后不能再改变。resolve&#x2F;reject只会接收1个参数，后续的都会被忽略。 123456let promise = new Promise(function(resolve, reject) &#123; resolve(&quot;done&quot;); reject(new Error(&quot;…&quot;)); // ignored setTimeout(() =&gt; resolve(&quot;…&quot;)); // ignored&#125;); reject的参数推荐使用Error对象。 demo1、处理 rejection有两种方式去处理 rejection 123456let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 1000);&#125;);// .catch(f) is the same as promise.then(null, f)promise.catch(alert); // shows &quot;Error: Whoops!&quot; after 1 second .catch(f) 只是 .then(null, f)的简写。 12345// 方式一promise.then(f1, f2);// 方式二promise.then(f1).catch(f2); 注意方式一和二的不同：f1发生的错误只会在方式二的catch中处理。 2、Unhandled rejections发生错误时，Promise状态变成reject，execution跳转到最近的rejection handler，如果没有rejection handler，错误就会变成stuck。比如： 12345new Promise(function() &#123; noSuchFunction(); // Error here (no such function)&#125;); // no .catch attached// catch ReferenceError: b is not defined 或者： 12345678910// a chain of promises without .catch at the endnew Promise(function() &#123; throw new Error(&quot;Whoops!&quot;);&#125;).then(function() &#123; // ...something...&#125;).then(function() &#123; // ...something else...&#125;).then(function() &#123; // ...but no catch after it!&#125;); 大多数js引擎会全局处理这种错误，我们可以在console中看到。 要尽量避免出现Unhandled rejections，可以在promise调用链末尾增加catch。 3、触发Promise异常 主动调用 reject 方法 抛出异常（exception） 1234567new Promise((resolve, reject) =&gt; &#123; a = b;&#125;).catch((val) =&gt; &#123; console.log(&#x27;catch&#x27;, val);&#125;)// catch ReferenceError: b is not defined 4、链式调用123456789101112131415161718new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;成功1&#x27;); &#125;, 1000);&#125;).then((val) =&gt; &#123; console.log(&#x27;then1&#x27;, val); return &#x27;成功2&#x27;&#125;).then((val) =&gt; &#123; console.log(&#x27;then2&#x27;, val); return Promise.resolve(&#x27;成功3&#x27;)&#125;).then((val) =&gt; &#123; console.log(&#x27;then3&#x27;, val); return &#x27;成功4&#x27;&#125;)// then1 成功1// then2 成功2// then3 成功3 注意then的返回值，链式调用时，前一个then的返回值决定后一个then的val。 通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 5、.then&#x2F;.catch是异步的1234567891011121314151617console.log(&#x27;javascript start&#x27;);setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&#x27;promise1&#x27;); resolve();&#125;).then(() =&gt; &#123; console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;javascript end&#x27;);// javascript start// promise1// javascript end// promise2// setTimeout 123456789new Promise((resolve) =&gt; &#123; console.log(&#x27;a&#x27;) resolve(&#x27;b&#x27;) console.log(&#x27;c&#x27;)&#125;).then((data) =&gt; &#123; console.log(data)&#125;)// a c b 构造函数中的executor执行是同步的，输出 a, 执行 resolve 函数，将 Promise 对象状态置为 resolved，输出 c。同时注册这个 Promise 对象的回调 then 函数。整个脚本执行完，stack 清空。event loop 检查到 stack 为空，再检查 microtask 队列中是否有任务，发现了 Promise 对象的 then 回调函数产生的 microtask，推入 stack，执行。输出 b，event loop的列队为空，stack 为空，脚本执行完毕。 microtask：在当前 task 执行完，准备进行 I&#x2F;O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作(microtask)，使得浏览器渲染和原生运算变得更加流畅。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 microtask。 原生的setTimeout就算是将延迟设置为 0 也会有 4 ms 的延迟，会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。 Promise 所说的异步执行，只是将 Promise 构造函数中 resolve，reject 方法和注册的 callback 转化为 eventLoop的 microtask&#x2F;Promise Job，并放到 Event Loop 队列中等待执行，也就是Javascript单线程中的“异步执行”。 Promise实现原理自行阅读参考的后3个链接 参考 Promise - JavaScript | MDN Promises, async&#x2F;await Promises&#x2F;A+ 剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类 · Issue #3 · xieranmaya&#x2F;blog 写一个符合 Promises&#x2F;A+ 规范并可配合 ES7 async&#x2F;await 使用的 Promise - 知乎","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[]},{"title":"Markdown常用语法手册","slug":"markdown概要","date":"2018-10-12T11:09:37.000Z","updated":"2024-08-06T08:57:38.660Z","comments":true,"path":"doc/markdown概要/","permalink":"http://example.com/doc/markdown%E6%A6%82%E8%A6%81/","excerpt":"","text":"常用语法1. 斜体和粗体这是 斜体，这是 粗体。 2. 分级标题在行首加井号表示不同级别的标题 (H1-H6)，例如：## H2, ### H3 3. 外链这是去往 本人博客 的链接。 4. 无序列表 无序列表项 一 无序列表项 二 5. 有序列表 有序列表项 一 有序列表项 二 6. 文字引用 整理知识，学习笔记 发布日记，杂文，所见所想 野火烧不尽，春风吹又生。 野火烧不尽，春风吹又生。 7. 行内代码块让我们聊聊 html。 8. 代码块123456789101112131415/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125; 9. 插入图像 10. 删除线这是一段错误的文本。 11. 绘制表格 Syntax Description Header Title Paragraph Text 使用:对齐 Syntax Description Test Text Header Title Here’s this Paragraph Text And more 参考文档Markdown 语法速查表","categories":[{"name":"doc","slug":"doc","permalink":"http://example.com/categories/doc/"}],"tags":[]}],"categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"},{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"},{"name":"图像处理","slug":"图像处理","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"ai","slug":"ai","permalink":"http://example.com/categories/ai/"},{"name":"动效","slug":"动效","permalink":"http://example.com/categories/%E5%8A%A8%E6%95%88/"},{"name":"node","slug":"node","permalink":"http://example.com/categories/node/"},{"name":"doc","slug":"doc","permalink":"http://example.com/categories/doc/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[]}